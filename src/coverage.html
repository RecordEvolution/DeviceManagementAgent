
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">reagent/api/code_execution.go (0.0%)</option>
				
				<option value="file1">reagent/api/device_handshake.go (0.0%)</option>
				
				<option value="file2">reagent/api/ethernet.go (0.0%)</option>
				
				<option value="file3">reagent/api/external.go (0.0%)</option>
				
				<option value="file4">reagent/api/get_agent_logs.go (0.0%)</option>
				
				<option value="file5">reagent/api/get_agent_metadata.go (0.0%)</option>
				
				<option value="file6">reagent/api/get_app_logs.go (0.0%)</option>
				
				<option value="file7">reagent/api/get_container_images.go (0.0%)</option>
				
				<option value="file8">reagent/api/get_network_metadata.go (0.0%)</option>
				
				<option value="file9">reagent/api/get_storage_usage.go (0.0%)</option>
				
				<option value="file10">reagent/api/get_tunnel_state.go (0.0%)</option>
				
				<option value="file11">reagent/api/list_containers.go (0.0%)</option>
				
				<option value="file12">reagent/api/prune_images.go (0.0%)</option>
				
				<option value="file13">reagent/api/request_app_state.go (81.6%)</option>
				
				<option value="file14">reagent/api/system_operations.go (0.0%)</option>
				
				<option value="file15">reagent/api/terminal_management.go (0.0%)</option>
				
				<option value="file16">reagent/api/update_agent.go (0.0%)</option>
				
				<option value="file17">reagent/api/update_system.go (0.0%)</option>
				
				<option value="file18">reagent/api/wifi.go (0.0%)</option>
				
				<option value="file19">reagent/api/write_file.go (0.0%)</option>
				
				<option value="file20">reagent/apps/app_manager.go (0.3%)</option>
				
				<option value="file21">reagent/apps/build_app.go (0.0%)</option>
				
				<option value="file22">reagent/apps/cancel_transitions.go (8.0%)</option>
				
				<option value="file23">reagent/apps/crashloop.go (0.0%)</option>
				
				<option value="file24">reagent/apps/fail_present.go (0.0%)</option>
				
				<option value="file25">reagent/apps/fail_run.go (0.0%)</option>
				
				<option value="file26">reagent/apps/publish_app.go (0.0%)</option>
				
				<option value="file27">reagent/apps/pull_and_run_app.go (0.0%)</option>
				
				<option value="file28">reagent/apps/pull_app.go (0.0%)</option>
				
				<option value="file29">reagent/apps/remove_app.go (0.0%)</option>
				
				<option value="file30">reagent/apps/removed_present.go (0.0%)</option>
				
				<option value="file31">reagent/apps/run_app.go (0.0%)</option>
				
				<option value="file32">reagent/apps/state_machine.go (12.5%)</option>
				
				<option value="file33">reagent/apps/state_observer.go (0.2%)</option>
				
				<option value="file34">reagent/apps/stop_and_build_app.go (0.0%)</option>
				
				<option value="file35">reagent/apps/stop_and_publish_app.go (0.0%)</option>
				
				<option value="file36">reagent/apps/stop_app.go (0.0%)</option>
				
				<option value="file37">reagent/apps/uninstall_app.go (0.0%)</option>
				
				<option value="file38">reagent/apps/update_app.go (0.0%)</option>
				
				<option value="file39">reagent/common/constants.go (0.0%)</option>
				
				<option value="file40">reagent/common/types.go (0.0%)</option>
				
				<option value="file41">reagent/common/utils.go (0.0%)</option>
				
				<option value="file42">reagent/config/config.go (0.0%)</option>
				
				<option value="file43">reagent/debounce/debounce.go (0.0%)</option>
				
				<option value="file44">reagent/errdefs/helpers.go (0.0%)</option>
				
				<option value="file45">reagent/errdefs/is.go (0.0%)</option>
				
				<option value="file46">reagent/messenger/dummy.go (50.0%)</option>
				
				<option value="file47">reagent/messenger/mock_nexus_client_new.go (63.3%)</option>
				
				<option value="file48">reagent/messenger/test_helpers.go (100.0%)</option>
				
				<option value="file49">reagent/messenger/wamp.go (54.4%)</option>
				
				<option value="file50">reagent/safe/utils.go (0.0%)</option>
				
				<option value="file51">reagent/testutil/config.go (0.0%)</option>
				
				<option value="file52">reagent/testutil/mock_messenger.go (0.0%)</option>
				
				<option value="file53">reagent/tunnel/frp.go (0.0%)</option>
				
				<option value="file54">reagent/tunnel/tunnel.go (0.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "bufio"
        "context"
        "errors"
        "fmt"
        "io"
        "os/exec"
        "reagent/common"
        "reagent/messenger"
        "reagent/messenger/topics"
        "reagent/terminal"
        "time"
)

func (ex *External) codeExecutionHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        args := response.Arguments
        if args == nil || args[0] == nil </span><span class="cov0" title="0">{
                return nil, errors.New("args array should not be empty")
        }</span>

        <span class="cov0" title="0">argsDict, ok := args[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("first param should be a dict")
        }</span>

        <span class="cov0" title="0">cmdName, ok := argsDict["cmd"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cmd param should be a string")
        }</span>

        <span class="cov0" title="0">blocking, ok := argsDict["blocking"].(bool)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("blocking param should be a boolean")
        }</span>

        <span class="cov0" title="0">var cmdArgsInterface []interface{}
        if argsDict["args"] != nil </span><span class="cov0" title="0">{
                cmdArgsInterface, ok = argsDict["args"].([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("args param should be an array of primitive values")
                }</span>
        }

        <span class="cov0" title="0">commandTimeout := uint64(1000)
        if argsDict["timeout"] != nil </span><span class="cov0" title="0">{
                commandTimeout, ok = argsDict["timeout"].(uint64)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("the timeout param should be an uint64")
                }</span>
        }

        <span class="cov0" title="0">var cmdArgs []string
        for _, arg := range cmdArgsInterface </span><span class="cov0" title="0">{
                cmdArgs = append(cmdArgs, fmt.Sprint(arg))
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(cmdName, cmdArgs...)
        cmd.Stderr = cmd.Stdout

        var err error
        var cmdStdout io.ReadCloser

        if blocking </span><span class="cov0" title="0">{
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return &amp;messenger.InvokeResult{Arguments: []interface{}{string(output)}}, nil</span>
        } else<span class="cov0" title="0"> {
                cmdStdout, err = cmd.StdoutPipe()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                time.Sleep(time.Millisecond * time.Duration(commandTimeout))
                scanner := bufio.NewScanner(cmdStdout)
                for scanner.Scan() </span><span class="cov0" title="0">{
                        output := scanner.Text()
                        topicAffix := fmt.Sprintf("%s_%d", topics.CmdExecutionPrefix, cmd.Process.Pid)
                        topic := common.BuildExternalApiTopic(ex.Config.ReswarmConfig.SerialNumber, topicAffix)

                        ex.Messenger.Publish(topics.Topic(topic), []interface{}{output}, nil, nil)
                }</span>
        }()

        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("command failed to run: %s", err.Error())
        }</span>

        <span class="cov0" title="0">respArgs := []interface{}{common.Dict{"pid": cmd.Process.Pid}}

        return &amp;messenger.InvokeResult{Arguments: respArgs}, nil</span>
}

func (ex *External) initDeviceTerm(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        var err error

        callerID := fmt.Sprint(response.Details["caller_authid"])
        pseudoTerminal := terminal.GetPseudoTerminal(callerID)

        if pseudoTerminal == nil </span><span class="cov0" title="0">{

                pseudoTerminal, err = terminal.NewPseudoTerminal(callerID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">res := pseudoTerminal.Setup(ex.Config, ex.Messenger)

                return &amp;messenger.InvokeResult{Arguments: []interface{}{res}}, nil</span>
        }

        <span class="cov0" title="0">res := common.Dict{
                "sessionID":   pseudoTerminal.SessionID,
                "writeTopic":  pseudoTerminal.WriteTopic,
                "dataTopic":   pseudoTerminal.DataTopic,
                "resizeTopic": pseudoTerminal.ResizeTopic,
        }

        return &amp;messenger.InvokeResult{Arguments: []interface{}{res}}, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "context"
        "reagent/common"
        "reagent/messenger"
        "time"
)

func (ex *External) deviceHandshakeHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        kwargs := common.Dict{
                "utp": time.Now().Format(time.RFC3339),
                "id":  ex.Config.ReswarmConfig.SerialNumber,
        }

        return &amp;messenger.InvokeResult{ArgumentsKw: kwargs}, nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "context"
        "errors"
        "reagent/common"
        "reagent/errdefs"
        "reagent/messenger"
)

func (ex *External) listEthernetDevices(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("READ", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to list ethernet devices"))
        }</span>

        <span class="cov0" title="0">ethernetDevices, err := ex.Network.ListEthernetDevices()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ethernetDeviceList := make([]interface{}, len(ethernetDevices))
        for i, ethernetDevice := range ethernetDevices </span><span class="cov0" title="0">{
                ethernetDeviceList[i] = common.Dict{
                        "interfaceName": ethernetDevice.InterfaceName,
                        "mac":           ethernetDevice.MAC,
                        "ipv4":          ethernetDevice.IPv4AddressData,
                        "ipv6":          ethernetDevice.IPv6AddressData,
                        "method":        ethernetDevice.Method,
                }
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{Arguments: ethernetDeviceList}, nil</span>
}

func (ex *External) updateIPConfigHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("NETWORK", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to update ip config"))
        }</span>

        <span class="cov0" title="0">if response.Arguments == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse args, payload is missing")
        }</span>

        <span class="cov0" title="0">payloadArg := response.Arguments[0]
        payload, ok := payloadArg.(map[string]interface{})

        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse payload")
        }</span>

        <span class="cov0" title="0">methodKw := payload["method"]
        method, ok := methodKw.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse method parameter")
        }</span>

        <span class="cov0" title="0">macKw := payload["mac"]
        mac, ok := macKw.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse mac parameter")
        }</span>

        <span class="cov0" title="0">interfaceKw := payload["interfaceName"]
        interfaceName, ok := interfaceKw.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse interface parameter")
        }</span>

        <span class="cov0" title="0">if methodKw != nil &amp;&amp; method == "auto" </span><span class="cov0" title="0">{
                err := ex.Network.EnableDHCP(mac, interfaceName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
        }

        <span class="cov0" title="0">ipv4Kw := payload["ipv4"]
        ipv4, ok := ipv4Kw.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse ipv4 parameter")
        }</span>

        <span class="cov0" title="0">prefixKw := payload["prefix"]
        prefix, ok := prefixKw.(uint64)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse prefix parameter")
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, ex.Network.SetIPv4Address(mac, interfaceName, ipv4, uint32(prefix))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "context"
        "fmt"
        "reagent/apps"
        "reagent/common"
        "reagent/config"
        "reagent/container"
        "reagent/filesystem"
        "reagent/logging"
        "reagent/messenger"
        "reagent/messenger/topics"
        "reagent/network"
        "reagent/persistence"
        "reagent/privilege"
        "reagent/system"
        "reagent/terminal"
        "reagent/tunnel"
        "strconv"
        "strings"

        "github.com/rs/zerolog/log"
)

// External is the API that is meant to be used by the externally exposed WAMP topics.
// It contains all the functionality available in the reagent.
type External struct {
        Container       container.Container
        Messenger       messenger.Messenger
        LogMessenger    messenger.Messenger
        Database        persistence.Database
        TunnelManager   tunnel.TunnelManager
        Network         network.Network
        Privilege       *privilege.Privilege
        Filesystem      *filesystem.Filesystem
        System          *system.System
        AppManager      *apps.AppManager
        TerminalManager *terminal.TerminalManager
        LogManager      *logging.LogManager
        Config          *config.Config
}

// RegistrationHandler is the handler that gets executed whenever a registered topic gets called.
type RegistrationHandler = func(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error)

// ! dynamically created registrations (terminal / logger) can be found in their respective packages
func (ex *External) getTopicHandlerMap() map[topics.Topic]RegistrationHandler <span class="cov0" title="0">{
        return map[topics.Topic]RegistrationHandler{
                topics.RequestAppState:        ex.requestAppStateHandler,
                topics.WriteToFile:            ex.writeToFileHandler,
                topics.Handshake:              ex.deviceHandshakeHandler,
                topics.GetImages:              ex.getImagesHandler,
                topics.RequestTerminalSession: ex.requestTerminalSessHandler,
                topics.StartTerminalSession:   ex.startTerminalSessHandler,
                topics.StopTerminalSession:    ex.stopTerminalSession,

                topics.ListWiFiNetworks:        ex.listWiFiNetworksHandler,
                topics.AddWiFiConfiguration:    ex.addWiFiConfigurationHandler,
                topics.ScanWifiNetworks:        ex.wifiScanHandler,
                topics.RemoveWiFiConfiguration: ex.removeWifiHandler,
                topics.SelectWiFiNetwork:       ex.selectWiFiNetworkHandler,
                topics.ListEthernetDevices:     ex.listEthernetDevices,
                topics.UpdateIPv4Configuration: ex.updateIPConfigHandler,
                topics.SystemReboot:            ex.systemRebootHandler,
                topics.SystemShutdown:          ex.systemShutdownHandler,
                topics.SystemRestartAgent:      ex.systemRestartAgentHandler,
                topics.RestartWifi:             ex.wifiRebootHandler,
                topics.UpdateAgent:             ex.updateReagent,
                topics.PruneImages:             ex.pruneImageHandler,
                topics.GetAgentMetaData:        ex.getAgentMetadataHandler,
                topics.ListContainers:          ex.listContainersHandler,
                topics.GetAgentLogs:            ex.getAgentLogs,
                topics.GetNetworkMetaData:      ex.getNetworkDataHandler,
                topics.GetAppLogHistory:        ex.getAppLogHistoryHandler,
                topics.GetTunnelState:          ex.getTunnelState,

                topics.GetOSRelease:     ex.getOSReleaseHandler,
                topics.DownloadOSUpdate: ex.downloadOSUpdateHandler,
                topics.InstallOSUpdate:  ex.installOSUpdateHandler,

                topics.ExecuteCommand:     ex.codeExecutionHandler,
                topics.InitDeviceTerminal: ex.initDeviceTerm,
                topics.GetIPv4Addresses:   ex.getCurrentIPAddresses,
                topics.GetStorageData:     ex.getStorageDataHandler,
        }
}</span>

func wrapDetails(handler RegistrationHandler) RegistrationHandler <span class="cov0" title="0">{
        return func(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) </span><span class="cov0" title="0">{
                if response.Details["caller_authid"] == "system" </span><span class="cov0" title="0">{
                        requestorAccountKeyKw := response.ArgumentsKw["requestor_account_key"]

                        if requestorAccountKeyKw == nil </span><span class="cov0" title="0">{
                                if len(response.Arguments) == 0 </span><span class="cov0" title="0">{
                                        return handler(ctx, response)
                                }</span>

                                <span class="cov0" title="0">argsOne := response.Arguments[0]
                                argsDict, ok := argsOne.(common.Dict)
                                if !ok </span><span class="cov0" title="0">{
                                        return handler(ctx, response)
                                }</span>

                                <span class="cov0" title="0">argsRequestorAccountKey := argsDict["requestor_account_key"]
                                if argsRequestorAccountKey != nil </span><span class="cov0" title="0">{
                                        requestorAccountKeyKw = argsRequestorAccountKey
                                }</span> else<span class="cov0" title="0"> {
                                        return handler(ctx, response)
                                }</span>
                        }

                        <span class="cov0" title="0">value, err := strconv.Atoi(fmt.Sprint(requestorAccountKeyKw))
                        if err == nil </span><span class="cov0" title="0">{
                                response.Details["caller_authid"] = uint64(value)
                        }</span>
                }

                <span class="cov0" title="0">return handler(ctx, response)</span>
        }
}

// RegisterAll registers all the static topics exposed by the reagent
func (ex *External) RegisterAll() error <span class="cov0" title="0">{
        serialNumber := ex.Config.ReswarmConfig.SerialNumber
        topicHandlerMap := ex.getTopicHandlerMap()
        for topic, handler := range topicHandlerMap </span><span class="cov0" title="0">{
                // will register all topics, e.g.: re.mgmt.request_app_state
                fullTopic := common.BuildExternalApiTopic(serialNumber, string(topic))
                err := ex.Messenger.Register(topics.Topic(fullTopic), wrapDetails(handler), nil)
                if err != nil </span><span class="cov0" title="0">{
                        // on reconnect we will reregister, which could cause a already exists exception
                        if strings.Contains(err.Error(), "wamp.error.procedure_already_exists") </span><span class="cov0" title="0">{
                                log.Warn().Msgf("Tried to register already existing topic: %s", fullTopic)
                        }</span> else<span class="cov0" title="0"> {
                                return err
                        }</span>
                }
                <span class="cov0" title="0">log.Info().Msgf("Registered topic %s on the device", fullTopic)</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "context"
        "io/ioutil"
        "os"
        "reagent/common"
        "reagent/messenger"
)

func (ex *External) getAgentLogs(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        logFile := ex.Config.CommandLineArguments.LogFileLocation
        fileContents, err := ioutil.ReadFile(logFile)
        if err != nil </span><span class="cov0" title="0">{
                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fileContents = []byte("log file was not found")</span>
        }

        <span class="cov0" title="0">dict := common.Dict{
                "reagent.log": string(fileContents),
        }

        return &amp;messenger.InvokeResult{
                Arguments: []interface{}{dict},
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "context"
        "errors"
        "reagent/common"
        "reagent/embedded"
        "reagent/errdefs"
        "reagent/messenger"
        "reagent/release"
        "reagent/system"
)

func (ex *External) getAgentMetadataHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("READ", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to get agent metadata"))
        }</span>

        <span class="cov0" title="0">currentAgentVersion := release.GetVersion()
        OSVersion, err := system.GetOSVersion()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serialNumber := ex.Config.ReswarmConfig.SerialNumber

        reswarmModeEnabled := true //filesystem.PathExists("/opt/reagent/reswarm-mode")
        os, arch, variant := release.GetSystemInfo()
        dict := common.Dict{
                "os":           os,
                "arch":         arch,
                "variant":      variant,
                "version":      currentAgentVersion,
                "serialNumber": serialNumber,
                "canUpdate":    reswarmModeEnabled,
        }

        // frpc is now embedded in the binary
        frpVersion := embedded.FRP_VERSION
        frpIsLatest := true

        lastAgentVersion, err := ex.System.GetLatestVersion("re-agent")
        agentIsLatest := lastAgentVersion == currentAgentVersion
        if err == nil </span><span class="cov0" title="0">{
                dict["latestVersion"] = lastAgentVersion
                dict["latestTunnelVersion"] = frpVersion
                dict["latestAgentVersion"] = lastAgentVersion
                dict["hasLatest"] = agentIsLatest &amp;&amp; frpIsLatest
        }</span>

        <span class="cov0" title="0">if OSVersion != "" </span><span class="cov0" title="0">{
                dict["OSVersion"] = OSVersion
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{
                Arguments: []interface{}{dict},
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "context"
        "errors"
        "fmt"
        "reagent/errdefs"
        "reagent/messenger"
)

func (ex *External) getAppLogHistoryHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("READ", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to get app log history"))
        }</span>

        <span class="cov0" title="0">args := response.Arguments

        if args == nil || args[0] == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("arguments are missing")
        }</span>

        <span class="cov0" title="0">argsDict, ok := args[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("first param should be a dict")
        }</span>

        <span class="cov0" title="0">containerName, ok := argsDict["containerName"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid value for containerName")
        }</span>

        <span class="cov0" title="0">history, err := ex.LogManager.GetLogHistory(containerName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{
                Arguments: []interface{}{history},
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "context"
        "errors"
        "reagent/errdefs"
        "reagent/messenger"
        "time"
)

func (ex *External) getImagesHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("READ", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to read docker images"))
        }</span>

        <span class="cov0" title="0">ctx, cancelFunc := context.WithTimeout(context.Background(), time.Millisecond*2000)
        result, err := ex.Container.ListImages(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                cancelFunc()
                return nil, err
        }</span>

        <span class="cov0" title="0">cancelFunc()

        // See https://github.com/golang/go/wiki/InterfaceSlice
        images := make([]interface{}, 0)
        for _, image := range result </span><span class="cov0" title="0">{
                images = append(images, image)
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{
                Arguments: images,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "context"
        "net"
        "reagent/messenger"
)

func (ex *External) getNetworkDataHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        intInfo := make([]interface{}, 0)
        interfaces, _ := net.Interfaces()
        for _, interf := range interfaces </span><span class="cov0" title="0">{

                if addrs, err := interf.Addrs(); err == nil </span><span class="cov0" title="0">{
                        for _, addr := range addrs </span><span class="cov0" title="0">{
                                intInfo = append(intInfo, addr)
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{
                Arguments: intInfo,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "context"
        "errors"
        "reagent/common"
        "reagent/errdefs"
        "reagent/messenger"
)

func (ex *External) getStorageDataHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("READ", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to get storage data"))
        }</span>

        <span class="cov0" title="0">stats := common.GetStats()

        result := common.Dict{
                "cpu_count":           stats.CPUCount,
                "cpu_usage":           stats.CPUUsagePercent,
                "memory_total":        stats.MemoryTotal,
                "memory_used":         stats.MemoryUsed,
                "memory_available":    stats.MemoryAvailable,
                "storage_total":       stats.StorageTotal,
                "storage_used":        stats.StorageUsed,
                "storage_free":        stats.StorageFree,
                "docker_apps_total":   stats.DockerAppsTotal,
                "docker_apps_used":    stats.DockerAppsUsed,
                "docker_apps_free":    stats.DockerAppsFree,
                "docker_apps_mounted": stats.DockerAppsMounted,
        }

        return &amp;messenger.InvokeResult{
                Arguments: []interface{}{result},
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "context"
        "reagent/messenger"
)

func (ex *External) getTunnelState(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        state, err := ex.TunnelManager.GetState()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{
                Arguments: []interface{}{state},
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "context"
        "errors"
        "reagent/errdefs"
        "reagent/messenger"
)

func (ex *External) listContainersHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("READ", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to list containers"))
        }</span>

        <span class="cov0" title="0">containers, err := ex.Container.GetContainers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{Arguments: []interface{}{containers}}, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// prune_images

package api

import (
        "context"
        "errors"
        "fmt"
        "reagent/common"
        "reagent/errdefs"
        "reagent/messenger"
)

func (ex *External) pruneImageHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("MAINTAIN", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to prune images"))
        }</span>

        <span class="cov0" title="0">args := response.Arguments
        options := common.Dict{}

        if args != nil || args[0] != nil </span><span class="cov0" title="0">{
                argsDict, ok := args[0].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("first param should be a dict")
                }</span>

                <span class="cov0" title="0">options = argsDict</span>
        }

        <span class="cov0" title="0">if options["all"] != nil </span><span class="cov0" title="0">{
                all, ok := options["all"].(bool)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("all value for container prune is not a boolean")
                }</span>

                <span class="cov0" title="0">if all </span><span class="cov0" title="0">{
                        output, err := ex.Container.PruneAllImages()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;messenger.InvokeResult{Arguments: []interface{}{string(output)}}, nil</span>
                }
        }

        <span class="cov0" title="0">_, err = ex.Container.PruneDanglingImages()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package api

import (
        "context"
        "errors"
        "fmt"
        "reagent/common"
        "reagent/config"
        "reagent/errdefs"
        "reagent/messenger"
        "reagent/safe"
        "strconv"

        "github.com/rs/zerolog/log"
)

func (ex *External) requestAppStateHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        payload, err := responseToTransitionPayload(ex.Config, response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: remove check and implement proper stream canceling for Docker Compose
        <span class="cov0" title="0">if payload.CancelTransition &amp;&amp; payload.DockerCompose != nil </span><span class="cov0" title="0">{
                return nil, errors.New("canceling docker compose apps not yet implemented")
        }</span>

        <span class="cov0" title="0">err = ex.AppManager.CreateOrUpdateApp(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">safe.Go(func() </span><span class="cov0" title="0">{
                err = ex.AppManager.RequestAppState(payload)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msgf("failed to request app state")
                        return
                }</span>
        })

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}

// responseToTransitionPayload parses a Messenger response to a generic common.TransitionPayload struct.
// Values that were not provided will be nil.
func responseToTransitionPayload(config *config.Config, result messenger.Result) (common.TransitionPayload, error) <span class="cov10" title="39">{
        kwargs := result.ArgumentsKw
        // details := result.Details

        appKeyKw := kwargs["app_key"]
        appNameKw := kwargs["app_name"]
        stageKw := kwargs["stage"]
        requestedStateKw := kwargs["target_state"]
        manuallyRequestedStateKw := kwargs["manually_requested_state"]
        releaseKeyKw := kwargs["release_key"]
        newReleaseKeyKw := kwargs["new_release_key"]
        currentStateKw := kwargs["current_state"]
        currentStateKw2 := kwargs["state"]
        requestorAccountKeyKw := kwargs["requestor_account_key"]
        requestorAccountKeyKw2 := kwargs["account_id"]
        environmentKw := kwargs["environment"]
        portsKw := kwargs["ports"]
        // dtaKeyKw := kwargs["device_to_app_key"]
        versionKw := kwargs["version"]
        presentVersionKw := kwargs["present_version"]
        newestVersionKw := kwargs["newest_version"]
        requestUpdateKw := kwargs["request_update"]
        cancelTransitionKw := kwargs["cancel_transition"]
        environmentTemplateKw := kwargs["environment_template"]
        dockerComposeKw := kwargs["docker_compose"]
        newDockerComposeKw := kwargs["new_docker_compose"]
        dockerCredentialsKw := kwargs["docker_credentials"]

        var appKey uint64
        var releaseKey uint64
        var newReleaseKey uint64
        var requestorAccountKey uint64
        var requestorAccountKey2 uint64
        var appName string
        var stage string
        var requestedState string
        var manuallyRequestedState string
        var currentState string
        var currentState2 string
        var version string
        var presentVersion string
        var newestVersion string
        var requestUpdate bool
        var cancelTransition bool
        var ok bool
        var ports []interface{}
        var environmentTemplate map[string]interface{}
        var environment map[string]interface{}
        var dockerCompose map[string]interface{}
        var newDockerCompose map[string]interface{}
        var dockerCredentials map[string]common.DockerCredential

        // TODO: can be simplified with parser function, but unneccessary
        if appKeyKw != nil </span><span class="cov10" title="39">{
                appKey, ok = appKeyKw.(uint64)
                if !ok </span><span class="cov1" title="1">{
                        return common.TransitionPayload{}, fmt.Errorf("%w app_key", errdefs.ErrFailedToParse)
                }</span>
                <span class="cov9" title="38">if appKey == 0 </span><span class="cov1" title="1">{
                        return common.TransitionPayload{}, fmt.Errorf("%w app_key", errdefs.ErrMissingFromPayload)
                }</span>
        }

        <span class="cov9" title="37">if appNameKw != nil </span><span class="cov9" title="37">{
                appName, ok = appNameKw.(string)
                if !ok </span><span class="cov1" title="1">{
                        return common.TransitionPayload{}, fmt.Errorf("%w appName", errdefs.ErrFailedToParse)
                }</span>
                <span class="cov9" title="36">if appName == "" </span><span class="cov1" title="1">{
                        return common.TransitionPayload{}, fmt.Errorf("%w appName", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="35">if stageKw != nil </span><span class="cov9" title="35">{
                stage, ok = stageKw.(string)
                if !ok </span><span class="cov1" title="1">{
                        return common.TransitionPayload{}, fmt.Errorf("%w stage", errdefs.ErrFailedToParse)
                }</span>
                <span class="cov9" title="34">if stage == "" </span><span class="cov1" title="1">{
                        return common.TransitionPayload{}, fmt.Errorf("%w stage", errdefs.ErrMissingFromPayload)
                }</span>
        }

        <span class="cov9" title="33">if requestedStateKw != nil </span><span class="cov9" title="33">{
                requestedState, ok = requestedStateKw.(string)
                if !ok </span><span class="cov1" title="1">{
                        return common.TransitionPayload{}, fmt.Errorf("%w requestedState", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="32">if manuallyRequestedStateKw != nil </span><span class="cov1" title="1">{
                manuallyRequestedState, ok = manuallyRequestedStateKw.(string)
                if !ok </span><span class="cov0" title="0">{
                        return common.TransitionPayload{}, fmt.Errorf("%w manuallyRequestedState", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="32">if currentStateKw != nil </span><span class="cov1" title="1">{
                currentState, ok = currentStateKw.(string)
                if !ok </span><span class="cov0" title="0">{
                        return common.TransitionPayload{}, fmt.Errorf("%w currentState", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="32">if currentStateKw2 != nil </span><span class="cov1" title="1">{
                currentState2, ok = currentStateKw2.(string)
                if !ok </span><span class="cov0" title="0">{
                        return common.TransitionPayload{}, fmt.Errorf("%w currentState2", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="32">if requestorAccountKeyKw != nil </span><span class="cov3" title="3">{
                requestorAccountKey, ok = requestorAccountKeyKw.(uint64)
                if !ok </span><span class="cov2" title="2">{
                        requestorAccountKeyString, ok := requestorAccountKeyKw.(string)
                        if !ok </span><span class="cov0" title="0">{
                                return common.TransitionPayload{}, fmt.Errorf("%w requestorAccountKey", errdefs.ErrFailedToParse)
                        }</span>

                        <span class="cov2" title="2">value, err := strconv.Atoi(requestorAccountKeyString)
                        if err != nil </span><span class="cov1" title="1">{
                                return common.TransitionPayload{}, err
                        }</span>
                        <span class="cov1" title="1">requestorAccountKey = uint64(value)</span>
                }
        }

        <span class="cov9" title="31">if requestorAccountKeyKw2 != nil </span><span class="cov1" title="1">{
                requestorAccountKey2, ok = requestorAccountKeyKw2.(uint64)
                if !ok </span><span class="cov0" title="0">{
                        requestorAccountKeyString2, ok := requestorAccountKeyKw2.(string)
                        if !ok </span><span class="cov0" title="0">{
                                return common.TransitionPayload{}, fmt.Errorf("%w requestorAccountKey2", errdefs.ErrFailedToParse)
                        }</span>

                        <span class="cov0" title="0">value, err := strconv.Atoi(requestorAccountKeyString2)
                        if err != nil </span><span class="cov0" title="0">{
                                return common.TransitionPayload{}, err
                        }</span>
                        <span class="cov0" title="0">requestorAccountKey2 = uint64(value)</span>
                }
        }

        <span class="cov9" title="31">if releaseKeyKw != nil </span><span class="cov2" title="2">{
                releaseKey, ok = releaseKeyKw.(uint64)
                if !ok </span><span class="cov1" title="1">{
                        releaseKeyString, ok := releaseKeyKw.(string)
                        if !ok </span><span class="cov0" title="0">{
                                return common.TransitionPayload{}, fmt.Errorf("%w releaseKeyString", errdefs.ErrFailedToParse)
                        }</span>

                        // due to a bug the release key can be stored as string...
                        <span class="cov1" title="1">parsedReleaseKey, err := strconv.ParseUint(releaseKeyString, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return common.TransitionPayload{}, err
                        }</span>

                        <span class="cov1" title="1">releaseKey = parsedReleaseKey</span>
                }
        }

        <span class="cov9" title="31">if newReleaseKeyKw != nil </span><span class="cov1" title="1">{
                newReleaseKey, ok = newReleaseKeyKw.(uint64)
                if !ok </span><span class="cov0" title="0">{
                        return common.TransitionPayload{}, fmt.Errorf("%w newReleaseKey", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="31">if versionKw != nil </span><span class="cov1" title="1">{
                version, ok = versionKw.(string)
                if !ok </span><span class="cov0" title="0">{
                        return common.TransitionPayload{}, fmt.Errorf("%w version", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="31">if newestVersionKw != nil </span><span class="cov1" title="1">{
                newestVersion, ok = newestVersionKw.(string)
                if !ok </span><span class="cov0" title="0">{
                        return common.TransitionPayload{}, fmt.Errorf("%w newestVersion", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="31">if presentVersionKw != nil </span><span class="cov1" title="1">{
                presentVersion, ok = presentVersionKw.(string)
                if !ok </span><span class="cov0" title="0">{
                        return common.TransitionPayload{}, fmt.Errorf("%w presentVersion", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="31">if requestUpdateKw != nil </span><span class="cov2" title="2">{
                requestUpdate, ok = requestUpdateKw.(bool)
                if !ok </span><span class="cov1" title="1">{
                        return common.TransitionPayload{}, fmt.Errorf("%w requestUpdate", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="30">if cancelTransitionKw != nil </span><span class="cov1" title="1">{
                cancelTransition, ok = cancelTransitionKw.(bool)
                if !ok </span><span class="cov0" title="0">{
                        return common.TransitionPayload{}, fmt.Errorf("%w cancelTransition", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="30">if environmentKw != nil </span><span class="cov2" title="2">{
                environment, ok = environmentKw.(map[string]interface{})
                if !ok </span><span class="cov1" title="1">{
                        return common.TransitionPayload{}, fmt.Errorf("%w environment", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="29">if environmentTemplateKw != nil </span><span class="cov1" title="1">{
                environmentTemplate, ok = environmentTemplateKw.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return common.TransitionPayload{}, fmt.Errorf("%w environment template", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="29">if portsKw != nil </span><span class="cov2" title="2">{
                ports, ok = portsKw.([]interface{})
                if !ok </span><span class="cov1" title="1">{
                        return common.TransitionPayload{}, fmt.Errorf("%w ports", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="28">if dockerComposeKw != nil </span><span class="cov2" title="2">{
                dockerCompose, ok = dockerComposeKw.(map[string]interface{})
                if !ok </span><span class="cov1" title="1">{
                        return common.TransitionPayload{}, fmt.Errorf("%w docker compose", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="27">if newDockerComposeKw != nil </span><span class="cov0" title="0">{
                newDockerCompose, ok = newDockerComposeKw.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return common.TransitionPayload{}, fmt.Errorf("%w new docker compose", errdefs.ErrFailedToParse)
                }</span>
        }

        <span class="cov9" title="27">if dockerCredentialsKw != nil </span><span class="cov4" title="4">{
                // Output map to store the parsed credentials
                dockerCredentials = make(map[string]common.DockerCredential)

                dockerCredentialsMap, ok := dockerCredentialsKw.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return common.TransitionPayload{}, fmt.Errorf("%w docker credentials", errdefs.ErrFailedToParse)
                }</span>

                // Iterate over the input map
                <span class="cov4" title="4">for key, value := range dockerCredentialsMap </span><span class="cov4" title="5">{
                        // Assert the value to map[string]interface{}
                        valMap, ok := value.(map[string]interface{})
                        if !ok </span><span class="cov1" title="1">{
                                return common.TransitionPayload{}, fmt.Errorf("%w docker credentials", errdefs.ErrFailedToParse)
                        }</span>

                        // Extract username and password
                        <span class="cov4" title="4">username, usernameOK := valMap["username"].(string)
                        password, passwordOK := valMap["password"].(string)

                        // Check if the username and password exist and are strings
                        if !usernameOK || !passwordOK </span><span class="cov1" title="1">{
                                return common.TransitionPayload{}, fmt.Errorf("%w docker credentials", errdefs.ErrFailedToParse)
                        }</span>

                        // Assign the credentials to the output map
                        <span class="cov3" title="3">dockerCredentials[key] = common.DockerCredential{
                                Username: username,
                                Password: password,
                        }</span>
                }
        }

        // callerAuthIDString := details["caller_authid"]

        // callerAuthID, err := strconv.Atoi(callerAuthIDString.(string))

        // callerAuthID, ok := callerAuthIDString.(string)
        // if !ok {
        //         return common.TransitionPayload{}, fmt.Errorf("Failed to parse callerAuthid")
        // }

        // happens where there is no app yet, for example, when you press stop on first build
        <span class="cov8" title="25">if requestedState == "" &amp;&amp; manuallyRequestedState != "" </span><span class="cov1" title="1">{
                requestedState = manuallyRequestedState
        }</span>

        <span class="cov8" title="25">if currentState == "" &amp;&amp; currentState2 != "" </span><span class="cov1" title="1">{
                currentState = currentState2
        }</span>

        <span class="cov8" title="25">if requestorAccountKey == 0 &amp;&amp; requestorAccountKey2 != 0 </span><span class="cov1" title="1">{
                requestorAccountKey = requestorAccountKey2
        }</span>

        <span class="cov8" title="25">payload := common.BuildTransitionPayload(appKey, appName, requestorAccountKey,
                common.Stage(stage), common.AppState(currentState),
                common.AppState(requestedState), releaseKey, newReleaseKey, config,
        )

        payload.RequestUpdate = requestUpdate

        // Version used to publish a release
        payload.Version = version

        // Newest version that is available of app
        payload.NewestVersion = newestVersion

        // Version that is currently on the device
        payload.PresentVersion = presentVersion

        payload.EnvironmentVariables = environment
        payload.EnvironmentTemplate = environmentTemplate

        payload.Ports = ports
        payload.DockerCompose = dockerCompose
        payload.NewDockerCompose = newDockerCompose

        payload.CancelTransition = cancelTransition

        payload.DockerCredentials = dockerCredentials

        // registryToken is added before we transition state and is not part of the response payload
        return payload, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "context"
        "errors"
        "reagent/errdefs"
        "reagent/messenger"
        "reagent/safe"
        "time"

        "github.com/rs/zerolog/log"
)

func (ex *External) systemRebootHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("MAINTAIN", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to reboot device"))
        }</span>

        <span class="cov0" title="0">safe.Go(func() </span><span class="cov0" title="0">{
                time.Sleep(time.Second * 2)

                err = ex.System.Reboot()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to trigger reboot")
                }</span>
        })

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}

func (ex *External) systemShutdownHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("MAINTAIN", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to power off device"))
        }</span>

        <span class="cov0" title="0">safe.Go(func() </span><span class="cov0" title="0">{
                time.Sleep(time.Second * 2)

                err = ex.System.Poweroff()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to trigger poweroff")
                }</span>
        })

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}

func (ex *External) systemRestartAgentHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("MAINTAIN", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to restart agent"))
        }</span>

        <span class="cov0" title="0">safe.Go(func() </span><span class="cov0" title="0">{
                time.Sleep(time.Second * 2)

                err = ex.System.RestartAgent()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to trigger restart agent")
                }</span>
        })

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package api

import (
        "context"
        "errors"
        "reagent/common"
        "reagent/errdefs"
        "reagent/messenger"
)

func (ex *External) startTerminalSessHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("DEVELOP", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to start a terminal session"))
        }</span>

        <span class="cov0" title="0">if response.Arguments == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse args, payload is missing")
        }</span>

        <span class="cov0" title="0">payloadArg := response.Arguments[0]
        payload, ok := payloadArg.(map[string]interface{})

        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse payload")
        }</span>

        <span class="cov0" title="0">sessionIDKw := payload["sessionID"]
        sessionID, ok := sessionIDKw.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse sessionID")
        }</span>

        <span class="cov0" title="0">registrationIDKw := payload["registrationID"]
        registrationID, ok := registrationIDKw.(uint64)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse registrationID")
        }</span>

        <span class="cov0" title="0">err = ex.TerminalManager.StartTerminalSession(sessionID, registrationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}

func (ex *External) stopTerminalSession(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("DEVELOP", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to start a terminal session"))
        }</span>

        <span class="cov0" title="0">if response.Arguments == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse args, payload is missing")
        }</span>

        <span class="cov0" title="0">payloadArg := response.Arguments[0]
        payload, ok := payloadArg.(map[string]interface{})

        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse payload")
        }</span>

        <span class="cov0" title="0">sessionIDKw := payload["sessionID"]
        sessionID, ok := sessionIDKw.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse sessionID")
        }</span>

        <span class="cov0" title="0">err = ex.TerminalManager.StopTerminalSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}

func (ex *External) requestTerminalSessHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("DEVELOP", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to start a terminal session"))
        }</span>

        <span class="cov0" title="0">if response.Arguments == nil </span><span class="cov0" title="0">{
                return nil, errors.New("no args found")
        }</span>

        <span class="cov0" title="0">payloadArg := response.Arguments[0]
        payload, ok := payloadArg.(map[string]interface{})

        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse payload")
        }</span>

        <span class="cov0" title="0">containerNameKw := payload["containerName"]
        containerName, ok := containerNameKw.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse containerName")
        }</span>

        <span class="cov0" title="0">termSess, err := ex.TerminalManager.RequestTerminalSession(containerName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>

        // this will be used by the frontend to register/call to the terminal session
        <span class="cov0" title="0">responseData := common.Dict{
                "dataTopic":   termSess.DataTopic,
                "writeTopic":  termSess.WriteTopic,
                "resizeTopic": termSess.ResizeTopic,
                "sessionID":   termSess.SessionID,
        }

        return &amp;messenger.InvokeResult{Arguments: []interface{}{responseData}}, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package api

import (
        "context"
        "errors"
        "reagent/common"
        "reagent/errdefs"
        "reagent/filesystem"
        "reagent/messenger"
        "reagent/messenger/topics"
)

func (ex *External) updateReagent(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("MAINTAIN", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to update reagent"))
        }</span>

        // reswarmModeEnabled, _ := filesystem.PathExists("/opt/reagent/reswarm-mode")
        // if !reswarmModeEnabled {
        //         return nil, errors.New("cannot update on non reswarm-mode enabled system")
        // }

        <span class="cov0" title="0">progressCallback := func(downloadProgress filesystem.DownloadProgress) </span><span class="cov0" title="0">{
                progress := common.Dict{
                        "increment":    downloadProgress.Increment,
                        "currentBytes": downloadProgress.CurrentBytes,
                        "fileSize":     downloadProgress.TotalFileSize,
                }

                serialNumber := ex.Config.ReswarmConfig.SerialNumber
                topic := common.BuildAgentUpdateProgress(serialNumber)
                ex.LogMessenger.Publish(topics.Topic(topic), []interface{}{progress}, nil, nil)
        }</span>

        <span class="cov0" title="0">updateResult, err := ex.System.UpdateSystem(progressCallback, true)
        if err != nil </span><span class="cov0" title="0">{
                if !errdefs.IsInProgress(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;messenger.InvokeResult{Arguments: []interface{}{updateResult}}, nil</span>
        }

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{Arguments: []interface{}{updateResult}}, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package api

import (
        "context"
        "errors"
        "fmt"
        "os"
        "reagent/common"
        "reagent/errdefs"
        "reagent/filesystem"
        "reagent/messenger"
        "reagent/messenger/topics"
        "reagent/system"
        "strings"
)

func (ex *External) getOSReleaseHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("READ", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to get os release data"))
        }</span>

        // current release information
        <span class="cov0" title="0">osReleaseCurrent, err := system.GetOSReleaseCurrent()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">osReleaseVersionSplit := strings.Split(osReleaseCurrent["VERSION"], "-")
        osReleaseVersion := ""
        osReleaseBuildTime := ""
        if len(osReleaseVersionSplit) == 3 </span><span class="cov0" title="0">{
                osReleaseVersion = strings.Trim(osReleaseVersionSplit[0], "v")
                osReleaseBuildTime = osReleaseVersionSplit[2]
        }</span>
        <span class="cov0" title="0">currentOSRelease := system.OSRelease{
                Name:      osReleaseCurrent["Name"],
                Version:   osReleaseVersion,
                BuildTime: osReleaseBuildTime,
        }

        // latest release information
        osReleaseLatest, err := system.GetOSReleaseLatest()
        if err != nil </span><span class="cov0" title="0">{
                // Systems that do not have /etc/os-release can return an empty value
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return &amp;messenger.InvokeResult{
                                Arguments: []interface{}{},
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">latestOSRelease := system.OSRelease{
                Name:      fmt.Sprint(osReleaseLatest[""]),
                Version:   fmt.Sprint(osReleaseLatest["version"]),
                BuildTime: fmt.Sprint(osReleaseLatest["buildtime"]),
        }

        // merge both
        osrelease := common.Dict{
                "currentRelease": common.Dict{
                        "Name":      currentOSRelease.Name,
                        "Version":   currentOSRelease.Version,
                        "BuildTime": currentOSRelease.BuildTime,
                },
                "latestRelease": common.Dict{
                        "Name":      latestOSRelease.Name,
                        "Version":   latestOSRelease.Version,
                        "BuildTime": latestOSRelease.BuildTime,
                },
        }

        return &amp;messenger.InvokeResult{
                Arguments: []interface{}{osrelease},
        }, nil</span>

}

func (ex *External) downloadOSUpdateHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("MAINTAIN", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to update reswarmos"))
        }</span>

        // prepare callback monitoring progress of download
        <span class="cov0" title="0">progressCallback := func(dp filesystem.DownloadProgress) </span><span class="cov0" title="0">{
                progress := common.Dict{
                        "increment":    dp.Increment,
                        "currentBytes": dp.CurrentBytes,
                        "fileSize":     dp.TotalFileSize,
                }

                serialNumber := ex.Config.ReswarmConfig.SerialNumber
                topic := common.BuildDownloadOSUpdateProgress(serialNumber)
                ex.LogMessenger.Publish(topics.Topic(topic), []interface{}{progress}, nil, nil)
        }</span>

        // start downloading...
        <span class="cov0" title="0">err = system.GetOSUpdate(progressCallback)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}

func (ex *External) installOSUpdateHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("MAINTAIN", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to update reswarmos"))
        }</span>

        // prepare callback monitoring progress of OS installation
        <span class="cov0" title="0">progressCallback := func(operationName string, progressPercent uint64) </span><span class="cov0" title="0">{
                progress := common.Dict{
                        "operationName":   operationName,
                        "progressPercent": progressPercent,
                }

                serialNumber := ex.Config.ReswarmConfig.SerialNumber
                topic := common.BuildInstallOSUpdateProgress(serialNumber)
                ex.LogMessenger.Publish(topics.Topic(topic), []interface{}{progress}, nil, nil)
        }</span>

        // start installing OS bundle...
        <span class="cov0" title="0">err = system.InstallOSUpdate(progressCallback)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package api

import (
        "context"
        "errors"
        "reagent/common"
        "reagent/errdefs"
        "reagent/messenger"
        "reagent/network"
)

func (ex *External) listWiFiNetworksHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("READ", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to list wifi networks"))
        }</span>

        <span class="cov0" title="0">wifis, err := ex.Network.ListWifiNetworks()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ipv4, ipv6, err := ex.Network.GetActiveWirelessDeviceConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // convert to slice to be passed on
        <span class="cov0" title="0">wifiList := make([]interface{}, len(wifis))
        for i, wifi := range wifis </span><span class="cov0" title="0">{
                wifiList[i] = common.Dict{
                        "mac":       wifi.MAC,
                        "ssid":      wifi.SSID,
                        "channel":   wifi.Channel,
                        "signal":    wifi.Signal,
                        "security":  wifi.SecurityType,
                        "frequency": wifi.Frequency,
                        "known":     wifi.Known,
                        "current":   wifi.Current,
                }
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{
                Arguments: wifiList,
                ArgumentsKw: common.Dict{
                        "ipv4": ipv4,
                        "ipv6": ipv6,
                },
        }, nil</span>
}

func (ex *External) getCurrentIPAddresses(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        ipv4Addresses, err := network.GetIPv4Addresses()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{Arguments: []interface{}{ipv4Addresses}}, nil</span>
}

func (ex *External) removeWifiHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("NETWORK", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to remove wifi config"))
        }</span>

        <span class="cov0" title="0">payloadArg := response.Arguments
        if len(payloadArg) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("args for add wifi config is empty")
        }</span>

        <span class="cov0" title="0">payload, ok := payloadArg[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("argument 1 of args is not a dictionary type")
        }</span>

        <span class="cov0" title="0">ssidToRemove, ok := payload["ssid"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse ssid, invalid type")
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, ex.Network.RemoveWifi(ssidToRemove)</span>
}

func (ex *External) wifiScanHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        // TODO: privilege check

        return &amp;messenger.InvokeResult{}, ex.Network.Scan()
}</span>

func (ex *External) wifiRebootHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("NETWORK", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to restart wifi"))
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, ex.Network.Reload()</span>
}

func (ex *External) addWiFiConfigurationHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("NETWORK", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to add wifi config"))
        }</span>

        <span class="cov0" title="0">payload := response.Arguments
        if len(payload) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("args for add wifi config is empty")
        }</span>

        <span class="cov0" title="0">wifiDict, ok := payload[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("argument 1 of args is not a dictionary type")
        }</span>

        <span class="cov0" title="0">var mac string
        var securityType string

        ssidArg := wifiDict["ssid"]
        macArg := wifiDict["mac"]
        securityTypeArg := wifiDict["security"]
        passwordArg := wifiDict["password"]
        priorityArg := wifiDict["priority"]

        if macArg != nil </span><span class="cov0" title="0">{
                mac, ok = macArg.(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("failed to parse mac, invalid type")
                }</span>
        }

        <span class="cov0" title="0">if securityTypeArg != nil </span><span class="cov0" title="0">{
                securityType, ok = securityTypeArg.(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("failed to parse securityType, invalid type")
                }</span>
        }

        <span class="cov0" title="0">ssid, ok := ssidArg.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse ssid, invalid type")
        }</span>

        <span class="cov0" title="0">password, ok := passwordArg.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse password, invalid type")
        }</span>

        <span class="cov0" title="0">priority, ok := priorityArg.(uint64)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse priority, invalid type")
        }</span>

        <span class="cov0" title="0">wifiEntryPayload := network.WiFiCredentials{
                Ssid:         ssid,
                Passwd:       password,
                Priority:     uint32(priority),
                SecurityType: securityType,
        }

        err = ex.Network.AddWiFi(mac, wifiEntryPayload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}

func (ex *External) selectWiFiNetworkHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("NETWORK", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges to select wifi network"))
        }</span>

        <span class="cov0" title="0">payload := response.Arguments
        if len(payload) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("args for add wifi config is empty")
        }</span>

        <span class="cov0" title="0">wifiDict, ok := payload[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("argument 1 of args is not a dictionary type")
        }</span>

        <span class="cov0" title="0">ssidArg := wifiDict["ssid"]
        macArg := wifiDict["mac"]

        ssid, ok := ssidArg.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse ssid, invalid type")
        }</span>

        <span class="cov0" title="0">mac, ok := macArg.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse mac, invalid type")
        }</span>

        <span class="cov0" title="0">err = ex.Network.ActivateWiFi(mac, ssid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package api

import (
        "context"
        "errors"
        "fmt"
        "reagent/errdefs"
        "reagent/filesystem"
        "reagent/messenger"
        "reagent/safe"
)

func (ex *External) writeToFileHandler(ctx context.Context, response messenger.Result) (*messenger.InvokeResult, error) <span class="cov0" title="0">{
        privileged, err := ex.Privilege.Check("DEVELOP", response.Details)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !privileged </span><span class="cov0" title="0">{
                return nil, errdefs.InsufficientPrivileges(errors.New("insufficient privileges write data to device"))
        }</span>

        <span class="cov0" title="0">args := response.Arguments

        // Matches file_transfer.ts payload
        chunkArg := args[0]
        fileNameArg := args[1]
        containerNameArg := args[2]
        totalArg := args[3]
        idArg := args[4]

        fileName, ok := fileNameArg.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse name argument")
        }</span>

        <span class="cov0" title="0">chunk, ok := chunkArg.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse chunk argument")
        }</span>

        <span class="cov0" title="0">containerName, ok := containerNameArg.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse containerName argument")
        }</span>

        <span class="cov0" title="0">total, ok := totalArg.(uint64)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse total argument")
        }</span>

        <span class="cov0" title="0">id, ok := idArg.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse id argument")
        }</span>

        <span class="cov0" title="0">fileDir := ex.Messenger.GetConfig().CommandLineArguments.AppsBuildDir

        fileChunk := filesystem.FileChunk{
                ID:            id,
                FileName:      fileName,
                FilePath:      fileDir,
                Data:          chunk,
                ContainerName: containerName,
                Total:         total,
        }

        err = ex.Filesystem.Write(fileChunk)
        if err != nil </span><span class="cov0" title="0">{
                // Clean up the failed transfer and notify the app manager to reset state
                ex.Filesystem.CleanupFailedTransfer(containerName)
                safe.Go(func() </span><span class="cov0" title="0">{
                        ex.AppManager.HandleTransferFailure(containerName, err)
                }</span>)
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">var message string
        if fileChunk.Data == "BEGIN" </span><span class="cov0" title="0">{
                safe.Go(func() </span><span class="cov0" title="0">{
                        ex.LogManager.ClearLogHistory(containerName)
                }</span>)

                <span class="cov0" title="0">message = "Received first package on device!"</span>
        } else<span class="cov0" title="0"> if fileChunk.Data == "END" </span><span class="cov0" title="0">{
                message = "File transfer has finished, starting build..."
        }</span>

        <span class="cov0" title="0">if fileChunk.Data == "BEGIN" || fileChunk.Data == "END" </span><span class="cov0" title="0">{
                safe.Go(func() </span><span class="cov0" title="0">{
                        ex.LogManager.Write(containerName, message)
                }</span>)

                <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
        }

        <span class="cov0" title="0">activeTransfer := ex.Filesystem.GetActiveTransfer(containerName)
        if activeTransfer == nil </span><span class="cov0" title="0">{
                // received a chunk but no active stream was found
                return &amp;messenger.InvokeResult{}, nil
        }</span>

        <span class="cov0" title="0">safe.Go(func() </span><span class="cov0" title="0">{
                percentage := float64(activeTransfer.Current) / float64(activeTransfer.Total) * 100
                percentageString := fmt.Sprintf("%.3f%%", percentage)
                ex.LogManager.PublishProgress(containerName, fileName, "Transfer Progress:", percentageString)
        }</span>)

        <span class="cov0" title="0">return &amp;messenger.InvokeResult{}, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package apps

import (
        "context"
        "fmt"
        "os"
        "reagent/common"
        "reagent/errdefs"
        "reagent/messenger/topics"
        "reagent/safe"
        "reagent/store"
        "reagent/tunnel"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

func init() <span class="cov8" title="1">{
        // Set zerolog to use a pretty console writer for human-friendly logs
        log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: "2006-01-02 15:04:05"})
}</span>

type AppManager struct {
        AppStore      *store.AppStore
        StateMachine  *StateMachine
        StateObserver *StateObserver
        tunnelManager tunnel.TunnelManager
        crashLoops    map[*CrashLoop]struct{}
        crashLoopLock sync.Mutex
}

func NewAppManager(sm *StateMachine, as *store.AppStore, so *StateObserver, tm tunnel.TunnelManager) *AppManager <span class="cov0" title="0">{
        am := AppManager{
                StateMachine:  sm,
                StateObserver: so,
                AppStore:      as,
                tunnelManager: tm,
                crashLoops:    make(map[*CrashLoop]struct{}),
        }

        am.StateObserver.AppManager = &amp;am
        return &amp;am
}</span>

func (am *AppManager) syncPortState(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        log.Debug().Str("app", payload.AppName).Msg("syncPortState called")
        globalConfig := am.StateMachine.Container.GetConfig()

        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                log.Debug().Msg("Skipping syncPortState for DEV stage")
                return nil
        }</span>

        <span class="cov0" title="0">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                log.Warn().Msg("Tunneling feature is not supported on Windows")
                return nil
        }</span>

        <span class="cov0" title="0">app.StateLock.Lock()
        curAppState := app.CurrentState
        requestedState := app.RequestedState
        app.StateLock.Unlock()

        portRules, err := tunnel.InterfaceToPortForwardRule(payload.Ports)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to convert interface to port forward rule")
                return err
        }</span>

        <span class="cov0" title="0">newPorts := make([]common.PortForwardRule, 0)

        for _, portRule := range portRules </span><span class="cov0" title="0">{
                subdomain := tunnel.CreateSubdomain(tunnel.Protocol(portRule.Protocol), uint64(globalConfig.ReswarmConfig.DeviceKey), payload.AppName, portRule.Port)
                tunnelID := tunnel.CreateTunnelID(subdomain, portRule.Protocol)
                newConfig := tunnel.TunnelConfig{}
                if portRule.Active </span><span class="cov0" title="0">{
                        if requestedState == common.RUNNING || curAppState == common.RUNNING </span><span class="cov0" title="0">{
                                tnl := am.tunnelManager.Get(tunnelID)
                                if tnl != nil </span><span class="cov0" title="0">{
                                        log.Debug().Str("tunnelID", tunnelID).Msg("Tunnel already exists, skipping add")
                                }</span> else<span class="cov0" title="0"> {

                                        tunnelConfig := tunnel.TunnelConfig{
                                                Subdomain:  subdomain,
                                                AppName:    payload.AppName,
                                                Protocol:   tunnel.Protocol(portRule.Protocol),
                                                LocalPort:  portRule.Port,
                                                LocalIP:    portRule.LocalIP,
                                                RemotePort: portRule.RemotePort,
                                        }

                                        newConfig, err = am.tunnelManager.AddTunnel(tunnelConfig)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error().Stack().Err(err).Msg("Failed to add tunnel")
                                        }</span>
                                }
                                // continue
                        }
                } else<span class="cov0" title="0"> {
                        // Remove tunnel when it's not active (regardless of app state)
                        // Build the tunnel config to remove it from the file even if it's not in memory
                        tunnelConfig := tunnel.TunnelConfig{
                                Subdomain:  subdomain,
                                AppName:    payload.AppName,
                                Protocol:   tunnel.Protocol(portRule.Protocol),
                                LocalPort:  portRule.Port,
                                LocalIP:    portRule.LocalIP,
                                RemotePort: portRule.RemotePort,
                        }

                        log.Info().Str("tunnelID", tunnelID).Msg("Removing tunnel as it is not active")
                        err := am.tunnelManager.RemoveTunnel(tunnelConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Stack().Err(err).Msg("Failed to remove tunnel")
                        }</span>
                }

                <span class="cov0" title="0">newPort := portRule
                if newConfig.RemotePort != 0 </span><span class="cov0" title="0">{
                        newPort.RemotePort = newConfig.RemotePort
                        log.Info().Str("app", payload.AppName).Int("localPort", int(portRule.Port)).Int("remotePort", int(newPort.RemotePort)).Msg("Assigned new remote port for tunnel")
                }</span>
                <span class="cov0" title="0">newPorts = append(newPorts, newPort)</span>

        }

        <span class="cov0" title="0">np, err := tunnel.PortForwardRuleToInterface(newPorts)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to convert newPorts to interface")
                return err
        }</span>

        <span class="cov0" title="0">payload.Ports = np
        am.tunnelManager.SaveRemotePorts(payload)

        // err = am.AppStore.UpdateLocalRequestedState(payload)
        // if err != nil {
        //         return err
        // }

        am.UpdateTunnelState()

        return nil</span>
}

func (am *AppManager) UpdateTunnelState() error <span class="cov0" title="0">{
        updateTopic := common.BuildTunnelStateUpdate(am.StateMachine.Container.GetConfig().ReswarmConfig.SerialNumber)
        tunnelStates, err := am.tunnelManager.GetState()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get tunnel states")
                return err
        }</span>

        <span class="cov0" title="0">var args []interface{}
        for _, tunnelState := range tunnelStates </span><span class="cov0" title="0">{
                args = append(args, tunnelState)
        }</span>

        <span class="cov0" title="0">log.Debug().Msg("Publishing tunnel state update")
        return am.AppStore.Messenger.Publish(topics.Topic(updateTopic), args, nil, nil)</span>
}

func (am *AppManager) RequestAppState(payload common.TransitionPayload) error <span class="cov0" title="0">{
        app, err := am.AppStore.GetApp(payload.AppKey, payload.Stage)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get app in RequestAppState")
                return err
        }</span>

        <span class="cov0" title="0">app.StateLock.Lock()
        curAppState := app.CurrentState
        requestedAppState := app.RequestedState
        app.StateLock.Unlock()

        log.Debug().Str("app", payload.AppName).Str("from", string(curAppState)).Str("to", string(requestedAppState)).Msg("Received Requested State")

        // clear crashloop counter if changing state request
        if !payload.Retrying </span><span class="cov0" title="0">{
                am.clearCrashLoop(app.AppKey, app.Stage)
        }</span>

        // TODO: get rid of this ugly patch: cancel any filetransfers for this container on stop press
        <span class="cov0" title="0">if (curAppState == common.UNINSTALLED || curAppState == common.REMOVED || curAppState == common.PRESENT || curAppState == common.FAILED) &amp;&amp;
                (requestedAppState == common.PRESENT || requestedAppState == common.BUILT) &amp;&amp; payload.Stage == common.DEV </span><span class="cov0" title="0">{
                log.Debug().Msg("Canceling file transfer due to state change")
                am.StateMachine.Filesystem.CancelFileTransfer(payload.ContainerName.Dev)
        }</span>

        <span class="cov0" title="0">if payload.CancelTransition </span><span class="cov0" title="0">{
                log.Debug().Msgf("Cancel request was received for %s (%s) (currently: %s)", app.AppName, app.Stage, app.CurrentState)
                am.StateMachine.CancelTransition(app, payload)
                return nil
        }</span>

        <span class="cov0" title="0">err = am.syncPortState(payload, app)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msgf("failed to sync port state")
                return err
        }</span>

        <span class="cov0" title="0">locked := app.SecureTransition() // if the app is not locked, it will lock the app
        if locked </span><span class="cov0" title="0">{
                log.Info().Msgf("App with name %s and stage %s is already transitioning. (CURRENT STATE: %s)", app.AppName, app.Stage, app.CurrentState)
                return nil
        }</span>

        // need to call this after we have secured the lock
        // to not change the actual state in the middle of an ongoing transition
        // this is necessary because some state transitions require a change of actual state (BUILD &amp; PUBLISH)
        <span class="cov0" title="0">err = am.UpdateCurrentAppState(payload)
        if err != nil </span><span class="cov0" title="0">{
                app.UnlockTransition()
                log.Error().Stack().Err(err).Msg("Failed to update current app state")
                return err
        }</span>

        // before we transition, should request the token
        <span class="cov0" title="0">token, err := am.AppStore.GetRegistryToken(payload.RequestorAccountKey)
        if err != nil </span><span class="cov0" title="0">{
                app.UnlockTransition()
                log.Error().Stack().Err(err).Msg("Failed to get registry token")
                return err
        }</span>

        <span class="cov0" title="0">payload.RegisteryToken = token

        errC := am.StateMachine.InitTransition(app, payload)
        if errC == nil </span><span class="cov0" title="0">{
                // not yet implemented or nullified state transition
                app.UnlockTransition()
                log.Debug().Msg("InitTransition returned nil channel, nothing to do")
                return nil
        }</span>

        // block till transition has finished
        <span class="cov0" title="0">select </span>{
        case err := &lt;-errC:<span class="cov0" title="0">
                app.UnlockTransition()

                if errdefs.IsNoActionTransition(err) </span><span class="cov0" title="0">{
                        log.Debug().Msg("A no action transition was executed, nothing to do. Will also not verify")

                        // Ensure the remote state == current state
                        err := am.StateObserver.Notify(app, app.CurrentState)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Stack().Err(err).Msgf("failed to ensure remote state")
                                return err
                        }</span>

                        <span class="cov0" title="0">am.UpdateTunnelState()

                        return nil</span>
                }

                <span class="cov0" title="0">isCanceled := errdefs.IsDockerStreamCanceled(err)
                if err == nil || isCanceled </span><span class="cov0" title="0">{
                        if !isCanceled </span><span class="cov0" title="0">{
                                log.Info().Msgf("Successfully finished transaction for App (%s, %s)", app.AppName, app.Stage)
                        }</span> else<span class="cov0" title="0"> {
                                log.Info().Msgf("Successfully canceled transition for App (%s, %s)", app.AppName, app.Stage)
                        }</span>

                        // Verify if app has the latest requested state
                        // TODO: properly handle it when verifying fails
                        <span class="cov0" title="0">err := am.VerifyState(app)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Stack().Err(err).Msgf("failed to verify app state")
                                return err
                        }</span>

                        <span class="cov0" title="0">am.UpdateTunnelState()

                        return nil</span>
                }

                // If anything goes wrong with the transition function
                // we should set the state change to FAILED
                // This will in turn update the in memory state and the local database state
                // which will in turn update the remote database as well
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        setStateErr := am.StateObserver.Notify(app, common.FAILED)
                        if setStateErr != nil </span><span class="cov0" title="0">{
                                // wrap errors into one
                                err = fmt.Errorf("failed to complete transition: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">log.Error().Msgf("An error occured during transition from %s to %s for %s (%s)", app.CurrentState, payload.RequestedState, app.AppName, app.Stage)
                log.Error().Stack().Err(err).Msgf("The app state for %s (%s) has been set to FAILED", app.AppName, app.Stage)

                // enter the crashloop when we encounter a FAILED state
                if payload.Stage == common.PROD </span><span class="cov0" title="0">{
                        am.incrementCrashLoop(payload)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// HandleTransferFailure handles a failed file transfer by resetting the app state to REMOVED.
// This is called when the file transfer encounters an error (e.g., canceled, network failure).
func (am *AppManager) HandleTransferFailure(containerName string, transferErr error) <span class="cov0" title="0">{
        log.Warn().Err(transferErr).Str("container", containerName).Msg("File transfer failed, resetting app state")

        app := am.AppStore.GetAppByContainerName(containerName)
        if app == nil </span><span class="cov0" title="0">{
                log.Warn().Str("container", containerName).Msg("Could not find app for failed transfer, cannot reset state")
                return
        }</span>

        <span class="cov0" title="0">app.StateLock.Lock()
        currentState := app.CurrentState
        app.StateLock.Unlock()

        // Only reset if the app is actually in TRANSFERING state
        if currentState != common.TRANSFERING </span><span class="cov0" title="0">{
                log.Debug().Str("container", containerName).Str("currentState", string(currentState)).Msg("App not in TRANSFERING state, skipping reset")
                return
        }</span>

        // Notify the backend that the state should be REMOVED
        <span class="cov0" title="0">err := am.StateObserver.Notify(app, common.REMOVED)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Str("container", containerName).Msg("Failed to notify backend of transfer failure")
        }</span>
}

func IsInvalidOfflineTransition(app *common.App, payload common.TransitionPayload) bool <span class="cov0" title="0">{
        app.StateLock.Lock()
        defer app.StateLock.Unlock()

        notInstalled := app.CurrentState == common.REMOVED || app.CurrentState == common.UNINSTALLED
        buildRequest := app.RequestedState == common.BUILT
        removalRequest := payload.RequestedState == common.REMOVED || payload.RequestedState == common.UNINSTALLED

        if buildRequest </span><span class="cov0" title="0">{
                return true
        }</span>

        // if the app is not on the device and we do any transition that would require internet we return true
        <span class="cov0" title="0">if notInstalled &amp;&amp; payload.Stage == common.PROD &amp;&amp; !removalRequest </span><span class="cov0" title="0">{
                return true
        }</span>

        // cannot publish, update apps while offline
        <span class="cov0" title="0">if payload.RequestedState == common.PUBLISHED || (payload.RequestedState == common.PRESENT &amp;&amp; payload.RequestUpdate) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (am *AppManager) CleanupOrphanedContainers() error <span class="cov0" title="0">{
        log.Info().Msg(" Cleaning up orphaned containers not in database...")

        ctx := context.Background()
        containers, err := am.StateMachine.Container.GetContainers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to list containers")
                return err
        }</span>

        // Get all apps from database
        <span class="cov0" title="0">apps, err := am.AppStore.GetAllApps()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get apps from database")
                return err
        }</span>

        // Create a map of expected container names
        <span class="cov0" title="0">expectedContainers := make(map[string]bool)
        for _, app := range apps </span><span class="cov0" title="0">{
                // Add both single and compose container names
                singleName := common.BuildContainerName(app.Stage, app.AppKey, app.AppName)
                composeName := common.BuildComposeContainerName(app.Stage, app.AppKey, app.AppName)
                expectedContainers[singleName] = true
                expectedContainers[composeName] = true
        }</span>

        // Check each container
        <span class="cov0" title="0">for _, container := range containers </span><span class="cov0" title="0">{
                for _, name := range container.Names </span><span class="cov0" title="0">{
                        // Clean leading slash from container name
                        cleanName := strings.TrimPrefix(name, "/")

                        // Check if it matches our naming convention
                        _, _, _, err := common.ParseContainerName(cleanName)
                        isOurContainer := err == nil

                        if !isOurContainer &amp;&amp; strings.Contains(cleanName, "_compose") </span><span class="cov0" title="0">{
                                // Also check compose naming (only if it has _compose in the name)
                                _, _, _, err := common.ParseComposeContainerName(cleanName)
                                isOurContainer = err == nil
                        }</span>

                        // If it's our container but not in database, remove it
                        <span class="cov0" title="0">if isOurContainer &amp;&amp; !expectedContainers[cleanName] </span><span class="cov0" title="0">{
                                log.Warn().
                                        Str("container", cleanName).
                                        Str("id", container.ID[:12]).
                                        Msg(" Removing orphaned container not in database")

                                removeCtx, cancel := context.WithTimeout(ctx, time.Second*30)
                                err := am.StateMachine.Container.RemoveContainerByID(removeCtx, container.ID, map[string]interface{}{"force": true})
                                cancel()

                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error().Stack().Err(err).
                                                Str("container", cleanName).
                                                Msg("Failed to remove orphaned container")
                                }</span> else<span class="cov0" title="0"> {
                                        log.Info().Str("container", cleanName).Msg(" Successfully removed orphaned container")
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">log.Info().Msg(" Orphaned container cleanup complete")
        return nil</span>
}

func (am *AppManager) CleanupOrphanedAppsFromDatabase(remotePayloads []common.TransitionPayload) error <span class="cov0" title="0">{
        log.Info().Msg(" Syncing database with backend and cleaning up orphaned apps...")

        // Create a map of apps that should exist (from backend)
        expectedApps := make(map[string]bool)
        for _, payload := range remotePayloads </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%d_%s", payload.AppKey, payload.Stage)
                expectedApps[key] = true
        }</span>

        // Get all apps from local database
        <span class="cov0" title="0">localApps, err := am.AppStore.GetAllApps()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get apps from database")
                return err
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Remove apps that are not in backend response
        for _, app := range localApps </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%d_%s", app.AppKey, app.Stage)

                if !expectedApps[key] </span><span class="cov0" title="0">{
                        log.Warn().
                                Str("app", app.AppName).
                                Uint64("app_key", app.AppKey).
                                Str("stage", string(app.Stage)).
                                Msg(" App not in backend sync, removing from database and Docker")

                        // Remove container if it exists
                        containerName := common.BuildContainerName(app.Stage, app.AppKey, app.AppName)
                        getContainerCtx, cancel := context.WithTimeout(ctx, time.Second*10)
                        cont, err := am.StateMachine.Container.GetContainer(getContainerCtx, containerName)
                        cancel()

                        if err == nil </span><span class="cov0" title="0">{
                                removeCtx, cancel := context.WithTimeout(ctx, time.Second*30)
                                err = am.StateMachine.Container.RemoveContainerByID(removeCtx, cont.ID, map[string]interface{}{"force": true})
                                cancel()
                                if err != nil &amp;&amp; !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                                        log.Error().Stack().Err(err).Str("container", containerName).Msg("Failed to remove container")
                                }</span>
                        }

                        // Remove compose containers if they exist
                        <span class="cov0" title="0">composeName := common.BuildComposeContainerName(app.Stage, app.AppKey, app.AppName)
                        getComposeCtx, cancel := context.WithTimeout(ctx, time.Second*10)
                        composeCont, err := am.StateMachine.Container.GetContainer(getComposeCtx, composeName)
                        cancel()

                        if err == nil </span><span class="cov0" title="0">{
                                removeCtx, cancel := context.WithTimeout(ctx, time.Second*30)
                                err = am.StateMachine.Container.RemoveContainerByID(removeCtx, composeCont.ID, map[string]interface{}{"force": true})
                                cancel()
                                if err != nil &amp;&amp; !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                                        log.Error().Stack().Err(err).Str("container", composeName).Msg("Failed to remove compose container")
                                }</span>
                        }

                        // Remove images
                        <span class="cov0" title="0">if app.Stage == common.DEV </span><span class="cov0" title="0">{
                                imageName := common.BuildImageName(app.Stage, "amd64", app.AppKey, app.AppName) // Simplified - should get actual arch
                                removeImageCtx, cancel := context.WithTimeout(ctx, time.Second*30)
                                err = am.StateMachine.Container.RemoveImagesByName(removeImageCtx, imageName, map[string]interface{}{"force": true})
                                cancel()
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Debug().Err(err).Str("image", imageName).Msg("Could not remove image (might not exist)")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // For PROD, try to remove versioned images
                                log.Debug().Str("app", app.AppName).Msg("Skipping image removal for PROD app (versioned images)")
                        }</span>

                        // Remove from database
                        <span class="cov0" title="0">err = am.AppStore.DeleteAppState(app.AppKey, app.Stage)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Stack().Err(err).Msg("Failed to delete app state from database")
                        }</span>

                        <span class="cov0" title="0">err = am.AppStore.DeleteRequestedState(app.AppKey, app.Stage)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Stack().Err(err).Msg("Failed to delete requested state from database")
                        }</span>

                        <span class="cov0" title="0">log.Info().
                                Str("app", app.AppName).
                                Uint64("app_key", app.AppKey).
                                Str("stage", string(app.Stage)).
                                Msg(" Successfully removed orphaned app")</span>
                }
        }

        <span class="cov0" title="0">log.Info().Msg(" Database cleanup complete")
        return nil</span>
}

func (am *AppManager) EnsureLocalRequestedStates() error <span class="cov0" title="0">{
        log.Debug().Msg("Ensuring local requested states")
        rStates, err := am.AppStore.GetRequestedStates()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get requested states")
                return err
        }</span>

        // Stagger the startup to avoid overwhelming the backend
        <span class="cov0" title="0">for idx := range rStates </span><span class="cov0" title="0">{
                payload := rStates[idx]

                app, err := am.AppStore.GetApp(payload.AppKey, payload.Stage)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Stack().Err(err).Msg("Failed to get app in EnsureLocalRequestedStates")
                        return err
                }</span>

                <span class="cov0" title="0">safe.Go(func() </span><span class="cov0" title="0">{
                        app.StateLock.Lock()
                        currentAppState := app.CurrentState
                        app.StateLock.Unlock()

                        if !IsInvalidOfflineTransition(app, payload) &amp;&amp; currentAppState != payload.RequestedState </span><span class="cov0" title="0">{
                                err := am.RequestAppState(payload)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error().Stack().Err(err).Msg("Failed to ensure local requested state")
                                }</span>
                        }
                })

                // Add a small delay between starting each app to avoid overwhelming the backend
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (am *AppManager) VerifyState(app *common.App) error <span class="cov0" title="0">{
        log.Debug().Str("app", app.AppName).Msg("Verifying app state")
        log.Printf("Verifying if app (%s, %s) is in latest state...", app.AppName, app.Stage)

        requestedStatePayload, err := am.AppStore.GetRequestedState(app.AppKey, app.Stage)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get requested state in VerifyState")
                return err
        }</span>

        <span class="cov0" title="0">log.Info().Msgf("Latest requested state (verify): %s", requestedStatePayload.RequestedState)

        app.StateLock.Lock()
        curAppState := app.CurrentState
        requestedState := app.RequestedState
        app.StateLock.Unlock()

        if curAppState == common.FAILED </span><span class="cov0" title="0">{
                log.Debug().Msg("App transition finished in a failed state")
                return nil
        }</span>

        <span class="cov0" title="0">if curAppState != requestedState </span><span class="cov0" title="0">{
                log.Debug().Msgf("App (%s, %s) is not in latest state (%s), transitioning to %s...", app.AppName, app.Stage, curAppState, requestedState)

                // transition again
                safe.Go(func() </span><span class="cov0" title="0">{
                        _ = am.RequestAppState(requestedStatePayload)
                }</span>)
        } else<span class="cov0" title="0"> {
                err = am.syncPortState(requestedStatePayload, app)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Stack().Err(err).Msgf("failed to sync port state")
                        return err
                }</span>
        }

        <span class="cov0" title="0">if curAppState == common.BUILT &amp;&amp; requestedState == common.BUILT </span><span class="cov0" title="0">{
                // The build has finished and should now be put to PRESENT
                err = am.StateObserver.Notify(app, common.PRESENT)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Stack().Err(err).Msg("Failed to notify state observer for PRESENT state")
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (am *AppManager) UpdateCurrentAppState(payload common.TransitionPayload) error <span class="cov0" title="0">{
        log.Debug().Str("app", payload.AppName).Msg("UpdateCurrentAppState called")
        app, err := am.AppStore.GetApp(payload.AppKey, payload.Stage)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get app in UpdateCurrentAppState")
                return err
        }</span>

        <span class="cov0" title="0">app.StateLock.Lock()

        curAppState := app.CurrentState

        if curAppState == common.BUILT ||
                curAppState == common.PUBLISHED ||
                (curAppState == common.PRESENT &amp;&amp; app.RequestedState == common.BUILT) </span><span class="cov0" title="0">{
                if payload.CurrentState != "" </span><span class="cov0" title="0">{
                        app.CurrentState = payload.CurrentState
                }</span>
        }

        <span class="cov0" title="0">if payload.PresentVersion != "" </span><span class="cov0" title="0">{
                app.Version = payload.PresentVersion
        }</span>

        <span class="cov0" title="0">app.StateLock.Unlock()

        log.Debug().Str("app", payload.AppName).Msg("Updating local app state")
        return am.AppStore.UpdateLocalAppState(app, curAppState)</span>
}

func (am *AppManager) CreateOrUpdateApp(payload common.TransitionPayload) error <span class="cov0" title="0">{
        log.Debug().Str("app", payload.AppName).Msg("CreateOrUpdateApp called")
        app, err := am.AppStore.GetApp(payload.AppKey, payload.Stage)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get app in CreateOrUpdateApp")
                return err
        }</span>

        <span class="cov0" title="0">payload.RequestedState = common.TransientToActualState(payload.RequestedState)

        if app == nil </span><span class="cov0" title="0">{
                app, err = am.AppStore.AddApp(payload)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Stack().Err(err).Msg("Failed to add app in CreateOrUpdateApp")
                        return err
                }</span>
        }

        <span class="cov0" title="0">app.StateLock.Lock()

        if app.CurrentState == common.BUILT &amp;&amp; app.RequestedState != common.BUILT </span><span class="cov0" title="0">{
                app.StateLock.Unlock()
                log.Debug().Str("app", payload.AppName).Msg("Skipping update of requestedState as app is already built")
                return nil
        }</span>

        <span class="cov0" title="0">app.RequestedState = payload.RequestedState

        app.StateLock.Unlock()

        log.Debug().Str("app", payload.AppName).Msg("Updating local requested app state")
        return am.AppStore.UpdateLocalRequestedState(payload)</span>
}

// EnsureRemoteRequestedStates iterates over all requested states found in the local database, and transitions were neccessary.
func (am *AppManager) EnsureRemoteRequestedStates() error <span class="cov0" title="0">{
        log.Debug().Msg("Ensuring remote requested states")
        payloads, err := am.AppStore.GetRequestedStates()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get requested states in EnsureRemoteRequestedStates")
                return err
        }</span>

        <span class="cov0" title="0">for i := range payloads </span><span class="cov0" title="0">{
                payload := payloads[i]

                // do not execute publishes on reconnect
                if payload.Stage == common.DEV || payload.RequestedState == common.PUBLISHED || payload.RequestedState == common.BUILT </span><span class="cov0" title="0">{
                        log.Debug().Str("app", payload.AppName).Msg("Skipping publish on reconnect for DEV/PUBLISHED/BUILT state")
                        continue</span>
                }

                <span class="cov0" title="0">safe.Go(func() </span><span class="cov0" title="0">{
                        log.Debug().Str("app", payload.AppName).Msg("Requesting app state in goroutine")
                        am.RequestAppState(payload)
                }</span>)
        }

        <span class="cov0" title="0">return nil</span>
}

// UpdateLocalRequestedAppStatesWithRemote is responsible for updating the local database with fetched requested states.
// The local database will be updated with the fetched requested states. In case an app state does not exist yet locally, one will be created.
func (am *AppManager) UpdateLocalRequestedAppStatesWithRemote(newestPayloads []common.TransitionPayload) error <span class="cov0" title="0">{
        log.Debug().Msg("Updating local requested app states with remote")

        log.Info().Msgf("Found %d app states, updating local database with new requested states..", len(newestPayloads))
        for i := range newestPayloads </span><span class="cov0" title="0">{
                payload := newestPayloads[i]

                // portRules, err := tunnel.InterfaceToPortForwardRule(payload.Ports)
                // if err != nil {
                //         return err
                // }

                if payload.Stage == common.PROD </span><span class="cov0" title="0">{
                        _, err := am.AppStore.GetApp(payload.AppKey, common.PROD)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">err = am.CreateOrUpdateApp(payload)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package apps

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "reagent/common"
        "reagent/config"
        "reagent/errdefs"
        "reagent/filesystem"
        "reagent/release"
        "reagent/tunnel"
        "strings"

        "github.com/docker/docker/api/types"
        "github.com/rs/zerolog/log"
)

func (sm *StateMachine) buildApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.Stage != common.DEV </span><span class="cov0" title="0">{
                return errors.New("can only build dev apps")
        }</span>

        <span class="cov0" title="0">return sm.buildDevApp(payload, app, false)</span>
}

func (sm *StateMachine) generateDotEnvContents(config *config.Config, payload common.TransitionPayload, app *common.App) (string, error) <span class="cov0" title="0">{
        var dotEnvFileContents string

        systemDefaultVariables := buildDefaultEnvironmentVariables(config, app.Stage, app)
        environmentVariables := buildProdEnvironmentVariables(systemDefaultVariables, payload.EnvironmentVariables)
        environmentTemplateDefaults := common.EnvironmentTemplateToStringArray(payload.EnvironmentTemplate)

        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                devEnvironmentVariables := append(systemDefaultVariables, environmentTemplateDefaults...)
                dotEnvFileContents = strings.Join(devEnvironmentVariables, "\n")
        }</span> else<span class="cov0" title="0"> {
                var missingDefaultEnvs []string
                for _, templateEnvString := range environmentTemplateDefaults </span><span class="cov0" title="0">{
                        envStringSplit := strings.Split(templateEnvString, "=")
                        environmentName := envStringSplit[0]

                        found := false
                        for _, envVariableString := range environmentVariables </span><span class="cov0" title="0">{
                                if strings.Contains(envVariableString, environmentName) </span><span class="cov0" title="0">{
                                        found = true
                                }</span>
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                missingDefaultEnvs = append(missingDefaultEnvs, templateEnvString)
                        }</span>
                }

                <span class="cov0" title="0">var remotePortEnvs []string
                portRules, err := tunnel.InterfaceToPortForwardRule(payload.Ports)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">for _, portRule := range portRules </span><span class="cov0" title="0">{
                        if portRule.RemotePortEnvironment != "" </span><span class="cov0" title="0">{
                                subdomain := tunnel.CreateSubdomain(tunnel.Protocol(portRule.Protocol), uint64(config.ReswarmConfig.DeviceKey), app.AppName, portRule.Port)
                                tunnelID := tunnel.CreateTunnelID(subdomain, portRule.Protocol)
                                tunnel := sm.StateObserver.AppManager.tunnelManager.Get(tunnelID)

                                if tunnel != nil </span><span class="cov0" title="0">{
                                        portEnv := fmt.Sprintf("%s=%d", portRule.RemotePortEnvironment, tunnel.Config.RemotePort)
                                        remotePortEnvs = append(remotePortEnvs, portEnv)
                                }</span>
                        }
                }

                <span class="cov0" title="0">dotEnvFileContents = strings.Join(append(environmentVariables, append(remotePortEnvs, missingDefaultEnvs...)...), "\n")</span>
        }

        <span class="cov0" title="0">return dotEnvFileContents, nil</span>
}

const DockerFileName = "docker-compose.json"
const DotEnvFileName = ".env-compose"

func (sm *StateMachine) SetupComposeFiles(payload common.TransitionPayload, app *common.App, updatingApp bool) (string, error) <span class="cov0" title="0">{
        config := sm.Container.GetConfig()

        isProd := payload.Stage == common.PROD
        targetDir := config.CommandLineArguments.AppsBuildDir
        if isProd </span><span class="cov0" title="0">{
                targetDir = config.CommandLineArguments.AppsComposeDir
        }</span>

        <span class="cov0" title="0">targetAppDir := targetDir + "/" + app.AppName
        dockerComposeFilePath := targetAppDir + "/" + DockerFileName
        dotEnvFilePath := targetAppDir + "/" + DotEnvFileName

        dockerCompose := payload.DockerCompose
        if payload.NewDockerCompose != nil &amp;&amp; updatingApp </span><span class="cov0" title="0">{
                dockerCompose = payload.NewDockerCompose
        }</span>

        <span class="cov0" title="0">dockerCompose["name"] = common.BuildComposeContainerName(payload.Stage, app.AppKey, app.AppName)

        services, ok := (dockerCompose["services"]).(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("failed to infer services")
        }</span>

        <span class="cov0" title="0">for _, serviceInterface := range services </span><span class="cov0" title="0">{
                service, ok := (serviceInterface).(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return "", errors.New("failed to infer service")
                }</span>

                <span class="cov0" title="0">service["env_file"] = DotEnvFileName</span>
        }

        <span class="cov0" title="0">dockerComposeJSONString, err := json.Marshal(dockerCompose)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">_, err = os.Stat(targetAppDir)
        if err != nil </span><span class="cov0" title="0">{
                err = os.MkdirAll(targetAppDir, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov0" title="0">dotEnvFileContents, err := sm.generateDotEnvContents(config, payload, app)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(dotEnvFilePath, []byte(dotEnvFileContents), os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(dockerComposeFilePath, dockerComposeJSONString, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return dockerComposeFilePath, nil</span>
}

func (sm *StateMachine) buildDevComposeApp(payload common.TransitionPayload, app *common.App, releaseBuild bool) error <span class="cov0" title="0">{
        err := sm.LogManager.ClearLogHistory(payload.ContainerName.Dev)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.REMOVED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">config := sm.Container.GetConfig()
        buildsDir := config.CommandLineArguments.AppsBuildDir
        fileName := payload.AppName + "." + config.CommandLineArguments.CompressedBuildExtension
        appFilesTar := buildsDir + "/" + fileName
        targetAppDir := buildsDir + "/" + app.AppName

        _, err = os.Stat(targetAppDir)
        if err == nil </span><span class="cov0" title="0">{
                err := os.RemoveAll(targetAppDir)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">err = filesystem.ExtractTarGz(appFilesTar, targetAppDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">app.ReleaseBuild = releaseBuild
        topicForLogStream := payload.ContainerName.Dev
        if releaseBuild </span><span class="cov0" title="0">{
                topicForLogStream = payload.PublishContainerName
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(topicForLogStream, "Starting image build...")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.BUILDING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compose := sm.Container.Compose()
        if !compose.Supported </span><span class="cov0" title="0">{
                message := "Docker Compose is not supported for this device"
                writeErr := sm.LogManager.Write(topicForLogStream, message)
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
                <span class="cov0" title="0">return errdefs.DockerComposeNotSupported(errors.New("docker compose is not supported"))</span>
        }

        <span class="cov0" title="0">err = sm.HandleRegistryLoginsWithDefault(payload)
        if err != nil </span><span class="cov0" title="0">{
                writeErr := sm.LogManager.Write(topicForLogStream, err.Error())
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">dockerComposePath, err := sm.SetupComposeFiles(payload, app, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">buildOutput, buildCmd, err := compose.Build(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = sm.LogManager.StreamLogsChannel(buildOutput, topicForLogStream)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = buildCmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !releaseBuild </span><span class="cov0" title="0">{
                pullOutput, pullCmd, err := compose.Pull(dockerComposePath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = sm.LogManager.StreamLogsChannel(pullOutput, topicForLogStream)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = pullCmd.Wait()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">buildMessage := "Compose Image built successfully"
        err = sm.LogManager.Write(topicForLogStream, buildMessage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sm.setState(app, common.BUILT)</span>
}

func (sm *StateMachine) buildDevApp(payload common.TransitionPayload, app *common.App, releaseBuild bool) error <span class="cov0" title="0">{
        if payload.DockerCompose != nil </span><span class="cov0" title="0">{
                return sm.buildDevComposeApp(payload, app, releaseBuild)
        }</span>

        <span class="cov0" title="0">err := sm.LogManager.ClearLogHistory(payload.ContainerName.Dev)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.REMOVED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">config := sm.Container.GetConfig()
        buildsDir := config.CommandLineArguments.AppsBuildDir
        fileName := payload.AppName + "." + config.CommandLineArguments.CompressedBuildExtension
        appFilesTar := buildsDir + "/" + fileName

        dockerFileName := "Dockerfile"
        buildArch := release.GetBuildArch()
        archSpecificDockerfile := fmt.Sprintf("Dockerfile.%s", buildArch)
        _, err = filesystem.ReadFileInTgz(appFilesTar, archSpecificDockerfile)
        if err == nil </span><span class="cov0" title="0">{
                dockerFileName = archSpecificDockerfile
        }</span>

        // need to specify that this is a release build on remote update
        // this ensures that the dev release will be set to exists = true
        // prod ready builds will not be set to exists until after they are pushed
        <span class="cov0" title="0">app.ReleaseBuild = releaseBuild
        buildOptions := types.ImageBuildOptions{
                Tags:       []string{payload.RegistryImageName.Dev},
                Dockerfile: dockerFileName,
                BuildID:    common.BuildDockerBuildID(app.AppKey, app.AppName),
        }

        topicForLogStream := payload.ContainerName.Dev
        if releaseBuild </span><span class="cov0" title="0">{
                topicForLogStream = payload.PublishContainerName
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(topicForLogStream, "Starting image build...")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.BUILDING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO: figure out context for build?
        <span class="cov0" title="0">reader, err := sm.Container.Build(context.Background(), appFilesTar, buildOptions)
        if err != nil </span><span class="cov0" title="0">{
                errorMessage := err.Error()
                if errdefs.IsDockerfileCannotBeEmpty(err) </span><span class="cov0" title="0">{
                        errorMessage = "The Dockerfile cannot be empty, please fill out your Dockerfile"
                }</span> else<span class="cov0" title="0"> if errdefs.IsDockerfileIsMissing(err) </span><span class="cov0" title="0">{
                        errorMessage = "Could not find a Dockerfile, please create a Dockerfile in the root of your project"
                }</span> else<span class="cov0" title="0"> if errdefs.IsDockerBuildFilesNotFound(err) </span><span class="cov0" title="0">{
                        errorMessage = "Build files for app not found: " + err.Error()
                }</span>

                <span class="cov0" title="0">log.Debug().Msgf("building failed sending following message to user %s", errorMessage)

                messageErr := sm.LogManager.Write(topicForLogStream, errorMessage)
                if messageErr != nil </span><span class="cov0" title="0">{
                        return messageErr
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">var buildMessage string
        streamErr := sm.LogManager.StreamBlocking(topicForLogStream, common.BUILD, reader)
        if streamErr != nil </span><span class="cov0" title="0">{
                if errdefs.IsDockerStreamCanceled(streamErr) </span><span class="cov0" title="0">{
                        buildMessage = "The build stream was canceled"
                        writeErr := sm.LogManager.Write(topicForLogStream, buildMessage)
                        if writeErr != nil </span><span class="cov0" title="0">{
                                return writeErr
                        }</span>
                        // this error will not cause a failed state and is handled upstream
                        <span class="cov0" title="0">return streamErr</span>
                }

                <span class="cov0" title="0">return streamErr</span>
        }

        <span class="cov0" title="0">buildMessage = "Image built successfully"
        err = sm.LogManager.Write(topicForLogStream, buildMessage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sm.setState(app, common.BUILT)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package apps

import (
        "errors"
        "reagent/common"
)

func (sm *StateMachine) cancelBuild(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.Stage == common.PROD </span><span class="cov0" title="0">{
                return errors.New("cannot build prod apps")
        }</span>

        <span class="cov0" title="0">buildID := common.BuildDockerBuildID(app.AppKey, app.AppName)

        sm.Container.CancelStream(buildID)

        return sm.setState(app, common.REMOVED)</span>
}

func (sm *StateMachine) cancelPull(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.Stage != common.PROD </span><span class="cov0" title="0">{
                return errors.New("cannot pull dev apps")
        }</span>

        <span class="cov0" title="0">pullID := common.BuildDockerPullID(payload.AppKey, payload.AppName)

        sm.Container.CancelStream(pullID)

        return sm.setState(app, common.REMOVED)</span>
}

func (sm *StateMachine) cancelPush(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        pushID := common.BuildDockerPushID(payload.AppKey, payload.AppName)

        sm.Container.CancelStream(pushID)

        return sm.setState(app, common.REMOVED)
}</span>

func (sm *StateMachine) cancelUpdate(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        pullID := common.BuildDockerPullID(payload.AppKey, payload.AppName)

        sm.Container.CancelStream(pullID)

        // let the backend know the update has been canceled
        app.UpdateStatus = common.CANCELED

        return sm.setState(app, common.PRESENT)
}</span>

func (sm *StateMachine) cancelUpdateAndRemove(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        pullID := common.BuildDockerPullID(payload.AppKey, payload.AppName)

        sm.Container.CancelStream(pullID)

        app.UpdateStatus = common.CANCELED

        return sm.removeApp(payload, app)
}</span>

func (sm *StateMachine) cancelTransfer(payload common.TransitionPayload, app *common.App) error <span class="cov8" title="1">{
        if payload.Stage != common.DEV </span><span class="cov8" title="1">{
                return errors.New("file transfer is only for dev apps")
        }</span>

        <span class="cov0" title="0">sm.Filesystem.CancelFileTransfer(payload.ContainerName.Dev)

        return sm.setState(app, common.REMOVED)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package apps

import (
        "reagent/common"
        "reagent/safe"
        "time"

        "github.com/rs/zerolog/log"
)

type CrashLoopManager struct {
        AppManager *AppManager
}

type CrashLoop struct {
        Payload common.TransitionPayload
        Retries uint
}

func calculateLoopSleepTime(retries uint) time.Duration <span class="cov0" title="0">{
        var sleepTime time.Duration
        if retries == 0 </span><span class="cov0" title="0">{
                sleepTime = time.Second * 5
        }</span> else<span class="cov0" title="0"> {
                sleepTime = time.Second * 5 * time.Duration(retries)
        }</span>

        // cap to 2,5 minutes
        <span class="cov0" title="0">sleepTime = time.Duration(common.Min(int64(sleepTime), int64(time.Second*150)))

        return sleepTime</span>
}

func (clm *AppManager) retry(crashTask *CrashLoop) <span class="cov0" title="0">{
        crashTask.Retries++

        safe.Go(func() </span><span class="cov0" title="0">{

                // cap to 2,5 minutes
                sleepTime := calculateLoopSleepTime(crashTask.Retries)

                log.Info().Msgf("CrashLoopBackOff attempt: %d, sleeping for %s for %s (%s)", crashTask.Retries, sleepTime, crashTask.Payload.AppName, crashTask.Payload.Stage)

                time.Sleep(sleepTime)

                if crashTask.Retries == 30 </span><span class="cov0" title="0">{
                        clm.crashLoopLock.Lock()
                        crashTask.Retries = 0
                        clm.crashLoopLock.Unlock()
                }</span>

                // exit the goroutine if the crashloop was canceled in the meantime
                <span class="cov0" title="0">clm.crashLoopLock.Lock()
                var foundTask *CrashLoop
                for task := range clm.crashLoops </span><span class="cov0" title="0">{
                        if task.Payload.Stage == crashTask.Payload.Stage &amp;&amp; task.Payload.AppKey == crashTask.Payload.AppKey </span><span class="cov0" title="0">{
                                foundTask = task
                                break</span>
                        }
                }

                <span class="cov0" title="0">if foundTask == nil </span><span class="cov0" title="0">{
                        log.Debug().Msgf("Crashloop task no longer exists for %d (%s), exiting goroutine...", crashTask.Payload.AppKey, crashTask.Payload.Stage)
                        clm.crashLoopLock.Unlock()
                        return
                }</span>

                <span class="cov0" title="0">clm.crashLoopLock.Unlock()

                app, _ := clm.AppStore.GetApp(crashTask.Payload.AppKey, crashTask.Payload.Stage)
                if app.CurrentState != crashTask.Payload.RequestedState </span><span class="cov0" title="0">{
                        clm.RequestAppState(crashTask.Payload)
                }</span> else<span class="cov0" title="0"> {
                        clm.clearCrashLoop(crashTask.Payload.AppKey, crashTask.Payload.Stage)
                }</span>

        })
}

func (clm *AppManager) clearCrashLoop(appKey uint64, stage common.Stage) <span class="cov0" title="0">{
        clm.crashLoopLock.Lock()
        var foundTask *CrashLoop
        for crashTask := range clm.crashLoops </span><span class="cov0" title="0">{
                if crashTask.Payload.Stage == stage &amp;&amp; crashTask.Payload.AppKey == appKey </span><span class="cov0" title="0">{
                        foundTask = crashTask
                        break</span>
                }
        }

        <span class="cov0" title="0">if foundTask != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("clearing an existing crashloop for %d (%s)", appKey, stage)
                delete(clm.crashLoops, foundTask)
        }</span>

        <span class="cov0" title="0">clm.crashLoopLock.Unlock()</span>
}

func (clm *AppManager) incrementCrashLoop(payload common.TransitionPayload) (uint, time.Duration) <span class="cov0" title="0">{
        clm.crashLoopLock.Lock()
        existingCrashes := clm.crashLoops

        var existingCrash *CrashLoop
        for crash := range existingCrashes </span><span class="cov0" title="0">{
                if crash.Payload.Stage == payload.Stage &amp;&amp;
                        crash.Payload.AppKey == payload.AppKey </span><span class="cov0" title="0">{
                        existingCrash = crash
                        break</span>
                }
        }
        <span class="cov0" title="0">clm.crashLoopLock.Unlock()

        if existingCrash != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("retrying an existing crashloop for %s (%s)", payload.AppName, payload.Stage)
                clm.retry(existingCrash)

                sleepTime := calculateLoopSleepTime(existingCrash.Retries)
                return existingCrash.Retries, sleepTime
        }</span> else<span class="cov0" title="0"> {
                payload.Retrying = true
                crashLoopTask := &amp;CrashLoop{Payload: payload, Retries: 0}

                clm.crashLoopLock.Lock()
                clm.crashLoops[crashLoopTask] = struct{}{}
                clm.crashLoopLock.Unlock()

                log.Debug().Msgf("created a new crash loop for %s (%s)", payload.AppName, payload.Stage)
                clm.retry(crashLoopTask)

                sleepTime := calculateLoopSleepTime(crashLoopTask.Retries)
                return crashLoopTask.Retries, sleepTime
        }</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package apps

import (
        "context"
        "reagent/common"
        "time"
)

func (sm *StateMachine) recoverFailToPresentHandler(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{

        var containerToRemove string
        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                containerToRemove = payload.ContainerName.Dev
        }</span> else<span class="cov0" title="0"> {
                containerToRemove = payload.ContainerName.Prod
        }</span>

        <span class="cov0" title="0">removeContainerByIdContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()
        // remove any existing container to ensure environment variables are set
        sm.Container.RemoveContainerByID(removeContainerByIdContext, containerToRemove, map[string]interface{}{"force": true})

        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                return sm.buildApp(payload, app)
        }</span>

        // Check if the image exists
        <span class="cov0" title="0">var fullImageName string
        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                fullImageName = payload.RegistryImageName.Dev
        }</span> else<span class="cov0" title="0"> if payload.Stage == common.PROD </span><span class="cov0" title="0">{
                fullImageName = payload.RegistryImageName.Prod
        }</span>

        <span class="cov0" title="0">getImagesContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        images, err := sm.Container.GetImages(getImagesContext, fullImageName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(images) != 0 </span><span class="cov0" title="0">{
                return sm.setState(app, common.PRESENT)
        }</span>

        <span class="cov0" title="0">return sm.pullApp(payload, app)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package apps

import (
        "context"
        "reagent/common"
        "time"
)

func (sm *StateMachine) recoverFailToRunningHandler(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{

        var containerToRemove string
        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                containerToRemove = payload.ContainerName.Dev
        }</span> else<span class="cov0" title="0"> {
                containerToRemove = payload.ContainerName.Prod
        }</span>

        <span class="cov0" title="0">if payload.DockerCompose == nil </span><span class="cov0" title="0">{
                removeContainerByIdContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()
                // remove any existing container to ensure environment variables are set
                sm.Container.RemoveContainerByID(removeContainerByIdContext, containerToRemove, map[string]interface{}{"force": true})
        }</span>

        <span class="cov0" title="0">return sm.runApp(payload, app)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package apps

import (
        "context"
        "fmt"
        "reagent/common"
        "reagent/container"
        "reagent/errdefs"
        "time"
)

func (sm *StateMachine) publishApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.DockerCompose != nil </span><span class="cov0" title="0">{
                return sm.publishComposeApp(payload, app)
        }</span>

        <span class="cov0" title="0">err := sm.LogManager.Write(payload.PublishContainerName, fmt.Sprintf("Initializing publish process for %s...", app.AppName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.buildDevApp(payload, app, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.PublishContainerName, "App build has finished, Starting to publish...")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">prodImage := fmt.Sprintf("%s:%s", payload.RegistryImageName.Prod, payload.Version)
        tagContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        err = sm.Container.Tag(tagContext, payload.RegistryImageName.Dev, prodImage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.PUBLISHING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.HandleRegistryLoginsWithDefault(payload)
        if err != nil </span><span class="cov0" title="0">{
                writeErr := sm.LogManager.Write(payload.PublishContainerName, err.Error())
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">pushOptions := container.PushOptions{
                AuthConfig: container.AuthConfig{
                        Username: payload.RegisteryToken,
                        Password: sm.Container.GetConfig().ReswarmConfig.Secret,
                },
                PushID: common.BuildDockerPushID(payload.AppKey, payload.AppName),
        }

        reader, err := sm.Container.Push(context.Background(), prodImage, pushOptions)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">streamErr := sm.LogManager.StreamBlocking(payload.PublishContainerName, common.PUSH, reader)
        if streamErr != nil </span><span class="cov0" title="0">{
                if errdefs.IsDockerStreamCanceled(streamErr) </span><span class="cov0" title="0">{
                        pushMessage := "The app release was canceled"
                        writeErr := sm.LogManager.Write(payload.PublishContainerName, pushMessage)
                        if writeErr != nil </span><span class="cov0" title="0">{
                                return writeErr
                        }</span>
                        // this error will not cause a failed state and is handled upstream
                        <span class="cov0" title="0">return streamErr</span>
                }

                <span class="cov0" title="0">return streamErr</span>
        }

        <span class="cov0" title="0">err = sm.setState(app, common.PUBLISHED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.ClearLogHistory(payload.PublishContainerName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (sm *StateMachine) publishComposeApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        err := sm.LogManager.Write(payload.PublishContainerName, fmt.Sprintf("Initializing publish process for %s...", app.AppName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.buildDevApp(payload, app, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.PublishContainerName, "App build has finished, Starting to publish...")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.PUBLISHING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dockerComposePath, err := sm.SetupComposeFiles(payload, app, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compose := sm.Container.Compose()

        err = sm.HandleRegistryLoginsWithDefault(payload)
        if err != nil </span><span class="cov0" title="0">{
                writeErr := sm.LogManager.Write(payload.PublishContainerName, err.Error())
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">pushOutput, pushCmd, err := compose.Push(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = sm.LogManager.StreamLogsChannel(pushOutput, payload.PublishContainerName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = pushCmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.PUBLISHED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.ClearLogHistory(payload.PublishContainerName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package apps

import (
        "reagent/common"
)

func (sm *StateMachine) removedToRunning(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        // handles both pulling and building when images are not found
        return sm.runApp(payload, app)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package apps

import (
        "context"
        "errors"
        "fmt"
        "reagent/common"
        "reagent/container"
        "reagent/errdefs"
)

func (sm *StateMachine) pullComposeApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        topicForLogStream := payload.ContainerName.Prod

        err := sm.LogManager.ClearLogHistory(topicForLogStream)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.DOWNLOADING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compose := sm.Container.Compose()

        // TODO: make sure that folder exists so that compose can be started, make a different folder for PROD apps
        dockerComposePath, err := sm.SetupComposeFiles(payload, app, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !compose.Supported </span><span class="cov0" title="0">{
                message := "Docker Compose is not supported for this device"
                writeErr := sm.LogManager.Write(topicForLogStream, message)
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
                <span class="cov0" title="0">return errdefs.DockerComposeNotSupported(errors.New("docker compose is not supported"))</span>
        }

        <span class="cov0" title="0">_, cmd, err := compose.Stop(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, cmd, err = compose.Remove(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.HandleRegistryLoginsWithDefault(payload)
        if err != nil </span><span class="cov0" title="0">{
                writeErr := sm.LogManager.Write(topicForLogStream, err.Error())
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">pullOutput, pullCmd, err := compose.Pull(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = sm.LogManager.StreamLogsChannel(pullOutput, topicForLogStream)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = pullCmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">buildMessage := "Compose Image Installed successfully"
        err = sm.LogManager.Write(topicForLogStream, buildMessage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sm.setState(app, common.PRESENT)</span>
}

func (sm *StateMachine) pullApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.DockerCompose != nil </span><span class="cov0" title="0">{
                return sm.pullComposeApp(payload, app)
        }</span>

        <span class="cov0" title="0">config := sm.Container.GetConfig()

        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                // cannot pull dev apps from registry
                return errors.New("cannot pull dev apps")
        }</span>

        <span class="cov0" title="0">err := sm.LogManager.ClearRemote(payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">initMessage := fmt.Sprintf("Initialising download for the app: %s...", payload.AppName)
        err = sm.LogManager.Write(payload.ContainerName.Prod, initMessage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.ClearLogHistory(payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Need to authenticate to private registry to determine proper privileges to pull the app
        <span class="cov0" title="0">err = sm.HandleRegistryLoginsWithDefault(payload)
        if err != nil </span><span class="cov0" title="0">{
                writeErr := sm.LogManager.Write(payload.ContainerName.Prod, err.Error())
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">authConfig := container.AuthConfig{
                Username: payload.RegisteryToken,
                Password: config.ReswarmConfig.Secret,
        }

        fullImageNameWithVersion := fmt.Sprintf("%s:%s", payload.RegistryImageName.Prod, payload.NewestVersion)
        pullOptions := container.PullOptions{
                AuthConfig: authConfig,
                PullID:     common.BuildDockerPullID(payload.AppKey, payload.AppName),
        }

        reader, err := sm.Container.Pull(context.Background(), fullImageNameWithVersion, pullOptions)
        if err != nil </span><span class="cov0" title="0">{
                errorMessage := fmt.Sprintf("Error occured while trying to pull the image: %s", err.Error())
                sm.LogManager.Write(payload.ContainerName.Prod, errorMessage)
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.DOWNLOADING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">streamErr := sm.LogManager.StreamBlocking(payload.ContainerName.Prod, common.PULL, reader)
        if streamErr != nil </span><span class="cov0" title="0">{
                if errdefs.IsDockerStreamCanceled(streamErr) </span><span class="cov0" title="0">{
                        pullMessage := "The app download was canceled"
                        writeErr := sm.LogManager.Write(payload.ContainerName.Prod, pullMessage)
                        if writeErr != nil </span><span class="cov0" title="0">{
                                return writeErr
                        }</span>
                        // this error will not cause a failed state and is handled upstream
                        <span class="cov0" title="0">return streamErr</span>
                }

                <span class="cov0" title="0">return streamErr</span>
        }

        <span class="cov0" title="0">pullMessage := fmt.Sprintf("Succesfully installed the app: %s (Version: %s)", payload.AppName, payload.NewestVersion)
        writeErr := sm.LogManager.Write(payload.ContainerName.Prod, pullMessage)
        if writeErr != nil </span><span class="cov0" title="0">{
                return writeErr
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.PRESENT)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package apps

import (
        "context"
        "fmt"
        "reagent/common"
        "reagent/errdefs"
        "time"

        "github.com/docker/docker/api/types/container"
)

func (sm *StateMachine) removeApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.DockerCompose != nil </span><span class="cov0" title="0">{
                return sm.removeComposeApp(payload, app)
        }</span>

        <span class="cov0" title="0">if app.Stage == common.PROD </span><span class="cov0" title="0">{
                return sm.removeProdApp(payload, app)
        }</span> else<span class="cov0" title="0"> if app.Stage == common.DEV </span><span class="cov0" title="0">{
                return sm.removeDevApp(payload, app)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (sm *StateMachine) removeComposeApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        containerName := payload.ContainerName.Dev
        if payload.Stage == common.PROD </span><span class="cov0" title="0">{
                containerName = payload.ContainerName.Prod
        }</span>

        <span class="cov0" title="0">err := sm.LogManager.ClearLogHistory(containerName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">removeInitMessage := fmt.Sprintf("Starting removal process for %s...", payload.AppName)
        err = sm.LogManager.Write(containerName, removeInitMessage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.DELETING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">options := map[string]interface{}{"force": true}

        dockerComposePath, err := sm.SetupComposeFiles(payload, app, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compose := sm.Container.Compose()
        // Need to remove it anyway even if it's not supported

        if !compose.Supported </span><span class="cov0" title="0">{
                err = sm.setState(app, common.REMOVED)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">sucessRemoveMessage := fmt.Sprintf("Successfully removed %s!", payload.AppName)

                return sm.LogManager.Write(containerName, sucessRemoveMessage)</span>
        }

        <span class="cov0" title="0">_, cmd, err := compose.Down(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, cmd, err = compose.Remove(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">images, err := compose.ListImages(payload.DockerCompose)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, imageName := range images </span><span class="cov0" title="0">{
                removeImagesByNameContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()

                err = sm.Container.RemoveImage(removeImagesByNameContext, imageName, options)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        <span class="cov0" title="0">err = sm.setState(app, common.REMOVED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sucessRemoveMessage := fmt.Sprintf("Successfully removed %s!", payload.AppName)

        return sm.LogManager.Write(containerName, sucessRemoveMessage)</span>
}

func (sm *StateMachine) removeDevApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{

        err := sm.LogManager.ClearLogHistory(payload.ContainerName.Dev)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">removeInitMessage := fmt.Sprintf("Starting removal process for %s...", payload.AppName)
        err = sm.LogManager.Write(payload.ContainerName.Dev, removeInitMessage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.DELETING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">options := map[string]interface{}{"force": true}

        getContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        // check if the image has a running container
        cont, err := sm.Container.GetContainer(getContainerContext, payload.ContainerName.Dev)
        if err != nil </span><span class="cov0" title="0">{
                if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                removeContainerByIdContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()

                // remove container if it exists
                removeContainerErr := sm.Container.RemoveContainerByID(removeContainerByIdContext, cont.ID, options)
                if removeContainerErr != nil </span><span class="cov0" title="0">{
                        if !errdefs.IsContainerNotFound(removeContainerErr) </span><span class="cov0" title="0">{
                                return removeContainerErr
                        }</span>
                }

                <span class="cov0" title="0">waitForContainerByIDContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()
                _, err = sm.Container.WaitForContainerByID(waitForContainerByIDContext, cont.ID, container.WaitConditionRemoved)
                if err != nil </span><span class="cov0" title="0">{
                        // expected behaviour, see: https://github.com/docker/docker-py/issues/2270
                        // still useful, and will wait if it's still not removed
                        if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">removeImagesByNameContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        err = sm.Container.RemoveImagesByName(removeImagesByNameContext, payload.RegistryImageName.Dev, options)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.REMOVED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sucessRemoveMessage := fmt.Sprintf("Successfully removed %s!", payload.AppName)
        return sm.LogManager.Write(payload.ContainerName.Dev, sucessRemoveMessage)</span>
}

func (sm *StateMachine) removeProdApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{

        err := sm.LogManager.ClearLogHistory(payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">removeInitMessage := fmt.Sprintf("Starting removal process for %s...", payload.AppName)
        err = sm.LogManager.Write(payload.ContainerName.Prod, removeInitMessage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.DELETING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">options := map[string]interface{}{"force": true}

        // check if the image has a running container
        getContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        cont, err := sm.Container.GetContainer(getContainerContext, payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // remove container if it exists
                removeContainerByIdContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()

                removeContainerErr := sm.Container.RemoveContainerByID(removeContainerByIdContext, cont.ID, options)
                if removeContainerErr != nil </span><span class="cov0" title="0">{
                        if !errdefs.IsContainerNotFound(removeContainerErr) </span><span class="cov0" title="0">{
                                return removeContainerErr
                        }</span>
                }

                <span class="cov0" title="0">waitForContainerByIDContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()

                _, err = sm.Container.WaitForContainerByID(waitForContainerByIDContext, cont.ID, container.WaitConditionRemoved)
                if err != nil </span><span class="cov0" title="0">{
                        // expected behaviour, see: https://github.com/docker/docker-py/issues/2270
                        // still useful, and will wait if it's still not removed
                        if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">removeImagesByNameContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        err = sm.Container.RemoveImagesByName(removeImagesByNameContext, payload.RegistryImageName.Prod, options)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.REMOVED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sucessRemoveMessage := fmt.Sprintf("Successfully removed %s!", payload.AppName)
        return sm.LogManager.Write(payload.ContainerName.Prod, sucessRemoveMessage)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package apps

import (
        "reagent/common"
)

func (sm *StateMachine) removedToPresent(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                return sm.noActionTransitionFunc(payload, app)
        }</span>

        <span class="cov0" title="0">return sm.pullApp(payload, app)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package apps

import (
        "context"
        "errors"
        "fmt"
        "os"
        "reagent/common"
        "reagent/config"
        "reagent/errdefs"
        "reagent/system"
        "reagent/tunnel"
        "strings"
        "time"

        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/api/types/mount"
        "github.com/docker/docker/api/types/network"
        "github.com/rs/zerolog/log"
)

func (sm *StateMachine) runApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                return sm.runDevApp(payload, app)
        }</span> else<span class="cov0" title="0"> if payload.Stage == common.PROD </span><span class="cov0" title="0">{
                return sm.runProdApp(payload, app)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (sm *StateMachine) runProdApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.DockerCompose != nil </span><span class="cov0" title="0">{
                return sm.runProdComposeApp(payload, app)
        }</span>

        <span class="cov0" title="0">err := sm.LogManager.ClearLogHistory(payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Prod, fmt.Sprintf("Starting %s...", payload.AppName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.STARTING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">containerID, err := sm.startContainer(payload, app)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pollingRate := time.Second * 1
        waitForRunningContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()
        runningSignal, errC := sm.Container.WaitForRunning(waitForRunningContext, containerID, pollingRate)

        // block and wait for running, if exited status then return as a failed state
        select </span>{
        case err = &lt;-errC:<span class="cov0" title="0">
                sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("The app failed to start, reason: %s", err.Error()))
                options := common.Dict{"follow": true, "stdout": true, "stderr": true}
                ioReader, logsErr := sm.Container.Logs(context.Background(), containerID, options)
                if logsErr != nil </span><span class="cov0" title="0">{
                        return logsErr
                }</span>

                <span class="cov0" title="0">sm.LogManager.StreamBlocking(payload.ContainerName.Prod, common.APP, ioReader)
                return err</span>
        case &lt;-runningSignal:<span class="cov0" title="0">
                break</span>
        }

        <span class="cov0" title="0">err = sm.setState(app, common.RUNNING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Prod, fmt.Sprintf("Now running app %s (%s)", payload.AppName, app.Version))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Stream(payload.ContainerName.Prod, common.APP, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (sm *StateMachine) runDevComposeApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        err := sm.LogManager.ClearLogHistory(payload.ContainerName.Dev)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compose := sm.Container.Compose()

        dockerComposePath, err := sm.SetupComposeFiles(payload, app, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.HandleRegistryLoginsWithDefault(payload)
        if err != nil </span><span class="cov0" title="0">{
                writeErr := sm.LogManager.Write(payload.ContainerName.Prod, err.Error())
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">err = sm.setState(app, common.STARTING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, cmd, err := compose.Stop(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, cmd, err = compose.Remove(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("Starting %s...", payload.AppName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">outputChan, upCmd, err := compose.Up(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = sm.LogManager.StreamLogsChannel(outputChan, payload.ContainerName.Dev)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = upCmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">waitForRunningContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        pollingRate := time.Second * 1
        runningSignal, errC := compose.WaitForRunning(waitForRunningContext, dockerComposePath, pollingRate)

        // block and wait for running, if exited status then return as a failed state
        select </span>{
        case err = &lt;-errC:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        // cleanup docker containers
                        _, cmd, cleanupErr := compose.Stop(dockerComposePath)
                        if cleanupErr != nil </span><span class="cov0" title="0">{
                                return cleanupErr
                        }</span>

                        <span class="cov0" title="0">cleanupErr = cmd.Wait()
                        if cleanupErr != nil </span><span class="cov0" title="0">{
                                return cleanupErr
                        }</span>

                        <span class="cov0" title="0">_, cmd, cleanupErr = compose.Remove(dockerComposePath)
                        if cleanupErr != nil </span><span class="cov0" title="0">{
                                return cleanupErr
                        }</span>

                        <span class="cov0" title="0">cleanupErr = cmd.Wait()
                        if cleanupErr != nil </span><span class="cov0" title="0">{
                                return cleanupErr
                        }</span>

                        <span class="cov0" title="0">sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("The app failed to start, reason: %s", err.Error()))
                        return err</span>
                }
                <span class="cov0" title="0">break</span>
        case &lt;-runningSignal:<span class="cov0" title="0">
                break</span>
        }

        <span class="cov0" title="0">err = sm.setState(app, common.RUNNING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("Now running app %s (%s)", payload.AppName, app.Version))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logsChannel, err := compose.LogStream(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = sm.LogManager.StreamLogsChannel(logsChannel, payload.ContainerName.Dev)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (sm *StateMachine) runProdComposeApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        err := sm.LogManager.ClearLogHistory(payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compose := sm.Container.Compose()
        if !compose.Supported </span><span class="cov0" title="0">{
                message := "Docker Compose is not supported for this device"
                writeErr := sm.LogManager.Write(payload.ContainerName.Prod, message)
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>

                <span class="cov0" title="0">return errdefs.DockerComposeNotSupported(errors.New("docker compose is not supported"))</span>
        }

        <span class="cov0" title="0">err = sm.HandleRegistryLoginsWithDefault(payload)
        if err != nil </span><span class="cov0" title="0">{
                writeErr := sm.LogManager.Write(payload.ContainerName.Prod, err.Error())
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">dockerComposePath, err := sm.SetupComposeFiles(payload, app, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.STARTING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, cmd, err := compose.Stop(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, cmd, err = compose.Remove(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Prod, fmt.Sprintf("Starting %s...", payload.AppName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.STARTING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">outputChan, upCmd, err := compose.Up(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = sm.LogManager.StreamLogsChannel(outputChan, payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = upCmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pollingRate := time.Second * 1
        waitForRunningContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        runningSignal, errC := compose.WaitForRunning(waitForRunningContext, dockerComposePath, pollingRate)

        // block and wait for running, if exited status then return as a failed state
        select </span>{
        case err = &lt;-errC:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        // cleanup docker containers
                        _, cmd, cleanupErr := compose.Stop(dockerComposePath)
                        if cleanupErr != nil </span><span class="cov0" title="0">{
                                return cleanupErr
                        }</span>

                        <span class="cov0" title="0">cleanupErr = cmd.Wait()
                        if cleanupErr != nil </span><span class="cov0" title="0">{
                                return cleanupErr
                        }</span>

                        <span class="cov0" title="0">_, cmd, cleanupErr = compose.Remove(dockerComposePath)
                        if cleanupErr != nil </span><span class="cov0" title="0">{
                                return cleanupErr
                        }</span>

                        <span class="cov0" title="0">cleanupErr = cmd.Wait()
                        if cleanupErr != nil </span><span class="cov0" title="0">{
                                return cleanupErr
                        }</span>

                        <span class="cov0" title="0">sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("The app failed to start, reason: %s", err.Error()))
                        return err</span>
                }
                <span class="cov0" title="0">break</span>
        case &lt;-runningSignal:<span class="cov0" title="0">
                break</span>
        }

        <span class="cov0" title="0">err = sm.setState(app, common.RUNNING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Prod, fmt.Sprintf("Now running app %s (%s)", payload.AppName, app.Version))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logsChannel, err := compose.LogStream(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = sm.LogManager.StreamLogsChannel(logsChannel, payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (sm *StateMachine) runDevApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.DockerCompose != nil </span><span class="cov0" title="0">{
                return sm.runDevComposeApp(payload, app)
        }</span>

        <span class="cov0" title="0">getContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        // remove old container first, if it exists
        cont, err := sm.Container.GetContainer(getContainerContext, payload.ContainerName.Dev)
        if err != nil </span><span class="cov0" title="0">{
                if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                RemoveContainerByIDContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()

                removeContainerErr := sm.Container.RemoveContainerByID(RemoveContainerByIDContext, cont.ID, map[string]interface{}{"force": true})
                if removeContainerErr != nil </span><span class="cov0" title="0">{
                        // It's possible we're trying to remove the container when it's already being removed
                        // RUNNING -&gt; STOPPED -&gt; RUNNING
                        // It's also possible the container does not exist yet, if it's the first time you're building the app
                        if !errdefs.IsContainerRemovalAlreadyInProgress(removeContainerErr) &amp;&amp; !errdefs.IsContainerNotFound(removeContainerErr) </span><span class="cov0" title="0">{
                                return removeContainerErr
                        }</span>
                }

                <span class="cov0" title="0">waitForContainerByIDContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()

                _, err = sm.Container.WaitForContainerByID(waitForContainerByIDContext, cont.ID, container.WaitConditionRemoved)
                if err != nil </span><span class="cov0" title="0">{
                        // expected behaviour, see: https://github.com/docker/docker-py/issues/2270
                        // still useful, and will wait if it's still not removed
                        if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }

        <span class="cov0" title="0">err = sm.LogManager.ClearLogHistory(payload.ContainerName.Dev)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("Starting %s...", payload.AppName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.STARTING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">newContainerID, err := sm.startContainer(payload, app)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pollingRate := time.Second * 1
        waitForRunningContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        runningSignal, errC := sm.Container.WaitForRunning(waitForRunningContext, newContainerID, pollingRate)

        // block and wait for running, if exited status then return as a failed state
        select </span>{
        case err = &lt;-errC:<span class="cov0" title="0">
                sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("The app failed to start, reason: %s", err.Error()))
                options := common.Dict{"follow": true, "stdout": true, "stderr": true}
                ioReader, logsErr := sm.Container.Logs(context.Background(), newContainerID, options)
                if logsErr != nil </span><span class="cov0" title="0">{
                        return logsErr
                }</span>

                <span class="cov0" title="0">sm.LogManager.StreamBlocking(payload.ContainerName.Dev, common.APP, ioReader)
                return err</span>
        case &lt;-runningSignal:<span class="cov0" title="0">
                break</span>
        }

        <span class="cov0" title="0">err = sm.setState(app, common.RUNNING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("Now running app %s", payload.AppName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Stream(payload.ContainerName.Dev, common.APP, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func buildProdEnvironmentVariables(defaultEnvironmentVariables []string, payloadEnvironmentVariables map[string]interface{}) []string <span class="cov0" title="0">{
        return append(defaultEnvironmentVariables, common.EnvironmentVarsToStringArray((payloadEnvironmentVariables))...)
}</span>

const maxEnvVarSize = 20 * 1024 // 20KB - reasonable maximum for environment variables

func writeEnvironmentVariablesToFiles(appSpecificDirectory string, envVars []string) error <span class="cov0" title="0">{
        envDir := appSpecificDirectory + "/env"
        err := os.MkdirAll(envDir, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, envVar := range envVars </span><span class="cov0" title="0">{
                parts := strings.SplitN(envVar, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">varName := parts[0]
                varValue := parts[1]

                filePath := fmt.Sprintf("%s/%s.txt", envDir, varName)
                err := os.WriteFile(filePath, []byte(varValue), 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write env var %s to file: %w", varName, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// filterLargeEnvVars returns only env vars that are below the size threshold
// Large env vars should only be accessed via files in /data/env/
func filterLargeEnvVars(envVars []string) []string <span class="cov0" title="0">{
        filtered := make([]string, 0, len(envVars))
        for _, envVar := range envVars </span><span class="cov0" title="0">{
                if len(envVar) &lt;= maxEnvVarSize </span><span class="cov0" title="0">{
                        filtered = append(filtered, envVar)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

func computeMounts(stage common.Stage, appName string, config *config.Config) ([]mount.Mount, error) <span class="cov0" title="0">{
        appSpecificDirectory := config.CommandLineArguments.AppsDirectory + "/" + strings.ToLower(string(stage)) + "/" + strings.ToLower(appName)

        err := os.MkdirAll(appSpecificDirectory, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                if !os.IsExist(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">mounts := []mount.Mount{
                {
                        Type:     mount.TypeBind,
                        Source:   config.CommandLineArguments.AppsSharedDir,
                        Target:   "/shared",
                        ReadOnly: false,
                },
                {
                        Type:     mount.TypeBind,
                        Source:   appSpecificDirectory,
                        Target:   "/data",
                        ReadOnly: false,
                },
        }

        if _, err := os.Stat("/sys/bus/w1/devices"); !os.IsNotExist(err) </span><span class="cov0" title="0">{
                mounts = append(mounts, mount.Mount{
                        Type:     mount.TypeBind,
                        Source:   "/sys/bus/w1/devices",
                        Target:   "/sys/bus/w1/devices",
                        ReadOnly: false,
                })
        }</span>

        // for nvidia
        <span class="cov0" title="0">if _, err := os.Stat("/usr/local/cuda"); !os.IsNotExist(err) </span><span class="cov0" title="0">{
                mounts = append(mounts, mount.Mount{
                        Type:     mount.TypeBind,
                        Source:   "/usr/local/cuda",
                        Target:   "/usr/local/cuda",
                        ReadOnly: false,
                })
        }</span>

        <span class="cov0" title="0">return mounts, nil</span>
}

func buildDefaultEnvironmentVariables(config *config.Config, environment common.Stage, app *common.App) []string <span class="cov0" title="0">{
        environmentVariables := []string{
                fmt.Sprintf("DEVICE_SERIAL_NUMBER=%s", config.ReswarmConfig.SerialNumber),
                fmt.Sprintf("ENV=%s", environment),
                fmt.Sprintf("DEVICE_KEY=%d", config.ReswarmConfig.DeviceKey),
                fmt.Sprintf("SWARM_KEY=%d", config.ReswarmConfig.SwarmKey),
                fmt.Sprintf("APP_KEY=%d", app.AppKey),
                fmt.Sprintf("APP_NAME=%s", app.AppName),
                fmt.Sprintf("DEVICE_SECRET=%s", config.ReswarmConfig.Secret),
                fmt.Sprintf("DEVICE_NAME=%s", config.ReswarmConfig.Name),
                fmt.Sprintf("DEVICE_ENDPOINT_URL=%s", config.ReswarmConfig.DeviceEndpointURL),
        }

        if config.ReswarmConfig.ReswarmBaseURL != "" </span><span class="cov0" title="0">{
                deviceURL := fmt.Sprintf("%s/%s/swarms/%s/settings/devices/%s", config.ReswarmConfig.ReswarmBaseURL, config.ReswarmConfig.SwarmOwnerName, config.ReswarmConfig.SwarmName, config.ReswarmConfig.Name)
                environmentVariables = append(environmentVariables, fmt.Sprintf("RESWARM_URL=%s", config.ReswarmConfig.ReswarmBaseURL))
                environmentVariables = append(environmentVariables, fmt.Sprintf("DEVICE_URL=%s", deviceURL))
        }</span>

        <span class="cov0" title="0">return environmentVariables</span>
}

func (sm *StateMachine) computeContainerConfigs(payload common.TransitionPayload, app *common.App) (*container.Config, *container.HostConfig, error) <span class="cov0" title="0">{
        config := sm.Container.GetConfig()
        systemDefaultVariables := buildDefaultEnvironmentVariables(config, app.Stage, app)
        environmentVariables := buildProdEnvironmentVariables(systemDefaultVariables, payload.EnvironmentVariables)
        environmentTemplateDefaults := common.EnvironmentTemplateToStringArray(payload.EnvironmentTemplate)

        // Get app-specific directory for writing env vars
        appSpecificDirectory := config.CommandLineArguments.AppsDirectory + "/" + strings.ToLower(string(app.Stage)) + "/" + strings.ToLower(app.AppName)

        var containerConfig container.Config

        if app.Stage == common.DEV </span><span class="cov0" title="0">{
                // Write all environment variables to files
                allEnvVars := append(systemDefaultVariables, environmentTemplateDefaults...)
                err := writeEnvironmentVariablesToFiles(appSpecificDirectory, allEnvVars)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to write environment variables to files: %w", err)
                }</span>

                // Only pass small env vars to container, large ones are available in /data/env/
                <span class="cov0" title="0">containerEnvVars := filterLargeEnvVars(allEnvVars)

                containerConfig = container.Config{
                        Image:        payload.RegistryImageName.Dev,
                        Env:          containerEnvVars,
                        Labels:       map[string]string{"real": "True"},
                        Volumes:      map[string]struct{}{},
                        AttachStdin:  true,
                        AttachStdout: true,
                        AttachStderr: true,
                        OpenStdin:    true,
                        Tty:          true,
                }</span>
        } else<span class="cov0" title="0"> {

                fullImageNameWithTag := fmt.Sprintf("%s:%s", payload.RegistryImageName.Prod, app.Version)
                getImageContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()

                _, err := sm.Container.GetImage(getImageContext, payload.RegistryImageName.Prod, payload.PresentVersion)
                if err != nil </span><span class="cov0" title="0">{
                        if errdefs.IsImageNotFound(err) </span><span class="cov0" title="0">{
                                log.Error().Msgf("Image %s:%s was not found, pulling......", payload.RegistryImageName.Prod, payload.PresentVersion)
                                pullErr := sm.pullApp(payload, app)
                                if pullErr != nil </span><span class="cov0" title="0">{
                                        return nil, nil, pullErr
                                }</span>
                        }
                }

                <span class="cov0" title="0">var missingDefaultEnvs []string
                for _, templateEnvString := range environmentTemplateDefaults </span><span class="cov0" title="0">{
                        envStringSplit := strings.Split(templateEnvString, "=")
                        environmentName := envStringSplit[0]

                        found := false
                        for _, envVariableString := range environmentVariables </span><span class="cov0" title="0">{
                                if strings.Contains(envVariableString, environmentName) </span><span class="cov0" title="0">{
                                        found = true
                                }</span>
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                missingDefaultEnvs = append(missingDefaultEnvs, templateEnvString)
                        }</span>
                }

                <span class="cov0" title="0">var remotePortEnvs []string
                portRules, err := tunnel.InterfaceToPortForwardRule(payload.Ports)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov0" title="0">for _, portRule := range portRules </span><span class="cov0" title="0">{
                        if portRule.RemotePortEnvironment != "" </span><span class="cov0" title="0">{
                                subdomain := tunnel.CreateSubdomain(tunnel.Protocol(portRule.Protocol), uint64(config.ReswarmConfig.DeviceKey), app.AppName, portRule.Port)
                                tunnelID := tunnel.CreateTunnelID(subdomain, portRule.Protocol)
                                tunnel := sm.StateObserver.AppManager.tunnelManager.Get(tunnelID)

                                if tunnel != nil </span><span class="cov0" title="0">{
                                        portEnv := fmt.Sprintf("%s=%d", portRule.RemotePortEnvironment, tunnel.Config.RemotePort)
                                        remotePortEnvs = append(remotePortEnvs, portEnv)
                                }</span>
                        }
                }

                // Write all environment variables to files
                <span class="cov0" title="0">allEnvVars := append(environmentVariables, append(remotePortEnvs, missingDefaultEnvs...)...)
                err = writeEnvironmentVariablesToFiles(appSpecificDirectory, allEnvVars)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to write environment variables to files: %w", err)
                }</span>

                // Only pass small env vars to container, large ones are available in /data/env/
                <span class="cov0" title="0">containerEnvVars := filterLargeEnvVars(allEnvVars)

                containerConfig = container.Config{
                        Image:  fullImageNameWithTag,
                        Env:    containerEnvVars,
                        Labels: map[string]string{"real": "True"},
                        Tty:    true,
                }</span>
        }

        <span class="cov0" title="0">mounts, err := computeMounts(app.Stage, app.AppName, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">hostConfig := container.HostConfig{
                // CapDrop: []string{"NET_ADMIN"},
                RestartPolicy: container.RestartPolicy{
                        Name: "no",
                },
                Mounts: mounts,
                Resources: container.Resources{
                        Devices: []container.DeviceMapping{
                                {
                                        PathOnHost:      "/dev",
                                        PathInContainer: "/dev",
                                },
                        },
                },
                Privileged:  true,
                NetworkMode: "host",
                CapAdd:      []string{"ALL"},
        }

        if system.HasNvidiaGPU() </span><span class="cov0" title="0">{
                log.Debug().Msgf("Detected a NVIDIA GPU, will request NVIDIA Device capabilities...")
                hostConfig.Runtime = "nvidia"
                // hostConfig.DeviceRequests = []container.DeviceRequest{
                //         {
                //                 Driver: "nvidia",
                //                 Count:  -1,
                //                 Capabilities: [][]string{
                //                         {
                //                                 "compute", "compat32", "graphics", "utility", "video", "display",
                //                         },
                //                 },
                //         },
                // }
        }</span>

        <span class="cov0" title="0">return &amp;containerConfig, &amp;hostConfig, nil</span>
}

func (sm *StateMachine) createContainer(payload common.TransitionPayload, app *common.App, cConfig *container.Config, hConfig *container.HostConfig) (string, error) <span class="cov0" title="0">{
        var containerID string
        var containerName string

        if app.Stage == common.PROD </span><span class="cov0" title="0">{
                containerName = payload.ContainerName.Prod
        }</span> else<span class="cov0" title="0"> {
                containerName = payload.ContainerName.Dev
        }</span>

        <span class="cov0" title="0">getContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()
        cont, err := sm.Container.GetContainer(getContainerContext, containerName)
        if err != nil </span><span class="cov0" title="0">{
                if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">createContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()
                containerID, err = sm.Container.CreateContainer(createContainerContext, *cConfig, *hConfig, network.NetworkingConfig{}, containerName)
                if err != nil </span><span class="cov0" title="0">{
                        if errdefs.IsImageNotFound(err) &amp;&amp; app.Stage == common.DEV </span><span class="cov0" title="0">{
                                imageNotFoundMessage := "The image " + payload.RegistryImageName.Dev + " was not found on the device, try building the app again..."
                                sm.LogManager.Write(containerName, imageNotFoundMessage)
                        }</span>
                        <span class="cov0" title="0">if strings.Contains(err.Error(), "nvidia") </span><span class="cov0" title="0">{
                                log.Debug().Msgf("Failed to launch container with NVIDIA Capabilities, retrying without... %s \n", err.Error())

                                removeContainerByIdContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                                defer cancel()
                                sm.Container.RemoveContainerByID(removeContainerByIdContext, containerID, map[string]interface{}{"force": true})

                                // remove NVIDIA host configuration
                                hConfig.Runtime = ""
                                hConfig.DeviceRequests = []container.DeviceRequest{}

                                createContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                                defer cancel()
                                containerID, err = sm.Container.CreateContainer(createContainerContext, *cConfig, *hConfig, network.NetworkingConfig{}, containerName)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return "", err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                containerID = cont.ID
        }</span>

        <span class="cov0" title="0">return containerID, nil</span>
}

func (sm *StateMachine) startContainer(payload common.TransitionPayload, app *common.App) (string, error) <span class="cov0" title="0">{
        containerConfig, hostConfig, err := sm.computeContainerConfigs(payload, app)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">containerID, err := sm.createContainer(payload, app, containerConfig, hostConfig)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">startContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        err = sm.Container.StartContainer(startContainerContext, containerID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "nvidia") </span><span class="cov0" title="0">{
                        log.Debug().Msgf("Failed to launch container with NVIDIA Capabilities, retrying without... %s \n", err.Error())

                        removeContainerByIdContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                        defer cancel()
                        sm.Container.RemoveContainerByID(removeContainerByIdContext, containerID, map[string]interface{}{"force": true})

                        // remove nvidia device request
                        hostConfig.DeviceRequests = []container.DeviceRequest{}

                        containerID, err = sm.createContainer(payload, app, containerConfig, hostConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">startContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                        defer cancel()

                        err = sm.Container.StartContainer(startContainerContext, containerID)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                }
        }

        <span class="cov0" title="0">return containerID, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package apps

import (
        "reagent/common"
        "reagent/container"
        "reagent/errdefs"
        "reagent/filesystem"
        "reagent/logging"
        "reagent/safe"

        "github.com/rs/zerolog/log"
)

type TransitionFunc func(TransitionPayload common.TransitionPayload, app *common.App) error

type StateMachine struct {
        StateObserver *StateObserver
        Filesystem    *filesystem.Filesystem
        Container     container.Container
        LogManager    *logging.LogManager
        appStates     []*common.App
}

func NewStateMachine(container container.Container, logManager *logging.LogManager, observer *StateObserver, filesystem *filesystem.Filesystem) StateMachine <span class="cov5" title="7">{
        appStates := make([]*common.App, 0)
        return StateMachine{
                StateObserver: observer,
                Container:     container,
                LogManager:    logManager,
                Filesystem:    filesystem,
                appStates:     appStates,
        }
}</span>

func (sm *StateMachine) noActionTransitionFunc(TransitionPayload common.TransitionPayload, app *common.App) error <span class="cov1" title="1">{
        return errdefs.NoActionTransition()
}</span>

func (sm *StateMachine) getTransitionFunc(prevState common.AppState, nextState common.AppState) TransitionFunc <span class="cov10" title="46">{
        var stateTransitionMap = map[common.AppState]map[common.AppState]TransitionFunc{
                common.REMOVED: {
                        common.PRESENT:     sm.removedToPresent,
                        common.RUNNING:     sm.removedToRunning,
                        common.BUILT:       sm.buildApp,
                        common.PUBLISHED:   sm.publishApp,
                        common.UNINSTALLED: sm.uninstallApp,
                        common.REMOVED:     sm.noActionTransitionFunc,
                },
                common.UNINSTALLED: {
                        common.PRESENT:     sm.pullApp,
                        common.RUNNING:     sm.runApp,
                        common.BUILT:       sm.buildApp,
                        common.PUBLISHED:   sm.publishApp,
                        common.UNINSTALLED: sm.noActionTransitionFunc,
                },
                common.PUBLISHING: {
                        common.REMOVED: sm.cancelPush,
                },
                common.BUILDING: {
                        common.REMOVED: sm.cancelBuild,
                },
                common.STOPPED: {
                        common.REMOVED:     sm.removeApp,
                        common.UNINSTALLED: sm.uninstallApp,
                        common.RUNNING:     sm.runApp,
                        common.BUILT:       sm.buildApp,
                        common.PUBLISHED:   sm.publishApp,
                        common.STOPPED:     sm.noActionTransitionFunc,
                },
                common.PRESENT: {
                        common.REMOVED:     sm.removeApp,
                        common.UNINSTALLED: sm.uninstallApp,
                        common.RUNNING:     sm.runApp,
                        common.BUILT:       sm.buildApp,
                        common.PUBLISHED:   sm.publishApp,
                        common.PRESENT:     sm.noActionTransitionFunc,
                },
                common.FAILED: {
                        common.REMOVED:     sm.removeApp,
                        common.UNINSTALLED: sm.uninstallApp,
                        common.PRESENT:     sm.recoverFailToPresentHandler,
                        common.RUNNING:     sm.recoverFailToRunningHandler,
                        common.BUILT:       sm.buildApp,
                        common.PUBLISHED:   sm.publishApp,
                },
                common.BUILT: {
                        common.REMOVED:     sm.removeApp,
                        common.UNINSTALLED: sm.uninstallApp,
                        common.PRESENT:     sm.noActionTransitionFunc,
                        common.RUNNING:     sm.runApp,
                        common.BUILT:       sm.buildApp,
                        common.PUBLISHED:   sm.publishApp,
                },
                common.TRANSFERED: {
                        common.REMOVED:     sm.removeApp,
                        common.UNINSTALLED: sm.uninstallApp,
                        common.PRESENT:     sm.pullApp,
                },
                common.TRANSFERING: {
                        common.REMOVED:     sm.cancelTransfer,
                        common.UNINSTALLED: sm.cancelTransfer,
                        common.PRESENT:     sm.cancelTransfer,
                },
                common.PUBLISHED: {
                        common.REMOVED:     sm.removeApp,
                        common.UNINSTALLED: sm.uninstallApp,
                        common.RUNNING:     sm.runApp,
                        common.PRESENT:     sm.noActionTransitionFunc,
                        common.BUILT:       sm.buildApp,
                        common.PUBLISHED:   sm.publishApp,
                },
                common.RUNNING: {
                        common.RUNNING:     sm.noActionTransitionFunc,
                        common.PRESENT:     sm.stopApp,
                        common.BUILT:       sm.stopApp,
                        common.PUBLISHED:   sm.removeAndPublishApp,
                        common.REMOVED:     sm.removeApp,
                        common.UNINSTALLED: sm.uninstallApp,
                },
                common.DOWNLOADING: {
                        common.PRESENT:     sm.pullApp,
                        common.REMOVED:     sm.cancelPull,
                        common.UNINSTALLED: sm.cancelPull,
                },
                common.STARTING: {
                        common.PRESENT:     sm.stopApp,
                        common.REMOVED:     sm.removeApp,
                        common.UNINSTALLED: sm.uninstallApp,
                        common.RUNNING:     sm.runApp,
                },
                common.STOPPING: {
                        common.PRESENT:     sm.stopApp,
                        common.REMOVED:     sm.removeApp,
                        common.UNINSTALLED: sm.uninstallApp,
                        common.RUNNING:     sm.runApp,
                },
                common.UPDATING: {
                        common.PRESENT:     sm.cancelUpdate,
                        common.REMOVED:     sm.cancelUpdateAndRemove,
                        common.UNINSTALLED: sm.uninstallApp,
                        common.RUNNING:     nil,
                },
                common.DELETING: {
                        common.PRESENT:     nil,
                        common.REMOVED:     sm.removeApp,
                        common.UNINSTALLED: sm.uninstallApp,
                        common.RUNNING:     nil,
                },
        }

        return stateTransitionMap[prevState][nextState]
}</span>

func (sm *StateMachine) setState(app *common.App, state common.AppState) error <span class="cov0" title="0">{
        err := sm.StateObserver.Notify(app, state)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (sm *StateMachine) executeTransition(app *common.App, payload common.TransitionPayload, transitionFunc TransitionFunc) chan error <span class="cov0" title="0">{
        errChannel := make(chan error, 1)

        safe.Go(func() </span><span class="cov0" title="0">{
                log.Info().Msgf("Executing transition from %s to %s for %s (%s)...", app.CurrentState, payload.RequestedState, app.AppName, app.Stage)
                err := transitionFunc(payload, app)

                // send potential error to errChannel
                // if error = nil, the transition has completed successfully
                errChannel &lt;- err

                // we are done sending, should close the channel
                close(errChannel)
        }</span>)

        <span class="cov0" title="0">return errChannel</span>
}

func (sm *StateMachine) CancelTransition(app *common.App, payload common.TransitionPayload) chan error <span class="cov0" title="0">{
        app.StateLock.Lock()
        curAppState := app.CurrentState
        app.StateLock.Unlock()

        transitionFunc := sm.getTransitionFunc(curAppState, payload.RequestedState)
        if transitionFunc == nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("It appears the cancel transition function does not exist. In %s to %s for %s (%s)", curAppState, payload.RequestedState, payload.AppName, payload.Stage)
                return nil
        }</span>

        <span class="cov0" title="0">return sm.executeTransition(app, payload, transitionFunc)</span>
}

func (sm *StateMachine) InitTransition(app *common.App, payload common.TransitionPayload) chan error <span class="cov0" title="0">{
        app.StateLock.Lock()
        curAppState := app.CurrentState
        app.StateLock.Unlock()

        var transitionFunc TransitionFunc
        if payload.RequestUpdate &amp;&amp; payload.NewestVersion != app.Version &amp;&amp; payload.RequestedState != common.UNINSTALLED </span><span class="cov0" title="0">{
                transitionFunc = sm.getUpdateTransition(payload, app)
        }</span> else<span class="cov0" title="0"> {
                transitionFunc = sm.getTransitionFunc(curAppState, payload.RequestedState)
        }</span>

        <span class="cov0" title="0">if transitionFunc == nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("Not yet implemented transition from %s to %s", curAppState, payload.RequestedState)
                return nil
        }</span>

        <span class="cov0" title="0">return sm.executeTransition(app, payload, transitionFunc)</span>
}

func (sm *StateMachine) HandleRegistryLoginsWithDefault(payload common.TransitionPayload) error <span class="cov0" title="0">{
        config := sm.Container.GetConfig()

        if payload.DockerCredentials == nil </span><span class="cov0" title="0">{
                payload.DockerCredentials = make(map[string]common.DockerCredential)
        }</span>

        <span class="cov0" title="0">payload.DockerCredentials[config.ReswarmConfig.DockerRegistryURL] = common.DockerCredential{
                Username: payload.RegisteryToken,
                Password: config.ReswarmConfig.Secret,
        }

        return sm.Container.HandleRegistryLogins(payload.DockerCredentials)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package apps

import (
        "context"
        "errors"
        "fmt"
        "reagent/common"
        "reagent/container"
        "reagent/errdefs"
        "reagent/logging"
        "reagent/safe"
        "reagent/store"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/rs/zerolog/log"
)

type AppStateObserver struct {
        Stage   common.Stage
        AppKey  uint64
        AppName string
        errChan chan error
}

type StateObserver struct {
        AppStore         *store.AppStore
        LogManager       *logging.LogManager
        AppManager       *AppManager
        Container        container.Container
        activeObservers  map[string]*AppStateObserver
        spawnerActive    bool
        observerMapMutex sync.Mutex
}

func NewObserver(container container.Container, appStore *store.AppStore, logManager *logging.LogManager) StateObserver <span class="cov10" title="7">{
        return StateObserver{
                Container:       container,
                AppStore:        appStore,
                LogManager:      logManager,
                activeObservers: make(map[string]*AppStateObserver),
        }
}</span>

func (so *StateObserver) NotifyLocal(app *common.App, achievedState common.AppState) error <span class="cov0" title="0">{
        // update in memory
        app.StateLock.Lock()
        app.CurrentState = achievedState
        appKey := app.AppKey
        stage := app.Stage
        appName := app.AppName
        app.StateLock.Unlock()

        // First update the local app state
        err := so.AppStore.UpdateLocalAppState(app, achievedState)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If app reached REMOVED state, check if backend requested removal before cleaning up database
        <span class="cov0" title="0">if achievedState == common.REMOVED </span><span class="cov0" title="0">{
                // Check what the backend requested
                requestedState, err := so.AppStore.GetRequestedState(appKey, stage)
                if err != nil </span><span class="cov0" title="0">{
                        // If there's no requested state, don't delete
                        log.Debug().
                                Str("app", appName).
                                Uint64("app_key", appKey).
                                Str("stage", string(stage)).
                                Msg("No requested state found, keeping database entries")
                        return nil
                }</span>

                // Only delete from database if backend requested REMOVED or UNINSTALLED
                <span class="cov0" title="0">if requestedState.RequestedState == common.REMOVED || requestedState.RequestedState == common.UNINSTALLED </span><span class="cov0" title="0">{
                        log.Info().
                                Str("app", appName).
                                Uint64("app_key", appKey).
                                Str("stage", string(stage)).
                                Str("requested_state", string(requestedState.RequestedState)).
                                Msg(" App reached REMOVED state and backend requested removal, cleaning up database entries")

                        // Delete from database
                        err = so.AppStore.DeleteAppState(appKey, stage)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Stack().Err(err).Msg("Failed to delete app state from database")
                        }</span>

                        <span class="cov0" title="0">err = so.AppStore.DeleteRequestedState(appKey, stage)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Stack().Err(err).Msg("Failed to delete requested state from database")
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Debug().
                                Str("app", appName).
                                Uint64("app_key", appKey).
                                Str("stage", string(stage)).
                                Str("requested_state", string(requestedState.RequestedState)).
                                Msg("App reached REMOVED but backend requested different state, keeping database entries")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (so *StateObserver) NotifyRemote(app *common.App, achievedState common.AppState) error <span class="cov0" title="0">{
        ctx := context.Background()
        return so.AppStore.UpdateRemoteAppState(ctx, app, achievedState)
}</span>

// Notify is used by the StateMachine to notify the observer that the app state has changed
func (so *StateObserver) Notify(app *common.App, achievedState common.AppState) error <span class="cov0" title="0">{
        err := so.NotifyLocal(app, achievedState)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return so.NotifyRemote(app, achievedState)</span>
}

func (so *StateObserver) removeObserver(stage common.Stage, appKey uint64, appName string) bool <span class="cov0" title="0">{
        containerName := common.BuildContainerName(stage, appKey, appName)
        so.observerMapMutex.Lock()
        observer := so.activeObservers[containerName]

        deletedObserver := false
        if observer != nil </span><span class="cov0" title="0">{
                close(observer.errChan)
                delete(so.activeObservers, containerName)
                deletedObserver = true

                log.Debug().Msgf("removed an observer for %s (%s)", appName, stage)
        }</span>
        <span class="cov0" title="0">so.observerMapMutex.Unlock()

        return deletedObserver</span>
}

func (so *StateObserver) removeComposeObserver(stage common.Stage, appKey uint64, appName string) bool <span class="cov0" title="0">{
        composeAppName := common.BuildComposeContainerName(stage, appKey, appName)
        so.observerMapMutex.Lock()
        observer := so.activeObservers[composeAppName]

        deletedObserver := false
        if observer != nil </span><span class="cov0" title="0">{
                close(observer.errChan)
                delete(so.activeObservers, composeAppName)
                deletedObserver = true
                log.Debug().Msgf("removed a compose observer for %s (%s)", appName, stage)
        }</span>
        <span class="cov0" title="0">so.observerMapMutex.Unlock()

        return deletedObserver</span>
}

func (so *StateObserver) addComposeObserver(stage common.Stage, appKey uint64, appName string) (bool, error) <span class="cov0" title="0">{
        composeName := common.BuildComposeContainerName(stage, appKey, appName)
        compose := so.Container.Compose()
        composeEntryList, err := compose.List()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">var foundComposeEntry *container.ComposeListEntry
        for _, composeEntry := range composeEntryList </span><span class="cov0" title="0">{
                if composeEntry.Name == composeName </span><span class="cov0" title="0">{
                        foundComposeEntry = &amp;composeEntry
                        break</span>
                }
        }

        <span class="cov0" title="0">if foundComposeEntry == nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("No compose was found for %s, not creating an observer...", composeName)
                return false, nil
        }</span>

        <span class="cov0" title="0">createdObserver := false
        so.observerMapMutex.Lock()
        if so.activeObservers[composeName] == nil </span><span class="cov0" title="0">{
                errC := so.observeComposeAppState(stage, appKey, appName)
                so.activeObservers[composeName] = &amp;AppStateObserver{
                        AppKey:  appKey,
                        AppName: appName,
                        Stage:   stage,
                        errChan: errC,
                }
                createdObserver = true

                log.Debug().Msgf("created a compose observer for %s (%s)", appName, stage)
        }</span>
        <span class="cov0" title="0">so.observerMapMutex.Unlock()

        return createdObserver, nil</span>
}

func (so *StateObserver) addObserver(stage common.Stage, appKey uint64, appName string) bool <span class="cov0" title="0">{
        containerName := common.BuildContainerName(stage, appKey, appName)

        ctx := context.Background()
        _, err := so.Container.GetContainerState(ctx, containerName)
        if err != nil </span><span class="cov0" title="0">{
                if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">log.Debug().Msgf("No container was found for %s, not creating an observer...", containerName)
                return false</span>
        }

        <span class="cov0" title="0">createdObserver := false
        so.observerMapMutex.Lock()
        if so.activeObservers[containerName] == nil </span><span class="cov0" title="0">{
                errC := so.observeAppState(stage, appKey, appName)
                so.activeObservers[containerName] = &amp;AppStateObserver{
                        AppKey:  appKey,
                        AppName: appName,
                        Stage:   stage,
                        errChan: errC,
                }
                createdObserver = true
                log.Debug().Msgf("created an observer for %s (%s)", appName, stage)
        }</span>

        <span class="cov0" title="0">so.observerMapMutex.Unlock()

        return createdObserver</span>
}

func (so *StateObserver) CorrectComposeAppState(requestedState common.TransitionPayload, images []container.ImageResult, composeListEntry []container.ComposeListEntry, updateRemote bool) error <span class="cov0" title="0">{
        compose := so.Container.Compose()
        composeName := common.BuildComposeContainerName(requestedState.Stage, requestedState.AppKey, requestedState.AppName)
        app, err := so.AppStore.GetApp(requestedState.AppKey, requestedState.Stage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var foundComposeEntry *container.ComposeListEntry
        for _, composeEntry := range composeListEntry </span><span class="cov0" title="0">{
                if composeEntry.Name == composeName </span><span class="cov0" title="0">{
                        foundComposeEntry = &amp;composeEntry
                }</span>
        }

        // NEVER STARTED / REMOVED / STOPPED (no containers available)
        <span class="cov0" title="0">if foundComposeEntry == nil </span><span class="cov0" title="0">{
                app.StateLock.Lock()
                currentAppState := app.CurrentState
                app.StateLock.Unlock()

                // Need to get images
                services, ok := (requestedState.DockerCompose["services"]).(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("failed to infer services")
                }</span>

                <span class="cov0" title="0">foundAllImages := true
                for _, serviceInterface := range services </span><span class="cov0" title="0">{
                        service, ok := (serviceInterface).(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New("failed to infer service")
                        }</span>

                        <span class="cov0" title="0">if service["image"] != nil </span><span class="cov0" title="0">{
                                imageName := fmt.Sprint(service["image"])

                                foundImage := false
                                for _, image := range images </span><span class="cov0" title="0">{
                                        for _, repoTag := range image.RepoTags </span><span class="cov0" title="0">{
                                                if strings.Contains(repoTag, imageName) </span><span class="cov0" title="0">{
                                                        foundImage = true
                                                        break</span>
                                                }
                                        }
                                }

                                <span class="cov0" title="0">if !foundImage </span><span class="cov0" title="0">{
                                        foundAllImages = false
                                        break</span>
                                }

                        }
                }

                <span class="cov0" title="0">hasComposeDir := compose.HasComposeDir(app.AppName, app.Stage)

                correctedAppState := common.UNINSTALLED
                // no images were found (and no container) for this guy, so this guy is REMOVED
                if !hasComposeDir </span><span class="cov0" title="0">{
                        if currentAppState == common.UNINSTALLED </span><span class="cov0" title="0">{
                                correctedAppState = common.UNINSTALLED
                        }</span> else<span class="cov0" title="0"> {
                                correctedAppState = common.REMOVED
                        }</span>
                } else<span class="cov0" title="0"> if foundAllImages </span><span class="cov0" title="0">{
                        // images were found for this guy, but no container, this means --&gt; PRESENT
                        correctedAppState = common.PRESENT
                }</span>

                <span class="cov0" title="0">if currentAppState != correctedAppState </span><span class="cov0" title="0">{
                        if updateRemote </span><span class="cov0" title="0">{
                                // notify the remote database of any changed states due to correction
                                err = so.Notify(app, correctedAppState)
                        }</span> else<span class="cov0" title="0"> {
                                err = so.NotifyLocal(app, correctedAppState)
                        }</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">containerStatuses, err := compose.Status(foundComposeEntry.ConfigFiles)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msgf("Failed to get container status for compose app with config %s", foundComposeEntry.ConfigFiles)
                return err
        }</span>

        <span class="cov0" title="0">latestAppState, err := so.aggregateStatuses(containerStatuses)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">app.StateLock.Lock()
        currentAppState := app.CurrentState
        app.StateLock.Unlock()

        var correctedAppState common.AppState
        switch currentAppState </span>{
        case common.DOWNLOADING,
                common.TRANSFERING,
                common.BUILDING,
                common.PUBLISHING:<span class="cov0" title="0">
                correctedAppState = common.REMOVED</span>
        case common.UPDATING:<span class="cov0" title="0">
                correctedAppState = common.PRESENT</span>
        case common.STOPPING,
                common.STARTING:<span class="cov0" title="0">
                correctedAppState = latestAppState</span>
        default:<span class="cov0" title="0">
                correctedAppState = latestAppState</span>
        }

        <span class="cov0" title="0">if updateRemote </span><span class="cov0" title="0">{
                err = so.Notify(app, correctedAppState)
        }</span> else<span class="cov0" title="0"> {
                err = so.NotifyLocal(app, correctedAppState)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to notify state change")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CorrectAppStates ensures that the app state corresponds with the container status of the app.
// Any transient states will be handled accordingly. After the states have been assured, it will attempt to update the app states remotely if true is passed.
func (so *StateObserver) CorrectAppStates(updateRemote bool) error <span class="cov0" title="0">{

        log.Debug().Msgf("Getting requested states (UpdateRemote: %t)", updateRemote)
        rStates, err := so.AppStore.GetRequestedStates()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">log.Debug().Msg("Got requested states")

        log.Debug().Msg("Get all local images for next step")
        allImages, err := so.Container.GetImages(context.Background(), "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Debug().Msg("Done getting all local images for next step")

        compose := so.Container.Compose()
        composeListEntry, err := compose.List()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for idx, rState := range rStates </span><span class="cov0" title="0">{

                // ComposeApp
                if rState.DockerCompose != nil </span><span class="cov0" title="0">{
                        err = so.CorrectComposeAppState(rState, allImages, composeListEntry, updateRemote)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Throttle remote updates to avoid overwhelming the backend
                        <span class="cov0" title="0">if updateRemote &amp;&amp; idx &lt; len(rStates)-1 </span><span class="cov0" title="0">{
                                time.Sleep(100 * time.Millisecond)
                        }</span>

                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">containerName := common.BuildContainerName(rState.Stage, rState.AppKey, rState.AppName)
                app, err := so.AppStore.GetApp(rState.AppKey, rState.Stage)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">ctx := context.Background()
                container, err := so.Container.GetContainerState(ctx, containerName)
                if err != nil </span><span class="cov0" title="0">{
                        if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Since the error is a container not found error (which is expected), we set the err to nil again
                        <span class="cov0" title="0">err = nil

                        // we should check if the image exists, if it does not, we should set the state to 'REMOVED', else to 'STOPPED'
                        var fullImageName string
                        if rState.Stage == common.DEV </span><span class="cov0" title="0">{
                                fullImageName = rState.RegistryImageName.Dev
                        }</span> else<span class="cov0" title="0"> if rState.Stage == common.PROD </span><span class="cov0" title="0">{
                                fullImageName = rState.RegistryImageName.Prod
                        }</span>

                        <span class="cov0" title="0">foundImage := false
                        for _, image := range allImages </span><span class="cov0" title="0">{
                                if len(image.RepoTags) &gt; 0 &amp;&amp; strings.Contains(image.RepoTags[0], fullImageName) </span><span class="cov0" title="0">{
                                        foundImage = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">app.StateLock.Lock()
                        currentAppState := app.CurrentState
                        var correctedAppState common.AppState
                        // no images were found (and no container) for this guy, so this guy is REMOVED
                        if !foundImage </span><span class="cov0" title="0">{
                                if currentAppState == common.UNINSTALLED </span><span class="cov0" title="0">{
                                        correctedAppState = common.UNINSTALLED
                                }</span> else<span class="cov0" title="0"> {
                                        correctedAppState = common.REMOVED
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // images were found for this guy, but no container, this means --&gt; PRESENT
                                correctedAppState = common.PRESENT
                        }</span>

                        <span class="cov0" title="0">app.StateLock.Unlock()
                        if currentAppState != correctedAppState </span><span class="cov0" title="0">{
                                if updateRemote </span><span class="cov0" title="0">{
                                        // notify the remote database of any changed states due to correction
                                        err = so.Notify(app, correctedAppState)
                                }</span> else<span class="cov0" title="0"> {
                                        err = so.NotifyLocal(app, correctedAppState)
                                }</span>
                        }

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).Msg("failed to notify app state")
                        }</span>

                        // should be all good iterate over next app
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">appStateDeterminedByContainer, err := common.ContainerStateToAppState(container.Status, int(container.ExitCode))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">app.StateLock.Lock()
                currentAppState := app.CurrentState
                app.StateLock.Unlock()

                var correctedAppState common.AppState
                switch currentAppState </span>{
                case common.DOWNLOADING,
                        common.TRANSFERING,
                        common.BUILDING,
                        common.PUBLISHING:<span class="cov0" title="0">
                        correctedAppState = common.REMOVED</span>
                case common.UPDATING:<span class="cov0" title="0">
                        correctedAppState = common.PRESENT</span>
                case common.STOPPING,
                        common.STARTING:<span class="cov0" title="0">
                        correctedAppState = appStateDeterminedByContainer</span>
                default:<span class="cov0" title="0">
                        correctedAppState = appStateDeterminedByContainer</span>
                }

                <span class="cov0" title="0">if updateRemote </span><span class="cov0" title="0">{
                        err = so.Notify(app, correctedAppState)
                }</span> else<span class="cov0" title="0"> {
                        err = so.NotifyLocal(app, correctedAppState)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Error().Stack().Err(err).Msg("Failed to notify state change")
                }</span>

                // Throttle remote updates to avoid overwhelming the backend
                <span class="cov0" title="0">if updateRemote &amp;&amp; idx &lt; len(rStates)-1 </span><span class="cov0" title="0">{
                        time.Sleep(100 * time.Millisecond)
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}

func (so *StateObserver) observeAppState(stage common.Stage, appKey uint64, appName string) chan error <span class="cov0" title="0">{
        errorC := make(chan error, 1)
        pollingRate := time.Second * 1

        safe.Go(func() </span><span class="cov0" title="0">{
                lastKnownStatus := "UKNOWN"

                defer func() </span><span class="cov0" title="0">{
                        so.removeObserver(stage, appKey, appName)
                }</span>()

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        containerName := common.BuildContainerName(stage, appKey, appName)

                        state, err := so.Container.GetContainerState(ctx, containerName)
                        if err != nil </span><span class="cov0" title="0">{
                                if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                                        errorC &lt;- err
                                        return
                                }</span>

                                // if the container doesn't exist anymore, need to make sure app is in the stopped state
                                <span class="cov0" title="0">app, err := so.AppStore.GetApp(appKey, stage)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error().Err(err).Msg("failed to get app")
                                        return
                                }</span>

                                <span class="cov0" title="0">if app == nil </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                // TODO: check if the following makes any sense??
                                // app.StateLock.Lock()
                                // app.CurrentState = common.PRESENT
                                // app.StateLock.Unlock()

                                <span class="cov0" title="0">log.Debug().Msgf("No container was found for %s, removing observer..", containerName)
                                return</span>
                        }

                        // status change detected
                        // always executed the state check on init
                        <span class="cov0" title="0">if lastKnownStatus == state.Status </span><span class="cov0" title="0">{
                                // log.Debug().Msgf("app (%s, %s) container status remains unchanged: %s", stage, appName, lastKnownStatus)
                                time.Sleep(pollingRate)
                                continue</span>
                        }

                        // check if correct and update database if needed
                        <span class="cov0" title="0">latestAppState, err := common.ContainerStateToAppState(state.Status, state.ExitCode)
                        if err != nil </span><span class="cov0" title="0">{
                                errorC &lt;- err

                                log.Error().Err(err).Msg("failed to parse latestAppState")
                                return
                        }</span>

                        <span class="cov0" title="0">app, err := so.AppStore.GetApp(appKey, stage)
                        if err != nil </span><span class="cov0" title="0">{
                                errorC &lt;- err
                                log.Error().Err(err).Msg("failed to get app")

                                return
                        }</span>

                        <span class="cov0" title="0">if app == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">app.StateLock.Lock()
                        curAppState := app.CurrentState
                        app.StateLock.Unlock()

                        alreadyTransitioning := app.SecureTransition()
                        if alreadyTransitioning </span><span class="cov0" title="0">{
                                log.Debug().Msg("State observer: app is already transitioning, waiting for transition to finish...")
                                time.Sleep(pollingRate)
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                app.UnlockTransition()
                        }</span>

                        <span class="cov0" title="0">if curAppState != latestAppState &amp;&amp; !common.IsTransientState(curAppState) &amp;&amp; !common.IsTransientState(latestAppState) </span><span class="cov0" title="0">{
                                log.Debug().Msgf("app (%s, %s) state is not up to date", appName, stage)
                                log.Debug().Msgf("app (%s, %s) updating from %s to %s", appName, stage, curAppState, latestAppState)

                                // update the current local and remote app state
                                err = so.Notify(app, latestAppState)
                                if err != nil </span><span class="cov0" title="0">{
                                        errorC &lt;- err
                                        log.Error().Err(err).Msg("failed to notify state")
                                        return
                                }</span>

                                <span class="cov0" title="0">if latestAppState == common.FAILED &amp;&amp; (stage == common.DEV || stage == common.PROD) </span><span class="cov0" title="0">{
                                        err = so.LogManager.Write(containerName, fmt.Sprintf("%s (%s) exited with status code: %d", appName, stage, state.ExitCode))
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error().Err(err).Msgf("failed to publish exit message to container %s", containerName)
                                        }</span>
                                }

                                <span class="cov0" title="0">if stage == common.PROD </span><span class="cov0" title="0">{
                                        // try to transition to the state it's supposed to be at
                                        payload, err := so.AppStore.GetRequestedState(app.AppKey, app.Stage)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>

                                        <span class="cov0" title="0">if latestAppState == common.FAILED </span><span class="cov0" title="0">{
                                                retries, sleepTime := so.AppManager.incrementCrashLoop(payload)
                                                err = so.LogManager.Write(containerName, fmt.Sprintf("Entered a crashloop (%s attempt), retrying in %s", common.Ordinal(retries), sleepTime))
                                                if err != nil </span><span class="cov0" title="0">{
                                                        log.Error().Err(err).Msgf("failed to publish retry message to container %s", containerName)
                                                }</span>

                                                <span class="cov0" title="0">return</span>
                                        } else<span class="cov0" title="0"> {
                                                so.AppManager.RequestAppState(payload)
                                        }</span>
                                }
                        }

                        // update the last recorded status
                        <span class="cov0" title="0">lastKnownStatus = state.Status

                        time.Sleep(pollingRate)</span>
                }
        })

        <span class="cov0" title="0">return errorC</span>
}

func (so *StateObserver) aggregateStatuses(containerStatuses []container.ComposeStatus) (common.AppState, error) <span class="cov0" title="0">{
        notRunningContainers := make([]string, 0)
        for _, status := range containerStatuses </span><span class="cov0" title="0">{
                // If one container is running, we say that it is running
                if status.State == "running" </span><span class="cov0" title="0">{
                        return common.RUNNING, nil
                }</span> else<span class="cov0" title="0"> {
                        notRunningContainers = append(notRunningContainers, status.Name)
                }</span>
        }

        <span class="cov0" title="0">aggregatedState := common.PRESENT
        for _, notRunningContainer := range notRunningContainers </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), time.Second*30)
                state, err := so.Container.GetContainerState(ctx, notRunningContainer)
                if err != nil </span><span class="cov0" title="0">{
                        cancel()
                        return "", err
                }</span>

                <span class="cov0" title="0">cancel()

                if state.Status == "exited" &amp;&amp; state.ExitCode &gt; 0 </span><span class="cov0" title="0">{
                        aggregatedState = common.FAILED
                }</span>
        }

        <span class="cov0" title="0">return aggregatedState, nil</span>
}

func (so *StateObserver) observeComposeAppState(stage common.Stage, appKey uint64, appName string) chan error <span class="cov0" title="0">{
        errorC := make(chan error, 1)
        pollingRate := time.Second * 1

        safe.Go(func() </span><span class="cov0" title="0">{
                var lastKnownStatus common.AppState

                defer func() </span><span class="cov0" title="0">{
                        so.removeComposeObserver(stage, appKey, appName)
                }</span>()

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        composeAppName := common.BuildComposeContainerName(stage, appKey, appName)
                        compose := so.Container.Compose()
                        composeEntryList, err := compose.List()
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">var foundComposeEntry *container.ComposeListEntry
                        for _, composeEntry := range composeEntryList </span><span class="cov0" title="0">{
                                if composeEntry.Name == composeAppName </span><span class="cov0" title="0">{
                                        foundComposeEntry = &amp;composeEntry
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if foundComposeEntry == nil </span><span class="cov0" title="0">{
                                app, err := so.AppStore.GetApp(appKey, stage)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error().Err(err).Msg("failed to get app")
                                        return
                                }</span>

                                <span class="cov0" title="0">if app == nil </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                // TODO: check if this actually makes sense, what if it's being deleted?
                                // app.StateLock.Lock()
                                // app.CurrentState = common.PRESENT
                                // app.StateLock.Unlock()

                                // log.Debug().Msgf("No container was found for compose app %s, removing observer..", composeAppName)
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">containerStatuses, err := compose.Status(foundComposeEntry.ConfigFiles)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).Msgf("Failed to get container status for compose app with config %s", foundComposeEntry.ConfigFiles)
                                continue</span>
                        }

                        <span class="cov0" title="0">latestAppState, err := so.aggregateStatuses(containerStatuses)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">app, err := so.AppStore.GetApp(appKey, stage)
                        if err != nil </span><span class="cov0" title="0">{
                                errorC &lt;- err
                                log.Error().Err(err).Msg("failed to get app")

                                return
                        }</span>

                        <span class="cov0" title="0">if app == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">app.StateLock.Lock()
                        curAppState := app.CurrentState
                        app.StateLock.Unlock()

                        alreadyTransitioning := app.SecureTransition()
                        if alreadyTransitioning </span><span class="cov0" title="0">{
                                log.Debug().Msg("State observer: compose app is already transitioning, waiting for transition to finish...")
                                time.Sleep(pollingRate)
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                app.UnlockTransition()
                        }</span>

                        // status change detected
                        // always executed the state check on init
                        <span class="cov0" title="0">if lastKnownStatus == latestAppState &amp;&amp; latestAppState == curAppState </span><span class="cov0" title="0">{
                                // log.Debug().Msgf("app (%s, %s) container status remains unchanged: %s", stage, appName, lastKnownStatus)
                                time.Sleep(pollingRate)
                                continue</span>
                        }

                        <span class="cov0" title="0">if curAppState != latestAppState &amp;&amp; !common.IsTransientState(curAppState) </span><span class="cov0" title="0">{
                                log.Debug().Msgf("app (%s, %s) state is not up to date", appName, stage)
                                log.Debug().Msgf("app (%s, %s) updating from %s to %s", appName, stage, curAppState, latestAppState)

                                // update the current local and remote app state
                                err = so.Notify(app, latestAppState)
                                if err != nil </span><span class="cov0" title="0">{
                                        errorC &lt;- err
                                        log.Error().Err(err).Msg("failed to notify state")
                                        return
                                }</span>

                                <span class="cov0" title="0">containerTopic := common.BuildContainerName(stage, appKey, appName)

                                if stage == common.PROD </span><span class="cov0" title="0">{
                                        // try to transition to the state it's supposed to be at
                                        payload, err := so.AppStore.GetRequestedState(app.AppKey, app.Stage)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>

                                        <span class="cov0" title="0">if latestAppState == common.FAILED </span><span class="cov0" title="0">{
                                                retries, sleepTime := so.AppManager.incrementCrashLoop(payload)
                                                err = so.LogManager.Write(containerTopic, fmt.Sprintf("Entered a crashloop (%s attempt), retrying in %s", common.Ordinal(retries), sleepTime))
                                                if err != nil </span><span class="cov0" title="0">{
                                                        log.Error().Err(err).Msgf("failed to publish retry message to container %s", containerTopic)
                                                }</span>

                                                <span class="cov0" title="0">return</span>
                                        } else<span class="cov0" title="0"> {
                                                so.AppManager.RequestAppState(payload)
                                        }</span>
                                }
                        }

                        // update the last recorded status
                        <span class="cov0" title="0">lastKnownStatus = latestAppState

                        time.Sleep(pollingRate)</span>
                }
        })

        <span class="cov0" title="0">return errorC</span>
}

var ContainerNameRegexExp = regexp.MustCompile(`(.{3,4})_([0-9]*)_.*`)
var ComposeContainerNameRegexExp = regexp.MustCompile(`(dev|prod)_(\d+)_([a-zA-Z0-9]+)_compose-([a-zA-Z0-9]+)-(\d+)`)

func (so *StateObserver) initObserverSpawner() chan error <span class="cov0" title="0">{
        messageC, errC := so.Container.ListenForContainerEvents(context.Background())

        errChan := make(chan error, 1)

        safe.Go(func() </span><span class="cov0" title="0">{
        loop:
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case event := &lt;-messageC:<span class="cov0" title="0">
                                switch event.Action </span>{
                                case "die", "kill", "destroy":<span class="cov0" title="0">
                                        containerName := event.Actor.Attributes["name"]
                                        match := ContainerNameRegexExp.FindStringSubmatch(containerName)
                                        matchCompose := ComposeContainerNameRegexExp.FindStringSubmatch(containerName)

                                        if len(matchCompose) != 0 </span><span class="cov0" title="0">{

                                                // Compose container looks as follows:
                                                // dev_1336_markopetzoldomaewamoushindeiru_compose-web-1
                                                // dev_1336_markopetzoldomaewamoushindeiru_compose-db-1
                                                // We only need the first part to identify the compose
                                                composeContainerName := strings.Split(containerName, "-")[0]
                                                stage, key, name, err := common.ParseComposeContainerName(composeContainerName)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }

                                                <span class="cov0" title="0">so.removeComposeObserver(stage, key, name)

                                                continue</span>
                                        }

                                        <span class="cov0" title="0">if len(match) != 0 </span><span class="cov0" title="0">{
                                                stage, key, name, err := common.ParseContainerName(containerName)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }

                                                <span class="cov0" title="0">so.removeObserver(stage, key, name)</span>
                                        }

                                case "create", "start":<span class="cov0" title="0">
                                        containerName := event.Actor.Attributes["name"]
                                        match := ContainerNameRegexExp.FindStringSubmatch(containerName)
                                        matchCompose := ComposeContainerNameRegexExp.FindStringSubmatch(containerName)

                                        if len(matchCompose) != 0 </span><span class="cov0" title="0">{
                                                composeContainerName := strings.Split(containerName, "-")[0]
                                                stage, key, name, err := common.ParseComposeContainerName(composeContainerName)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }

                                                <span class="cov0" title="0">so.addComposeObserver(stage, key, name)

                                                continue</span>
                                        }

                                        <span class="cov0" title="0">if len(match) != 0 </span><span class="cov0" title="0">{
                                                stage, key, name, err := common.ParseContainerName(containerName)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">so.addObserver(stage, key, name)</span>
                                        }

                                }
                        case err := &lt;-errC:<span class="cov0" title="0">
                                errChan &lt;- err
                                log.Error().Err(err).Msg("Error during observer spawner")
                                close(errChan)

                                so.spawnerActive = false
                                break loop</span>
                        }
                }
        })

        <span class="cov0" title="0">so.spawnerActive = true
        return errChan</span>
}

func (so *StateObserver) ObserveAppStates() error <span class="cov0" title="0">{
        // all the apps currently available
        apps, err := so.AppStore.GetAllApps()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compose := so.Container.Compose()
        composeListEntry, err := compose.List()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, app := range apps </span><span class="cov0" title="0">{
                // Only create observers for apps that should have containers running
                // Skip apps in REMOVED, UNINSTALLED, FAILED, BUILT, PUBLISHED states
                app.StateLock.Lock()
                currentState := app.CurrentState
                app.StateLock.Unlock()

                if currentState == common.REMOVED ||
                        currentState == common.UNINSTALLED ||
                        currentState == common.FAILED ||
                        currentState == common.BUILT ||
                        currentState == common.PUBLISHED </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">createdObserver := so.addObserver(app.Stage, app.AppKey, app.AppName)

                if !createdObserver </span><span class="cov0" title="0">{
                        var composeApp *container.ComposeListEntry
                        composeAppName := common.BuildComposeContainerName(app.Stage, app.AppKey, app.AppName)
                        for _, composeEntry := range composeListEntry </span><span class="cov0" title="0">{
                                if composeEntry.Name == composeAppName </span><span class="cov0" title="0">{
                                        composeApp = &amp;composeEntry
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if composeApp != nil </span><span class="cov0" title="0">{
                                so.addComposeObserver(app.Stage, app.AppKey, app.AppName)
                        }</span>
                }

        }

        <span class="cov0" title="0">if !so.spawnerActive </span><span class="cov0" title="0">{
                so.initObserverSpawner()
        }</span>

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package apps

import "reagent/common"

func (sm *StateMachine) stopAndBuildApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        err := sm.stopDevApp(payload, app)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.buildDevApp(payload, app, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package apps

import "reagent/common"

func (sm *StateMachine) removeAndPublishApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                err := sm.removeDevApp(payload, app)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = sm.publishApp(payload, app)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package apps

import (
        "context"
        "fmt"
        "reagent/common"
        "reagent/errdefs"
        "time"

        "github.com/docker/docker/api/types/container"
        "github.com/pkg/errors"
)

func (sm *StateMachine) stopApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                return sm.stopDevApp(payload, app)
        }</span> else<span class="cov0" title="0"> if payload.Stage == common.PROD </span><span class="cov0" title="0">{
                return sm.stopProdApp(payload, app)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (sm *StateMachine) stopProdApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.DockerCompose != nil </span><span class="cov0" title="0">{
                return sm.stopProdComposeApp(payload, app)
        }</span>

        <span class="cov0" title="0">err := sm.setState(app, common.STOPPING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">getContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()
        // for now to resolve the issue regarding env variables, we should remove the container on stop
        cont, err := sm.Container.GetContainer(getContainerContext, payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to getContainer during stopDevApp")
                }</span>
        }

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Prod, fmt.Sprintf("Received stop signal for %s", payload.AppName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.STOPPING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">stopContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()
        err = sm.Container.StopContainerByID(stopContainerContext, cont.ID, time.Second*1)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to stop container by ID during stopProdApp")
        }</span>

        <span class="cov0" title="0">waitForContainerByIDContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()
        _, err = sm.Container.WaitForContainerByID(waitForContainerByIDContext, cont.ID, container.WaitConditionNotRunning)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">removeContainerByIDContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()
        err = sm.Container.RemoveContainerByID(removeContainerByIDContext, cont.ID, map[string]interface{}{"force": true})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pollContainerStateContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()
        // should return 'container not found' error, this way we know it's removed successfully
        _, errC := sm.Container.PollContainerState(pollContainerStateContext, cont.ID, time.Second)
        err = &lt;-errC
        if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.PRESENT)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sm.LogManager.Write(payload.ContainerName.Prod, fmt.Sprintf("Successfully stopped %s", payload.AppName))</span>
}

func (sm *StateMachine) stopDevComposeApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        dockerComposePath, err := sm.SetupComposeFiles(payload, app, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("Received stop signal for %s", payload.AppName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.STOPPING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compose := sm.Container.Compose()

        _, cmd, err := compose.Stop(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, cmd, err = compose.Remove(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.PRESENT)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("Successfully stopped %s", payload.AppName))</span>
}

func (sm *StateMachine) stopProdComposeApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        dockerComposePath, err := sm.SetupComposeFiles(payload, app, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Prod, fmt.Sprintf("Received stop signal for %s", payload.AppName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.STOPPING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compose := sm.Container.Compose()

        _, cmd, err := compose.Stop(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, cmd, err = compose.Remove(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.PRESENT)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sm.LogManager.Write(payload.ContainerName.Prod, fmt.Sprintf("Successfully stopped %s", payload.AppName))</span>
}

func (sm *StateMachine) stopDevApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.DockerCompose != nil </span><span class="cov0" title="0">{
                return sm.stopDevComposeApp(payload, app)
        }</span>

        <span class="cov0" title="0">getContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        cont, err := sm.Container.GetContainer(getContainerContext, payload.ContainerName.Dev)
        if err != nil </span><span class="cov0" title="0">{
                if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to getContainer during stopDevApp")
                }</span>
        }

        <span class="cov0" title="0">err = sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("Received stop signal for %s", payload.AppName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.STOPPING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">stopContainerByIDrContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        err = sm.Container.StopContainerByID(stopContainerByIDrContext, cont.ID, time.Second*1)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to stop container by ID during stopDevApp")
        }</span>

        <span class="cov0" title="0">waitForContainerByIDContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()
        _, err = sm.Container.WaitForContainerByID(waitForContainerByIDContext, cont.ID, container.WaitConditionNotRunning)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">removeContainerByIDContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()
        err = sm.Container.RemoveContainerByID(removeContainerByIDContext, cont.ID, map[string]interface{}{"force": true})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // should return 'container not found' error, this way we know it's removed successfully
        <span class="cov0" title="0">pollContainerStateContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        _, errC := sm.Container.PollContainerState(pollContainerStateContext, cont.ID, time.Second)
        err = &lt;-errC
        if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.PRESENT)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sm.LogManager.Write(payload.ContainerName.Dev, fmt.Sprintf("Successfully stopped %s", payload.AppName))</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package apps

import (
        "fmt"
        "os"
        "reagent/common"
        "strings"

        "github.com/rs/zerolog/log"
)

func (sm *StateMachine) uninstallApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        err := sm.removeApp(payload, app)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.setState(app, common.UNINSTALLED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">config := sm.Container.GetConfig()

        appsDir := config.CommandLineArguments.AppsDirectory
        dataFolderDir := fmt.Sprintf("%s/%s/%s", appsDir, strings.ToLower(string(payload.Stage)), payload.AppName)
        err = os.RemoveAll(dataFolderDir) // remove the data directory for the app we just removed
        log.Debug().Msgf("Removed data dir: %s, error: %v", dataFolderDir, err)

        if payload.Stage == common.DEV &amp;&amp; payload.DockerCompose == nil </span><span class="cov0" title="0">{
                buildDir := config.CommandLineArguments.AppsBuildDir
                fileName := payload.AppName + "." + config.CommandLineArguments.CompressedBuildExtension
                buildZipFile := buildDir + "/" + fileName
                err = os.RemoveAll(buildZipFile) // removes the build zip if it exists
                log.Debug().Msgf("Removed build zip file: %s, error: %v", buildZipFile, err)
        }</span>

        <span class="cov0" title="0">if payload.DockerCompose != nil </span><span class="cov0" title="0">{
                appDir := config.CommandLineArguments.AppsComposeDir + "/" + payload.AppName
                if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                        appDir = config.CommandLineArguments.AppsBuildDir + "/" + payload.AppName
                }</span>

                <span class="cov0" title="0">_, err := os.Stat(appDir)
                if err == nil </span><span class="cov0" title="0">{
                        err = os.RemoveAll(appDir)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package apps

import (
        "context"
        "fmt"
        "reagent/common"
        "reagent/container"
        "reagent/errdefs"
        "time"

        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

func (sm *StateMachine) getUpdateTransition(payload common.TransitionPayload, app *common.App) TransitionFunc <span class="cov0" title="0">{
        return sm.updateApp
}</span>

func (sm *StateMachine) updateApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.DockerCompose != nil </span><span class="cov0" title="0">{
                return sm.updateComposeApp(payload, app)
        }</span>

        <span class="cov0" title="0">if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                return errors.New("cannot update dev app")
        }</span>

        <span class="cov0" title="0">if payload.NewestVersion == app.Version </span><span class="cov0" title="0">{
                return errors.New("the app is already equal to the newest version")
        }</span>

        <span class="cov0" title="0">err := sm.setState(app, common.UPDATING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">getContainerContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        cont, err := sm.Container.GetContainer(getContainerContext, payload.ContainerName.Prod)
        if err == nil </span><span class="cov0" title="0">{

                removeContainerByIdContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()
                err = sm.Container.RemoveContainerByID(removeContainerByIdContext, cont.ID, map[string]interface{}{"force": true})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">pollContainerStateContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
                defer cancel()

                // should return 'container not found' error, this way we know it's removed successfully
                _, errC := sm.Container.PollContainerState(pollContainerStateContext, cont.ID, time.Second)
                err := &lt;-errC
                if !errdefs.IsContainerNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">config := sm.Container.GetConfig()
        initMessage := fmt.Sprintf("Initialising download for the app: %s...", payload.AppName)
        err = sm.LogManager.Write(payload.ContainerName.Prod, initMessage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.LogManager.ClearLogHistory(payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Need to authenticate to private registry to determine proper privileges to pull the app
        <span class="cov0" title="0">err = sm.HandleRegistryLoginsWithDefault(payload)
        if err != nil </span><span class="cov0" title="0">{
                writeErr := sm.LogManager.Write(payload.ContainerName.Prod, err.Error())
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">authConfig := container.AuthConfig{
                Username: payload.RegisteryToken,
                Password: config.ReswarmConfig.Secret,
        }

        fullImageNameWithVersion := fmt.Sprintf("%s:%s", payload.RegistryImageName.Prod, payload.NewestVersion)
        pullOptions := container.PullOptions{
                AuthConfig: authConfig,
                PullID:     common.BuildDockerPullID(payload.AppKey, payload.AppName),
        }

        log.Debug().Msgf("PULLING IMAGE: %s", fullImageNameWithVersion)
        reader, err := sm.Container.Pull(context.Background(), fullImageNameWithVersion, pullOptions)
        if err != nil </span><span class="cov0" title="0">{
                errorMessage := fmt.Sprintf("Error occured while trying to pull the image: %s", err.Error())
                sm.LogManager.Write(payload.ContainerName.Prod, errorMessage)
                return err
        }</span>

        <span class="cov0" title="0">streamErr := sm.LogManager.StreamBlocking(payload.ContainerName.Prod, common.PULL, reader)
        if streamErr != nil </span><span class="cov0" title="0">{
                if errdefs.IsDockerStreamCanceled(streamErr) </span><span class="cov0" title="0">{
                        pullMessage := "The update was canceled"
                        writeErr := sm.LogManager.Write(payload.ContainerName.Prod, pullMessage)
                        if writeErr != nil </span><span class="cov0" title="0">{
                                return writeErr
                        }</span>
                        // this error will not cause a failed state and is handled upstream
                        <span class="cov0" title="0">return streamErr</span>
                }

                <span class="cov0" title="0">return streamErr</span>
        }

        <span class="cov0" title="0">pullMessage := fmt.Sprintf("Succesfully installed the app: %s (Version: %s)", payload.AppName, payload.NewestVersion)
        writeErr := sm.LogManager.Write(payload.ContainerName.Prod, pullMessage)
        if writeErr != nil </span><span class="cov0" title="0">{
                return writeErr
        }</span>

        <span class="cov0" title="0">app.StateLock.Lock()
        app.Version = payload.NewestVersion
        app.ReleaseKey = payload.NewReleaseKey
        app.UpdateStatus = common.PENDING_REMOTE_CONFIRMATION // set flag to make backend aware we updated
        app.StateLock.Unlock()

        // also tell the database that we successfully updated (with the updated flag)
        err = sm.setState(app, common.PRESENT)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">removeImageByNameContext, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        log.Debug().Msgf("Removing Old Image %s:%s", payload.RegistryImageName.Prod, payload.PresentVersion)
        sm.Container.RemoveImageByName(removeImageByNameContext, payload.RegistryImageName.Prod, payload.PresentVersion, map[string]interface{}{"force": true})

        // update the version of the local requested states
        payload.NewestVersion = app.Version
        payload.PresentVersion = app.Version
        payload.Version = app.Version

        // The state validation will ensure it will reach it's requestedState again
        return sm.StateObserver.AppStore.UpdateLocalRequestedState(payload)</span>
}

func (sm *StateMachine) updateComposeApp(payload common.TransitionPayload, app *common.App) error <span class="cov0" title="0">{
        if payload.Stage == common.DEV </span><span class="cov0" title="0">{
                return errors.New("cannot update dev app")
        }</span>

        <span class="cov0" title="0">if payload.NewestVersion == app.Version </span><span class="cov0" title="0">{
                return errors.New("the app is already equal to the newest version")
        }</span>

        <span class="cov0" title="0">err := sm.setState(app, common.UPDATING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compose := sm.Container.Compose()
        if !compose.Supported </span><span class="cov0" title="0">{
                message := "Docker Compose is not supported for this device"
                writeErr := sm.LogManager.Write(payload.ContainerName.Prod, message)
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>

                <span class="cov0" title="0">return errdefs.DockerComposeNotSupported(errors.New("docker compose is not supported"))</span>
        }

        <span class="cov0" title="0">dockerComposePath, err := sm.SetupComposeFiles(payload, app, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, cmd, err := compose.Stop(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, cmd, err = compose.Remove(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">initMessage := fmt.Sprintf("Initialising download for the app: %s...", payload.AppName)
        err = sm.LogManager.Write(payload.ContainerName.Prod, initMessage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sm.HandleRegistryLoginsWithDefault(payload)
        if err != nil </span><span class="cov0" title="0">{
                writeErr := sm.LogManager.Write(payload.ContainerName.Prod, err.Error())
                if writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">err = sm.LogManager.ClearLogHistory(payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pullOutput, pullCmd, err := compose.Pull(dockerComposePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = sm.LogManager.StreamLogsChannel(pullOutput, payload.ContainerName.Prod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = pullCmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pullMessage := fmt.Sprintf("Succesfully installed the app: %s (Version: %s)", payload.AppName, payload.NewestVersion)
        writeErr := sm.LogManager.Write(payload.ContainerName.Prod, pullMessage)
        if writeErr != nil </span><span class="cov0" title="0">{
                return writeErr
        }</span>

        <span class="cov0" title="0">app.StateLock.Lock()
        app.Version = payload.NewestVersion
        app.ReleaseKey = payload.NewReleaseKey
        app.UpdateStatus = common.PENDING_REMOTE_CONFIRMATION // set flag to make backend aware we updated
        app.StateLock.Unlock()

        // also tell the database that we successfully updated (with the updated flag)
        err = sm.setState(app, common.PRESENT)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO: remove old images from docker-compose

        // update the version of the local requested states
        <span class="cov0" title="0">payload.DockerCompose = payload.NewDockerCompose
        payload.NewestVersion = app.Version
        payload.PresentVersion = app.Version
        payload.Version = app.Version

        // The state validation will ensure it will reach it's requestedState again
        return sm.StateObserver.AppStore.UpdateLocalRequestedState(payload)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package common

import (
        "errors"
)

// AppState states
type AppState string
type Stage string
type UpdateStatus string
type Environment string

func IsCancelableState(appState AppState) bool <span class="cov0" title="0">{
        switch appState </span>{
        case BUILDING, PUBLISHING, DOWNLOADING, TRANSFERING, UPDATING:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

type LogType string

const (
        PULL  LogType = "PULL"
        PUSH  LogType = "PUSH"
        BUILD LogType = "BUILD"
        APP   LogType = "APP"
)

func GetCurrentLogType(currentState AppState) LogType <span class="cov0" title="0">{
        var logType LogType
        if currentState == DOWNLOADING || currentState == UPDATING </span><span class="cov0" title="0">{
                logType = PULL
        }</span> else<span class="cov0" title="0"> if currentState == PUBLISHING </span><span class="cov0" title="0">{
                logType = PUSH
        }</span> else<span class="cov0" title="0"> if currentState == BUILDING </span><span class="cov0" title="0">{
                logType = BUILD
        }</span> else<span class="cov0" title="0"> {
                logType = APP
        }</span>
        <span class="cov0" title="0">return logType</span>
}

func TransientToActualState(appState AppState) AppState <span class="cov0" title="0">{
        switch appState </span>{
        case BUILDING,
                TRANSFERED,
                DOWNLOADING,
                TRANSFERING,
                PUBLISHING,
                UPDATING,
                STOPPING:<span class="cov0" title="0">
                return PRESENT</span>
        case DELETING:<span class="cov0" title="0">
                return REMOVED</span>
        case STARTING:<span class="cov0" title="0">
                return RUNNING</span>
        }

        <span class="cov0" title="0">return appState</span>
}

func IsTransientState(appState AppState) bool <span class="cov0" title="0">{
        switch appState </span>{
        case BUILDING,
                BUILT,
                TRANSFERED,
                DELETING,
                TRANSFERING,
                PUBLISHING,
                PUBLISHED,
                DOWNLOADING,
                STOPPING,
                UPDATING,
                STARTING:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func ContainerStateToAppState(containerState string, exitCode int) (AppState, error) <span class="cov0" title="0">{
        unknownStateErr := errors.New("unkown state")

        switch containerState </span>{
        case "running":<span class="cov0" title="0">
                return RUNNING, nil</span>
        case "created":<span class="cov0" title="0">
                return PRESENT, nil</span>
        case "removing":<span class="cov0" title="0">
                return STOPPING, nil</span>
        case "paused":<span class="cov0" title="0"> // won't occur (as of writing)
                return "", unknownStateErr</span>
        case "restarting":<span class="cov0" title="0">
                return FAILED, nil</span>
        case "exited":<span class="cov0" title="0">
                // 137 = SIGKILL received
                // 0 = Normal exit without error
                // if exitCode == 0 || exitCode == 137 {
                //         return PRESENT, nil
                // }

                // for now it's more clear to the user, that their container exited if we set it to failed
                return FAILED, nil</span>
        case "dead":<span class="cov0" title="0">
                return FAILED, nil</span>
        }

        <span class="cov0" title="0">return "", unknownStateErr</span>
}

const (
        PRESENT     AppState = "PRESENT"
        REMOVED     AppState = "REMOVED"
        UNINSTALLED AppState = "UNINSTALLED"
        FAILED      AppState = "FAILED"
        BUILT       AppState = "BUILT"
        BUILDING    AppState = "BUILDING"
        TRANSFERED  AppState = "TRANSFERED"
        TRANSFERING AppState = "TRANSFERING"
        PUBLISHING  AppState = "PUBLISHING"
        PUBLISHED   AppState = "PUBLISHED"
        DOWNLOADING AppState = "DOWNLOADING"
        STARTING    AppState = "STARTING"
        STOPPING    AppState = "STOPPING"
        STOPPED     AppState = "STOPPED"
        UPDATING    AppState = "UPDATING"
        DELETING    AppState = "DELETING"
        RUNNING     AppState = "RUNNING"
)

const (
        PRODUCTION Environment = "production"
        TEST       Environment = "test"
        LOCAL      Environment = "local"
)

const (
        COMPLETED                   UpdateStatus = "completed"
        CANCELED                    UpdateStatus = "canceled"
        PENDING_REMOTE_CONFIRMATION UpdateStatus = "pending_remote_confirmation"
)

const (
        DEV  Stage = "DEV"
        PROD Stage = "PROD"
)
</pre>
		
		<pre class="file" id="file40" style="display: none">package common

import (
        "errors"
        "reagent/config"
        "sync"

        "github.com/rs/zerolog/log"
        "golang.org/x/sync/semaphore"
)

type Dict map[string]interface{}
type Timestamp string

// Result is the value received from a Messenger request (Call, Register callback, Subscription callback)
type Result struct {
        Arguments    []interface{}
        ArgumentsKw  Dict
        Details      Dict
        Registration uint64 // Values will be filled based on Result type
        Request      uint64
        Subscription uint64
        Publication  uint64
}

// InvokeResult is the value sent whenever a procedure is invoked
type InvokeResult struct {
        Arguments   []interface{}
        ArgumentsKw Dict
        Err         string
}

type App struct {
        AppKey              uint64
        DeviceToAppKey      uint64
        RequestorAccountKey uint64
        ReleaseKey          uint64
        AppName             string
        RequestedState      AppState
        CurrentState        AppState
        UpdateStatus        UpdateStatus
        Stage               Stage
        RequestUpdate       bool
        ReleaseBuild        bool
        Version             string
        LastUpdated         Timestamp
        TransitionLock      *semaphore.Weighted
        StateLock           sync.Mutex
}

func (app *App) SecureTransition() bool <span class="cov0" title="0">{
        if app.TransitionLock == nil </span><span class="cov0" title="0">{
                log.Error().Err(errors.New("no semaphore initialized"))
                return false
        }</span>
        <span class="cov0" title="0">return !app.TransitionLock.TryAcquire(1)</span>
}

func (app *App) UnlockTransition() <span class="cov0" title="0">{
        app.TransitionLock.Release(1)
}</span>

func (app *App) IsCancelable() bool <span class="cov0" title="0">{
        app.StateLock.Lock()
        currAppState := app.CurrentState
        app.StateLock.Unlock()

        return IsCancelableState(currAppState)
}</span>

type StageBasedResult struct {
        Dev  string
        Prod string
}

type DockerCredential struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

type PortForwardRule struct {
        Main                  bool   `json:"main"`
        RuleName              string `json:"name"`
        Active                bool   `json:"active"`
        Public                bool   `json:"public"`
        Port                  uint64 `json:"port"`
        Protocol              string `json:"protocol"`
        LocalIP               string `json:"local_ip"`
        RemotePortEnvironment string `json:"remote_port_environment"`
        RemotePort            uint64 `json:"remote_port"`
}

// TransitionPayload provides the data used by the StateMachine to transition between states.
type TransitionPayload struct {
        RequestedState       AppState
        CurrentState         AppState
        Stage                Stage
        RequestorAccountKey  uint64
        DeviceToAppKey       uint64
        AppKey               uint64
        CallerAuthID         int
        AppName              string
        ImageName            StageBasedResult
        PresentImageName     string
        RegistryImageName    StageBasedResult
        ContainerName        StageBasedResult
        DockerCredentials    map[string]DockerCredential
        EnvironmentVariables map[string]any
        EnvironmentTemplate  map[string]any
        DockerCompose        map[string]any
        NewDockerCompose     map[string]any
        Ports                []any
        PublishContainerName string
        RegisteryToken       string
        NewestVersion        string
        PresentVersion       string
        ReleaseKey           uint64
        NewReleaseKey        uint64
        Version              string
        RequestUpdate        bool
        Retrying             bool
        CancelTransition     bool
}

func BuildTransitionPayload(appKey uint64, appName string, requestorAccountKey uint64,
        stage Stage, currentState AppState, requestedState AppState, releaseKey uint64, newReleaseKey uint64,
        config *config.Config,
) TransitionPayload <span class="cov0" title="0">{

        payload := TransitionPayload{
                Stage:               stage,
                RequestedState:      requestedState,
                AppName:             appName,
                AppKey:              appKey,
                CurrentState:        currentState,
                ReleaseKey:          releaseKey,
                NewReleaseKey:       newReleaseKey,
                RequestorAccountKey: requestorAccountKey,
        }

        payload.initContainerData(appKey, appName, config)

        return payload
}</span>

type DeviceSyncResponse struct {
        DeviceKey              int                    `json:"device_key"`
        SwarmKey               int                    `json:"swarm_key"`
        AccountKey             int                    `json:"account_key"`
        SerialNumber           string                 `json:"serial_number"`
        AppName                string                 `json:"app_name"`
        Name                   string                 `json:"name"` // device name
        Status                 string                 `json:"status"`
        Architecture           string                 `json:"architecture"`
        Address                string                 `json:"address"`
        ReleaseKey             int                    `json:"release_key"`
        NewReleaseKey          int                    `json:"new_release_key"`
        DeviceToAppKey         int                    `json:"device_to_app_key"`
        Environment            map[string]interface{} `json:"environment"`
        EnvironmentTemplate    map[string]interface{} `json:"environment_template"`
        DockerCompose          map[string]interface{} `json:"docker_compose"`
        NewDockerCompose       map[string]interface{} `json:"new_docker_compose"`
        Ports                  []interface{}          `json:"ports"`
        CurrentState           string                 `json:"current_state"`
        Stage                  string                 `json:"stage"`
        ContainerName          string                 `json:"container_name"`
        RequestUpdate          bool                   `json:"request_update"`
        TargetState            string                 `json:"target_state"`
        ManuallyRequestedState string                 `json:"manually_requested_state"`
        InheritFromGroup       interface{}            `json:"inherit_from_group"`
        RequestorAccountKey    int                    `json:"requestor_account_key"`
        PresentVersion         string                 `json:"present_version"`
        PresentImageName       string                 `json:"present_image_name"`
        NewImageName           string                 `json:"new_image_name"`
        NewestVersion          string                 `json:"newest_version"`
        Description            string                 `json:"description"`
        AppKey                 uint64                 `json:"app_key"`
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package common

import (
        "encoding/json"
        "errors"
        "fmt"
        "net"
        "os"
        "reagent/config"
        "reagent/messenger/topics"
        "reagent/release"
        "regexp"
        "strconv"
        "strings"
        "unicode/utf8"

        "github.com/rs/zerolog/log"
        "github.com/shirou/gopsutil/v4/cpu"
        "github.com/shirou/gopsutil/v4/disk"
        "github.com/shirou/gopsutil/v4/mem"
)

func BuildContainerName(stage Stage, appKey uint64, appName string) string <span class="cov0" title="0">{
        return strings.ToLower(fmt.Sprintf("%s_%d_%s", stage, appKey, appName))
}</span>

func BuildComposeContainerName(stage Stage, appKey uint64, appName string) string <span class="cov0" title="0">{
        return strings.ToLower(fmt.Sprintf("%s_%d_%s_compose", stage, appKey, appName))
}</span>

func BuildImageName(stage Stage, arch string, appKey uint64, appName string) string <span class="cov0" title="0">{
        return strings.ToLower(fmt.Sprintf("%s_%s_%d_%s", stage, arch, appKey, appName))
}</span>

func BuildRegistryImageName(registryURL string, mainRepositoryName string, imageName string) string <span class="cov0" title="0">{
        return strings.ToLower(fmt.Sprintf("%s%s%s", registryURL, mainRepositoryName, imageName))
}</span>

func BuildAgentUpdateProgress(serialNumber string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s.%s.%s", topicPrefix, serialNumber, topics.AgentProgress)
}</span>

func BuildDownloadOSUpdateProgress(serialNumber string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s.%s.%s", topicPrefix, serialNumber, topics.DownloadOSUpdateProgress)
}</span>

func BuildInstallOSUpdateProgress(serialNumber string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s.%s.%s", topicPrefix, serialNumber, topics.InstallOSUpdateProgress)
}</span>

func BuildPerformOSUpdateProgress(serialNumber string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s.%s.%s", topicPrefix, serialNumber, topics.PerformOSUpdateProgress)
}</span>

func BuildTunnelStateUpdate(serialNumber string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s.%s.%s/onreload", topicPrefix, serialNumber, topics.TunnelStateUpdate)
}</span>

const topicPrefix = "re.mgmt"

func BuildLogTopic(serialNumber string, containerName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("reswarm.logs.%s.%s", serialNumber, containerName)
}</span>

func BuildExternalApiTopic(serialNumber string, topic string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s.%s.%s", topicPrefix, serialNumber, topic)
}</span>

func BuildDockerBuildID(appKey uint64, appName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("build_%d_%s", appKey, appName)
}</span>

func BuildDockerPullID(appKey uint64, appName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("pull_%d_%s", appKey, appName)
}</span>

func BuildDockerPushID(appKey uint64, appName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("push_%d_%s", appKey, appName)
}</span>

func EscapeNewlineCharacters(input string) string <span class="cov0" title="0">{
        input = strings.ReplaceAll(input, "\n", "\\n")
        input = strings.ReplaceAll(input, "\t", "\\t")
        input = strings.ReplaceAll(input, "\r", "\\r")
        return input
}</span>

func EnvironmentTemplateToStringArray(environmentsTemplateMap map[string]interface{}) []string <span class="cov0" title="0">{
        stringArray := make([]string, 0)

        for key, entry := range environmentsTemplateMap </span><span class="cov0" title="0">{
                value := entry.(map[string]interface{})["defaultValue"]
                if value != nil </span><span class="cov0" title="0">{
                        stringArray = append(stringArray, fmt.Sprintf("%s=%s", key, EscapeNewlineCharacters(fmt.Sprint(value))))
                }</span>
        }

        <span class="cov0" title="0">return stringArray</span>
}

func ListDirectories(path string) ([]string, error) <span class="cov0" title="0">{
        folder, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer folder.Close()

        subfolders, err := folder.Readdir(-1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var directories []string
        for _, item := range subfolders </span><span class="cov0" title="0">{
                if item.IsDir() </span><span class="cov0" title="0">{
                        directories = append(directories, item.Name())
                }</span>
        }

        <span class="cov0" title="0">return directories, nil</span>
}

func EnvironmentVarsToStringArray(environmentsMap map[string]interface{}) []string <span class="cov0" title="0">{
        stringArray := make([]string, 0)

        for key, entry := range environmentsMap </span><span class="cov0" title="0">{
                value := entry.(map[string]interface{})["value"]
                stringArray = append(stringArray, fmt.Sprintf("%s=%s", key, EscapeNewlineCharacters(fmt.Sprint(value))))
        }</span>

        <span class="cov0" title="0">return stringArray</span>
}

var StatusRegex = regexp.MustCompile(`\((.*?)\)`)

func ParseExitCodeFromContainerStatus(status string) (int64, error) <span class="cov0" title="0">{
        statusString := StatusRegex.FindString(status)
        exitCodeString := strings.TrimRight(strings.TrimLeft(statusString, "("), ")")
        exitCodeInt, err := strconv.ParseInt(exitCodeString, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">return exitCodeInt, nil</span>
}

func GetRandomFreePort() (port int, err error) <span class="cov0" title="0">{
        var a *net.TCPAddr
        if a, err = net.ResolveTCPAddr("tcp", "localhost:0"); err == nil </span><span class="cov0" title="0">{
                var l *net.TCPListener
                if l, err = net.ListenTCP("tcp", a); err == nil </span><span class="cov0" title="0">{
                        defer l.Close()
                        return l.Addr().(*net.TCPAddr).Port, nil
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func GetFreePortFromStart(startPort int) (int, error) <span class="cov0" title="0">{
        for port := startPort; port &lt;= 65535; port++ </span><span class="cov0" title="0">{
                addr := fmt.Sprintf("127.0.0.1:%d", port)
                listener, err := net.Listen("tcp", addr)
                if err == nil </span><span class="cov0" title="0">{
                        defer listener.Close()
                        return listener.Addr().(*net.TCPAddr).Port, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, fmt.Errorf("no free port available")</span>
}

// Ordinal gives you the input number in a rank/ordinal format.
//
// Ordinal(3) -&gt; 3rd
func Ordinal(x uint) string <span class="cov0" title="0">{
        suffix := "th"
        switch x % 10 </span>{
        case 1:<span class="cov0" title="0">
                if x%100 != 11 </span><span class="cov0" title="0">{
                        suffix = "st"
                }</span>
        case 2:<span class="cov0" title="0">
                if x%100 != 12 </span><span class="cov0" title="0">{
                        suffix = "nd"
                }</span>
        case 3:<span class="cov0" title="0">
                if x%100 != 13 </span><span class="cov0" title="0">{
                        suffix = "rd"
                }</span>
        }
        <span class="cov0" title="0">return strconv.Itoa(int(x)) + suffix</span>
}

func ParseContainerName(containerName string) (Stage, uint64, string, error) <span class="cov0" title="0">{
        if containerName == "" </span><span class="cov0" title="0">{
                return "", 0, "", errors.New("container name is empty")
        }</span>

        // cleanup container name
        <span class="cov0" title="0">if string([]rune(containerName)[0]) == "/" </span><span class="cov0" title="0">{
                // get index of the rune that == /
                _, i := utf8.DecodeRuneInString(containerName)
                // remove that rune from the string
                containerName = containerName[i:]
        }</span>

        <span class="cov0" title="0">var stage Stage
        var appKey uint64
        var name string

        containerSplit := strings.Split(containerName, "_")
        if len(containerSplit) &lt; 3 </span><span class="cov0" title="0">{
                return "", 0, "", errors.New("invalid container name")
        }</span>

        <span class="cov0" title="0">if containerSplit[0] == "dev" </span><span class="cov0" title="0">{
                stage = DEV
        }</span> else<span class="cov0" title="0"> if containerSplit[0] == "prod" </span><span class="cov0" title="0">{
                stage = PROD
        }</span> else<span class="cov0" title="0"> if containerSplit[0] == "pub" </span><span class="cov0" title="0">{
                stage = DEV
        }</span> else<span class="cov0" title="0"> {
                stage = ""
        }</span>

        <span class="cov0" title="0">parsedAppKey, err := strconv.ParseUint(containerSplit[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, "", err
        }</span>
        <span class="cov0" title="0">appKey = parsedAppKey

        // also handles names like dev_6_net_data, aka 2 _'s at the end
        name = strings.Join(containerSplit[2:], "_")

        return stage, appKey, name, nil</span>
}

func ParseComposeContainerName(containerName string) (Stage, uint64, string, error) <span class="cov0" title="0">{
        if containerName == "" </span><span class="cov0" title="0">{
                return "", 0, "", errors.New("container name is empty")
        }</span>

        // cleanup container name
        <span class="cov0" title="0">if string([]rune(containerName)[0]) == "/" </span><span class="cov0" title="0">{
                // get index of the rune that == /
                _, i := utf8.DecodeRuneInString(containerName)
                // remove that rune from the string
                containerName = containerName[i:]
        }</span>

        <span class="cov0" title="0">var stage Stage
        var appKey uint64
        var name string

        containerSplit := strings.Split(containerName, "_")
        if containerSplit[3] != "compose" </span><span class="cov0" title="0">{
                return "", 0, "", errors.New("invalid compose container name")
        }</span>

        <span class="cov0" title="0">if containerSplit[0] == "dev" </span><span class="cov0" title="0">{
                stage = DEV
        }</span> else<span class="cov0" title="0"> if containerSplit[0] == "prod" </span><span class="cov0" title="0">{
                stage = PROD
        }</span> else<span class="cov0" title="0"> if containerSplit[0] == "pub" </span><span class="cov0" title="0">{
                stage = DEV
        }</span> else<span class="cov0" title="0"> {
                stage = ""
        }</span>

        <span class="cov0" title="0">parsedAppKey, err := strconv.ParseUint(containerSplit[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, "", err
        }</span>
        <span class="cov0" title="0">appKey = parsedAppKey

        name = containerSplit[2]

        return stage, appKey, name, nil</span>
}

func (tp *TransitionPayload) initContainerData(appKey uint64, appName string, config *config.Config) <span class="cov0" title="0">{
        publishContainer := BuildContainerName("pub", appKey, appName)
        devContainerName := BuildContainerName(DEV, appKey, appName)
        prodContainerName := BuildContainerName(PROD, appKey, appName)

        _, arch, variant := release.GetSystemInfo()
        imageArchName := arch + variant

        devImageName := BuildImageName(DEV, imageArchName, appKey, appName)
        devRegImageName := BuildRegistryImageName(config.ReswarmConfig.DockerRegistryURL, config.ReswarmConfig.DockerMainRepository, devImageName)

        prodImageName := BuildImageName(PROD, imageArchName, appKey, appName)
        prodRegImageName := BuildRegistryImageName(config.ReswarmConfig.DockerRegistryURL, config.ReswarmConfig.DockerMainRepository, prodImageName)

        tp.PublishContainerName = publishContainer
        tp.ContainerName = StageBasedResult{
                Dev:  devContainerName,
                Prod: prodContainerName,
        }
        tp.ImageName = StageBasedResult{
                Dev:  devImageName,
                Prod: prodImageName,
        }
        tp.RegistryImageName = StageBasedResult{
                Dev:  devRegImageName,
                Prod: prodRegImageName,
        }
}</span>

func PrettyPrintDebug(data interface{}) <span class="cov0" title="0">{
        pretty, err := PrettyFormat(data)
        if err != nil </span><span class="cov0" title="0">{
                pretty = fmt.Sprintf("%+v", pretty)
        }</span>

        <span class="cov0" title="0">log.Debug().Msg(pretty)</span>
}

func Min(a int64, b int64) int64 <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func Log(format string, stdout bool, logLevel string, val ...interface{}) <span class="cov0" title="0">{
        levelMsg := strings.ToUpper(logLevel)

        if stdout </span><span class="cov0" title="0">{
                args := make([]interface{}, 0)
                args = append(args, fmt.Sprintf("%s:", levelMsg))
                args = append(args, val...)

                if format == "" </span><span class="cov0" title="0">{
                        fmt.Println(args)
                        return
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf(format, args)
                        return
                }</span>
        }

        <span class="cov0" title="0">event := log.Debug()
        switch logLevel </span>{
        case "error":<span class="cov0" title="0">
                event = log.Error()</span>
        case "info":<span class="cov0" title="0">
                event = log.Info()</span>
        case "warning":<span class="cov0" title="0">
                event = log.Warn()</span>
        }

        <span class="cov0" title="0">if format == "" </span><span class="cov0" title="0">{
                event.Msg(fmt.Sprint(val...))
                return
        }</span> else<span class="cov0" title="0"> {
                event.Msgf(format, val...)
                return
        }</span>
}

func PrettyFormat(data interface{}) (string, error) <span class="cov0" title="0">{
        var p []byte
        //    var err := error
        p, err := json.MarshalIndent(data, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(p), nil</span>
}

// Stats contains system resource usage information
type Stats struct {
        CPUCount          int     `json:"cpu_count"`           // Number of logical CPUs
        CPUUsagePercent   float64 `json:"cpu_usage_percent"`   // CPU usage percentage (0-100)
        MemoryTotal       uint64  `json:"memory_total"`        // Total memory in bytes
        MemoryUsed        uint64  `json:"memory_used"`         // Used memory in bytes
        MemoryAvailable   uint64  `json:"memory_available"`    // Available memory in bytes
        StorageTotal      uint64  `json:"storage_total"`       // Total storage in bytes (root filesystem)
        StorageUsed       uint64  `json:"storage_used"`        // Used storage in bytes (root filesystem)
        StorageFree       uint64  `json:"storage_free"`        // Free storage in bytes (root filesystem)
        DockerAppsTotal   uint64  `json:"docker_apps_total"`   // Total storage in bytes (/opt/reagent/docker-apps)
        DockerAppsUsed    uint64  `json:"docker_apps_used"`    // Used storage in bytes (/opt/reagent/docker-apps)
        DockerAppsFree    uint64  `json:"docker_apps_free"`    // Free storage in bytes (/opt/reagent/docker-apps)
        DockerAppsMounted bool    `json:"docker_apps_mounted"` // Whether /opt/reagent/docker-apps is a separate mount
}

// GetStats returns current system resource statistics.
// This function is cross-platform (Linux, macOS, Windows).
func GetStats() Stats <span class="cov0" title="0">{
        stats := Stats{}

        // Get CPU count
        if cpuCount, err := cpu.Counts(true); err == nil </span><span class="cov0" title="0">{
                stats.CPUCount = cpuCount
        }</span>

        // Get CPU usage (percentage is the only meaningful metric for CPU)
        <span class="cov0" title="0">if cpuPercent, err := cpu.Percent(0, false); err == nil &amp;&amp; len(cpuPercent) &gt; 0 </span><span class="cov0" title="0">{
                stats.CPUUsagePercent = cpuPercent[0]
        }</span>

        // Get Memory - absolute values
        <span class="cov0" title="0">if vmStat, err := mem.VirtualMemory(); err == nil </span><span class="cov0" title="0">{
                stats.MemoryTotal = vmStat.Total
                stats.MemoryUsed = vmStat.Used
                stats.MemoryAvailable = vmStat.Available
        }</span>

        // Get Disk - absolute values for root filesystem
        <span class="cov0" title="0">if diskStat, err := disk.Usage("/"); err == nil </span><span class="cov0" title="0">{
                stats.StorageTotal = diskStat.Total
                stats.StorageUsed = diskStat.Used
                stats.StorageFree = diskStat.Free
        }</span>

        // Get Docker apps storage - /opt/reagent/docker-apps mount
        <span class="cov0" title="0">dockerAppsPath := "/opt/reagent/docker-apps"
        if diskStat, err := disk.Usage(dockerAppsPath); err == nil </span><span class="cov0" title="0">{
                stats.DockerAppsTotal = diskStat.Total
                stats.DockerAppsUsed = diskStat.Used
                stats.DockerAppsFree = diskStat.Free
                // Check if it's a separate mount (different total than root)
                stats.DockerAppsMounted = stats.DockerAppsTotal != stats.StorageTotal
        }</span>

        <span class="cov0" title="0">return stats</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package config

import (
        "encoding/json"
        "flag"
        "fmt"
        "io/ioutil"

        "github.com/rs/zerolog/log"

        "os"
        "path/filepath"
        "runtime"
)

// ReswarmConfig types for the .flock file
type ReswarmConfig struct {
        Name   string `json:"name"`
        Secret string `json:"secret"`
        Board  struct {
                CPU          string      `json:"cpu"`
                Docs         interface{} `json:"docs"`
                Board        string      `json:"board"`
                Model        string      `json:"model"`
                Boardname    string      `json:"boardname"`
                Modelname    string      `json:"modelname"`
                Reflasher    bool        `json:"reflasher"`
                Architecture string      `json:"architecture"`
        } `json:"board"`
        Status         string      `json:"status"`
        Password       string      `json:"password"`
        Wlanssid       string      `json:"wlanssid"`
        SwarmKey       int         `json:"swarm_key"`
        DeviceKey      int         `json:"device_key"`
        SwarmName      string      `json:"swarm_name"`
        Description    interface{} `json:"description"` // can be null --&gt; interface{}
        Architecture   string      `json:"architecture"`
        SerialNumber   string      `json:"serial_number"`
        Authentication struct {
                Key         string `json:"key"`
                Certificate string `json:"certificate"`
        } `json:"authentication"`
        SwarmOwnerName       string `json:"swarm_owner_name"`
        ConfigPassphrase     string `json:"config_passphrase"`
        DeviceEndpointURL    string `json:"device_endpoint_url"`
        Environment          string `json:"environment,omitempty"`
        DockerRegistryURL    string `json:"docker_registry_url"`
        InsecureRegistries   string `json:"insecure-registries,omitempty"`
        DockerMainRepository string `json:"docker_main_repository"`
        ReswarmBaseURL       string `json:"-"`
}

type CommandLineArguments struct {
        AppsDirectory              string
        AppsComposeDir             string
        AppsBuildDir               string
        AppsSharedDir              string
        AgentDir                   string
        DownloadDir                string
        CompressedBuildExtension   string
        RemoteUpdateURL            string
        Environment                string
        Debug                      bool
        DebugMessaging             bool
        Version                    bool
        Arch                       bool
        Offline                    bool
        Profiling                  bool
        ProfilingPort              uint
        ShouldUpdateAgent          bool
        PrettyLogging              bool
        UseNetworkManager          bool
        LogFileLocation            string
        ConfigFileLocation         string
        DatabaseFileName           string
        PingPongTimeout            uint
        ResponseTimeout            uint
        ConnectionEstablishTimeout uint
}

type Config struct {
        ReswarmConfig        *ReswarmConfig
        CommandLineArguments *CommandLineArguments
        StartupLogChannel    chan string
}

func New(cliArgs *CommandLineArguments, reswarmConfig *ReswarmConfig) Config <span class="cov0" title="0">{
        return Config{
                ReswarmConfig:        reswarmConfig,
                CommandLineArguments: cliArgs,
        }
}</span>

func GetCliArguments() (*CommandLineArguments, error) <span class="cov0" title="0">{
        defaultAgentDir := "/opt/reagent"
        defaultLogFilePath := "/var/log/reagent.log"

        // fallback for when reagent is ran on mac/windows
        if runtime.GOOS != "linux" </span><span class="cov0" title="0">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">defaultLogFilePath = fmt.Sprintf("%s/%s", homeDir, "reagent/reagent.log")
                defaultAgentDir = fmt.Sprintf("%s/%s", homeDir, "reagent")</span>
        }

        // By default apps are stored inside the default agent directory, as well, to
        // support a variety of distributions/systems with a rootfs only. However,
        // for the agent running on actual embedded linux we tend to use a separate
        // dedicated (update-)persistent partition mounted at "/apps"
        <span class="cov0" title="0">defaultAppsDir := filepath.Join(defaultAgentDir, "apps")

        // sqlite database files go into the default agent directory as well
        defaultDatabaseFileName := filepath.Join(defaultAgentDir, "reagent.db")

        logFile := flag.String("logFile", defaultLogFilePath, "log file used by the reagent")
        debug := flag.Bool("debug", true, "sets the log level to debug")
        shouldUpdate := flag.Bool("update", true, "determines if the agent should update on start")
        offline := flag.Bool("offline", false, "starts the agent without establishing a socket connection. meant for debugging")
        env := flag.String("env", "production", "determines in which environment the agent will operate. Possible values: (production, test, local)")
        arch := flag.Bool("arch", false, "displays the architecture for which the binary was built")
        version := flag.Bool("version", false, "displays the current version of the agent")
        profiling := flag.Bool("profiling", false, "spins up a pprof webserver on the defined port")
        profilingPort := flag.Uint("profilingPort", 80, "port of the profiling service")
        prettyLogging := flag.Bool("prettyLogging", false, "enables the pretty console writing, intended for debugging")
        remoteUpdateURL := flag.String("remoteUpdateURL", "https://storage.googleapis.com", "bucket to be used to download updates")
        agentDir := flag.String("agentDir", defaultAgentDir, "default location of the agent binary")
        appsDir := flag.String("appsDir", defaultAppsDir, "default path for apps and app-data")
        databaseFileName := flag.String("dbFileName", defaultDatabaseFileName, "defines the name used to persist the database file")
        debugMessaging := flag.Bool("debugMessaging", false, "enables debug logs for messenging layer")
        nmw := flag.Bool("nmw", true, "enables the agent to use the NetworkManager API on Linux machines")
        compressedBuildExtension := flag.String("compressedBuildExtension", "tgz", "sets the extension in which the compressed build files will be provided")
        pingPongTimeout := flag.Uint("ppTimeout", 5000, "Sets the ping pong timeout of the client in milliseconds (0 means no timeout)")
        responseTimeout := flag.Uint("respTimeout", 7000, "Sets the response timeout of the client in milliseconds")
        socketConnectionEstablishTimeout := flag.Uint("connTimeout", 1250, "Sets the connection timeout for the socket connection in milliseconds. (0 means no timeout)")
        cfgFile := flag.String("config", "", "ironflock configuration file")
        flag.Parse()

        cliArgs := CommandLineArguments{
                AppsDirectory:              *appsDir,
                AppsBuildDir:               (*appsDir) + "/build",
                AppsComposeDir:             (*appsDir) + "/compose",
                AppsSharedDir:              (*appsDir) + "/shared",
                DownloadDir:                (*agentDir) + "/downloads",
                AgentDir:                   *agentDir,
                RemoteUpdateURL:            *remoteUpdateURL,
                CompressedBuildExtension:   *compressedBuildExtension,
                Debug:                      *debug,
                Version:                    *version,
                Offline:                    *offline,
                Environment:                *env,
                PrettyLogging:              *prettyLogging,
                DebugMessaging:             *debugMessaging,
                LogFileLocation:            *logFile,
                ConfigFileLocation:         *cfgFile,
                Profiling:                  *profiling,
                ProfilingPort:              *profilingPort,
                ShouldUpdateAgent:          *shouldUpdate,
                DatabaseFileName:           *databaseFileName,
                PingPongTimeout:            *pingPongTimeout,
                ResponseTimeout:            *responseTimeout,
                ConnectionEstablishTimeout: *socketConnectionEstablishTimeout,
                Arch:                       *arch,
                UseNetworkManager:          *nmw,
        }

        return &amp;cliArgs, nil</span>
}

func SaveReswarmConfig(path string, reswarmConfig *ReswarmConfig) error <span class="cov0" title="0">{
        file, err := json.MarshalIndent(reswarmConfig, "", " ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ioutil.WriteFile(path, file, os.ModePerm)</span>
}

// LoadReswarmConfig populates a ReswarmConfig struct from a given path
func LoadReswarmConfig(path string) (*ReswarmConfig, error) <span class="cov0" title="0">{
        jsonFile, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer jsonFile.Close()
        byteValue, _ := ioutil.ReadAll(jsonFile)

        var reswarmConfig ReswarmConfig
        json.Unmarshal(byteValue, &amp;reswarmConfig)

        if reswarmConfig.DockerRegistryURL == "registry.reswarm.io/" </span><span class="cov0" title="0">{
                reswarmConfig.DockerRegistryURL = "registry.ironflock.com/"
        }</span>

        <span class="cov0" title="0">if reswarmConfig.DeviceEndpointURL == "wss://cbw.record-evolution.com/ws-re-dev" </span><span class="cov0" title="0">{
                reswarmConfig.DeviceEndpointURL = "wss://cbw.ironflock.com/ws-re-dev"
        }</span>

        <span class="cov0" title="0">err = SaveReswarmConfig(path, &amp;reswarmConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Stack().Err(err).Msg("failed to save .flock config file")
        }</span>

        <span class="cov0" title="0">return &amp;reswarmConfig, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package debounce

import (
        "sync"
        "time"
)

// New returns a debounced function that takes another functions as its argument.
// This function will be called when the debounced function stops being called
// for the given duration.
// The debounced function can be invoked with different functions, if needed,
// the last one will win.
func New(after time.Duration) func(f func()) <span class="cov0" title="0">{
        d := &amp;debouncer{after: after}

        return func(f func()) </span><span class="cov0" title="0">{
                d.add(f)
        }</span>
}

type debouncer struct {
        mu    sync.Mutex
        after time.Duration
        timer *time.Timer
}

func (d *debouncer) add(f func()) <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        if d.timer != nil </span><span class="cov0" title="0">{
                d.timer.Stop()
        }</span>
        <span class="cov0" title="0">d.timer = time.AfterFunc(d.after, f)</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package errdefs

import "errors"

var ErrNotYetImplemented = errors.New("not yet implemented")
var ErrNotFound = errors.New("not found")
var ErrAlreadyExists = errors.New("already exists")
var ErrFailedToParse = errors.New("failed to parse")
var ErrMissingFromPayload = errors.New("missing from payload")
var ErrConfigNotProvided = errors.New("no config file provided")

/*------------*/

type ErrBuildFailed struct{ error }

func (e ErrBuildFailed) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrBuildFailed) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func BuildFailed(err error) error <span class="cov0" title="0">{
        if err == nil || IsBuildFailed(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return ErrBuildFailed{err}</span>
}

/*------------*/

type ErrContainerNameAlreadyInUse struct{ error }

func (e ErrContainerNameAlreadyInUse) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrContainerNameAlreadyInUse) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func ContainerNameAlreadyInUse(err error) error <span class="cov0" title="0">{
        if err == nil || IsContainerNameAlreadyInUse(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ErrContainerNameAlreadyInUse{err}</span>
}

/*------------*/

type ErrContainerNotFound struct{ error }

func (e ErrContainerNotFound) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrContainerNotFound) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func ContainerNotFound(err error) error <span class="cov0" title="0">{
        if err == nil || IsContainerNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ErrContainerNotFound{err}</span>
}

/*------------*/

type ErrImageNotFound struct{ error }

func (e ErrImageNotFound) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrImageNotFound) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func ImageNotFound(err error) error <span class="cov0" title="0">{
        if err == nil || IsImageNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ErrImageNotFound{err}</span>
}

/*------------*/

type ErrInsufficientPrivileges struct{ error }

func (e ErrInsufficientPrivileges) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrInsufficientPrivileges) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func InsufficientPrivileges(err error) error <span class="cov0" title="0">{
        if err == nil || IsInsufficientPrivileges(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ErrInsufficientPrivileges{err}</span>
}

/*------------*/

type ErrContainerRemovalAlreadyInProgress struct{ error }

func (e ErrContainerRemovalAlreadyInProgress) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrContainerRemovalAlreadyInProgress) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func ContainerRemovalAlreadyInProgress(err error) error <span class="cov0" title="0">{
        if err == nil || IsContainerRemovalAlreadyInProgress(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ErrContainerRemovalAlreadyInProgress{err}</span>
}

/*-----------*/

type ErrRegistrationHandlerFailed struct {
        err error
        URI string
}

func (e ErrRegistrationHandlerFailed) Error() string <span class="cov0" title="0">{
        return e.err.Error()
}</span>

func (e ErrRegistrationHandlerFailed) Cause() error <span class="cov0" title="0">{
        return e.err
}</span>

func (e ErrRegistrationHandlerFailed) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>

func RegistrationHandlerFailed(err error, URI string) error <span class="cov0" title="0">{
        if err == nil || IsRegistrationHandlerFailed(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ErrRegistrationHandlerFailed{err, URI}</span>
}

/*-----------*/

type ErrDockerfileCannotBeEmpty struct {
        error
}

func (e ErrDockerfileCannotBeEmpty) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrDockerfileCannotBeEmpty) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func DockerfileCannotBeEmpty(err error) error <span class="cov0" title="0">{
        if err == nil || IsDockerfileCannotBeEmpty(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ErrDockerfileCannotBeEmpty{err}</span>
}

/*-----------*/

type ErrDockerfileIsMissing struct {
        error
}

func (e ErrDockerfileIsMissing) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrDockerfileIsMissing) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func DockerfileIsMissing(err error) error <span class="cov0" title="0">{
        if err == nil || IsDockerfileIsMissing(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ErrDockerfileIsMissing{err}</span>
}

/*-----------*/

type ErrDockerBuildFilesNotFound struct {
        error
}

func (e ErrDockerBuildFilesNotFound) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrDockerBuildFilesNotFound) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func DockerBuildFilesNotFound(err error) error <span class="cov0" title="0">{
        if err == nil || IsDockerBuildFilesNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ErrDockerBuildFilesNotFound{err}</span>
}

/*-----------*/

type ErrDockerStreamCanceled struct {
        error
}

func (e ErrDockerStreamCanceled) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrDockerStreamCanceled) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func DockerStreamCanceled(err error) error <span class="cov0" title="0">{
        if err == nil || IsDockerStreamCanceled(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ErrDockerStreamCanceled{err}</span>
}

/*-----------*/

type ErrNoActionTransition struct {
        error
}

func (e ErrNoActionTransition) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrNoActionTransition) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func NoActionTransition() error <span class="cov0" title="0">{
        return ErrNoActionTransition{errors.New("no action")}
}</span>

/*-----------*/

type ErrInProgress struct {
        error
}

func (e ErrInProgress) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrInProgress) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func InProgress(err error) error <span class="cov0" title="0">{
        return ErrInProgress{err}
}</span>

/*-----------*/

type ErrDockerComposeNotSupported struct {
        error
}

func (e ErrDockerComposeNotSupported) Cause() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e ErrDockerComposeNotSupported) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func DockerComposeNotSupported(err error) error <span class="cov0" title="0">{
        if err == nil || IsDockerComposeNotSupported(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ErrDockerComposeNotSupported{err}</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package errdefs

func IsBuildFailed(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrBuildFailed)
        return ok
}</span>

func IsContainerNameAlreadyInUse(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrContainerNameAlreadyInUse)
        return ok
}</span>

func IsContainerNotFound(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrContainerNotFound)
        return ok
}</span>

func IsImageNotFound(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrImageNotFound)
        return ok
}</span>

func IsContainerRemovalAlreadyInProgress(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrContainerRemovalAlreadyInProgress)
        return ok
}</span>

func IsRegistrationHandlerFailed(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrContainerRemovalAlreadyInProgress)
        return ok
}</span>

func IsDockerfileCannotBeEmpty(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrDockerfileCannotBeEmpty)
        return ok
}</span>

func IsDockerfileIsMissing(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrDockerfileIsMissing)
        return ok
}</span>

func IsDockerStreamCanceled(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrDockerStreamCanceled)
        return ok
}</span>

func IsDockerComposeNotSupported(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrDockerComposeNotSupported)
        return ok
}</span>

func IsNoActionTransition(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrNoActionTransition)
        return ok
}</span>

func IsDockerBuildFilesNotFound(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrDockerBuildFilesNotFound)
        return ok
}</span>

func IsInProgress(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrInProgress)
        return ok
}</span>

func IsInsufficientPrivileges(err error) bool <span class="cov0" title="0">{
        _, ok := err.(ErrInsufficientPrivileges)
        return ok
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package messenger

import (
        "context"
        "reagent/common"
        "reagent/config"
        "reagent/messenger/topics"
)

type OfflineMessenger struct {
        config *config.Config
}

func NewOffline(config *config.Config) *OfflineMessenger <span class="cov10" title="6">{
        return &amp;OfflineMessenger{config}
}</span>

func (om OfflineMessenger) Register(topic topics.Topic, cb func(ctx context.Context, invocation Result) (*InvokeResult, error), options common.Dict) error <span class="cov1" title="1">{
        return nil
}</span>

func (om OfflineMessenger) Publish(topic topics.Topic, args []interface{}, kwargs common.Dict, options common.Dict) error <span class="cov1" title="1">{
        return nil
}</span>

func (om OfflineMessenger) Subscribe(topic topics.Topic, cb func(Result) error, options common.Dict) error <span class="cov1" title="1">{
        return nil
}</span>

func (om OfflineMessenger) Call(ctx context.Context, topic topics.Topic, args []interface{}, kwargs common.Dict, options common.Dict, progCb func(Result)) (Result, error) <span class="cov0" title="0">{
        return Result{}, nil
}</span>

func (om OfflineMessenger) SubscriptionID(topic topics.Topic) (id uint64, ok bool) <span class="cov0" title="0">{
        return 0, true
}</span>

func (om OfflineMessenger) RegistrationID(topic topics.Topic) (id uint64, ok bool) <span class="cov0" title="0">{
        return 0, true
}</span>

func (om OfflineMessenger) Unregister(topic topics.Topic) error <span class="cov0" title="0">{
        return nil
}</span>

func (om OfflineMessenger) Unsubscribe(topic topics.Topic) error <span class="cov0" title="0">{
        return nil
}</span>

func (om OfflineMessenger) SetupTestament() error <span class="cov0" title="0">{
        return nil
}</span>

func (om OfflineMessenger) GetSessionID() uint64 <span class="cov1" title="1">{
        return 0
}</span>

func (om OfflineMessenger) GetConfig() *config.Config <span class="cov1" title="1">{
        return om.config
}</span>

func (om OfflineMessenger) Connected() bool <span class="cov1" title="1">{
        return false
}</span>

func (om OfflineMessenger) SetOnConnect(cb func(reconnect bool)) {<span class="cov0" title="0">
}</span>

func (om OfflineMessenger) Close() {<span class="cov0" title="0">

}</span>

func (om OfflineMessenger) UpdateRemoteDeviceStatus(status DeviceStatus) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package messenger

import (
        "context"
        "errors"
        "sync"

        "github.com/gammazero/nexus/v3/client"
        "github.com/gammazero/nexus/v3/wamp"
)

// =============================================================================
// Error Constants
// =============================================================================

// ErrMockConnectionFailed is returned when MockClient is configured to fail connections.
var ErrMockConnectionFailed = errors.New("mock connection failed")

// ErrMockCallLimitExceeded is returned when MockNexusClient exceeds its call limit.
var ErrMockCallLimitExceeded = errors.New("mock call limit exceeded")

// =============================================================================
// MockClient - Configurable mock that mirrors the real client structure
// =============================================================================

// MockClient is a configurable mock client that produces MockNexusClients.
// It mirrors the structure of the real nexus client where you configure
// connection behavior and then call ConnectNet to get a NexusClient.
//
// Usage:
//
//        mockClient := NewMockClient()
//        mockClient.SetConnectFailCount(2) // Fail first 2 connection attempts
//        session, err := NewWampSession(cfg, socketConfig, nil, mockClient.ConnectNet)
//        // After successful connection:
//        nexusClient := mockClient.LastClient()
type MockClient struct {
        mu sync.Mutex

        // Connection behavior configuration
        connectFailCount int   // Number of times ConnectNet should fail before succeeding
        connectError     error // Error to return on connection failure

        // Client configuration (applied to created MockNexusClients)
        clientCallLimit      int   // Max calls before client fails (0 = unlimited)
        clientCallError      error // Error to return on Call operations
        clientPublishError   error // Error to return on Publish operations
        clientDontSignalDone bool  // Whether Close() should NOT signal Done()

        // Custom client configurator for advanced scenarios
        clientConfigurator func(*MockNexusClient)

        // Tracking
        connectAttempts int
        clients         []*MockNexusClient
}

// NewMockClient creates a new MockClient with default settings.
// By default, connections succeed immediately and clients work normally.
func NewMockClient() *MockClient <span class="cov4" title="17">{
        return &amp;MockClient{
                connectError: ErrMockConnectionFailed,
        }
}</span>

// =============================================================================
// Connection Configuration
// =============================================================================

// SetConnectFailCount sets how many connection attempts should fail before succeeding.
// Pass 0 for immediate success (default).
func (m *MockClient) SetConnectFailCount(count int) *MockClient <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.connectFailCount = count
        return m
}</span>

// SetConnectError sets the error returned on failed connection attempts.
// Defaults to ErrMockConnectionFailed.
func (m *MockClient) SetConnectError(err error) *MockClient <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.connectError = err
        return m
}</span>

// =============================================================================
// Client Configuration (applied to created MockNexusClients)
// =============================================================================

// SetClientCallLimit sets the maximum number of Call operations before
// the created clients start returning ErrMockCallLimitExceeded.
// Pass 0 for unlimited (default).
func (m *MockClient) SetClientCallLimit(limit int) *MockClient <span class="cov2" title="4">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.clientCallLimit = limit
        return m
}</span>

// SetClientCallError sets the error that created clients will return on Call operations.
// Pass nil for successful calls (default).
func (m *MockClient) SetClientCallError(err error) *MockClient <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.clientCallError = err
        return m
}</span>

// SetClientPublishError sets the error that created clients will return on Publish operations.
// Pass nil for successful publishes (default).
func (m *MockClient) SetClientPublishError(err error) *MockClient <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.clientPublishError = err
        return m
}</span>

// SetClientDontSignalDone configures whether created clients should NOT signal Done() on Close().
// When true, simulates the nexus bug where ping timeout doesn't properly signal Done().
func (m *MockClient) SetClientDontSignalDone(value bool) *MockClient <span class="cov1" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.clientDontSignalDone = value
        return m
}</span>

// SetClientConfigurator sets a custom function to configure each created MockNexusClient.
// This is called after applying other client settings, allowing advanced customization.
func (m *MockClient) SetClientConfigurator(fn func(*MockNexusClient)) *MockClient <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.clientConfigurator = fn
        return m
}</span>

// =============================================================================
// ConnectNet - The ClientProvider function
// =============================================================================

// ConnectNet is the ClientProvider function. Pass this to NewWampSession.
//
// Usage:
//
//        mockClient := NewMockClient()
//        session, err := NewWampSession(cfg, socketConfig, nil, mockClient.ConnectNet)
func (m *MockClient) ConnectNet(ctx context.Context, url string, cfg client.Config) (NexusClient, error) <span class="cov8" title="482">{
        m.mu.Lock()
        m.connectAttempts++
        attempt := m.connectAttempts
        failCount := m.connectFailCount
        connectErr := m.connectError

        // Capture client config while holding lock
        callLimit := m.clientCallLimit
        callError := m.clientCallError
        publishError := m.clientPublishError
        dontSignalDone := m.clientDontSignalDone
        configurator := m.clientConfigurator
        m.mu.Unlock()

        // Fail for the configured number of attempts
        if attempt &lt;= failCount </span><span class="cov1" title="2">{
                return nil, connectErr
        }</span>

        // Create successful client
        <span class="cov8" title="480">nexusClient := &amp;MockNexusClient{
                connected:      true,
                done:           make(chan struct{}),
                callLimit:      callLimit,
                callError:      callError,
                publishError:   publishError,
                dontSignalDone: dontSignalDone,
        }

        // Apply custom configurator if set
        if configurator != nil </span><span class="cov1" title="2">{
                configurator(nexusClient)
        }</span>

        <span class="cov8" title="480">m.mu.Lock()
        m.clients = append(m.clients, nexusClient)
        m.mu.Unlock()

        return nexusClient, nil</span>
}

// =============================================================================
// Inspection Functions
// =============================================================================

// ConnectAttempts returns the number of ConnectNet calls made.
func (m *MockClient) ConnectAttempts() int <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.connectAttempts
}</span>

// Clients returns all MockNexusClients created by ConnectNet.
func (m *MockClient) Clients() []*MockNexusClient <span class="cov3" title="5">{
        m.mu.Lock()
        defer m.mu.Unlock()
        result := make([]*MockNexusClient, len(m.clients))
        copy(result, m.clients)
        return result
}</span>

// LastClient returns the most recently created MockNexusClient, or nil if none.
func (m *MockClient) LastClient() *MockNexusClient <span class="cov2" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if len(m.clients) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov2" title="3">return m.clients[len(m.clients)-1]</span>
}

// ClientCount returns the number of MockNexusClients created.
func (m *MockClient) ClientCount() int <span class="cov3" title="6">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return len(m.clients)
}</span>

// Reset clears all tracking state (attempts and clients) but keeps configuration.
func (m *MockClient) Reset() *MockClient <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.connectAttempts = 0
        m.clients = nil
        return m
}</span>

// =============================================================================
// MockNexusClient - Mock implementation of NexusClient
// =============================================================================

// MockNexusClient is a mock implementation of NexusClient for testing.
// It is created by MockClient.ConnectNet() and can be configured to
// simulate various error conditions.
type MockNexusClient struct {
        mu sync.Mutex

        // Connection state
        connected      bool
        done           chan struct{}
        dontSignalDone bool // When true, Close() won't close the done channel

        // Error configuration
        callError      error
        publishError   error
        registerError  error
        subscribeError error

        // Call limit
        callLimit int // When &gt; 0, fails after this many calls

        // Call tracking
        callCount      int
        publishCount   int
        registerCount  int
        subscribeCount int

        // Custom result for Call
        callResult *wamp.Result

        // Custom call handler for complex test scenarios
        onCall func(procedure string) (*wamp.Result, error)
}

// =============================================================================
// MockNexusClient - Simulation Functions
// =============================================================================

// SimulateConnectionDrop simulates the server dropping the connection.
// This closes the Done() channel and sets Connected() to false.
func (m *MockNexusClient) SimulateConnectionDrop() <span class="cov1" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.connected </span><span class="cov1" title="2">{
                m.connected = false
                close(m.done)
        }</span>
}

// SimulateBrokenConnection simulates a connection that appears connected
// but all calls fail. The Done() channel is NOT closed, simulating
// the nexus bug where ping timeout doesn't properly signal Done().
func (m *MockNexusClient) SimulateBrokenConnection(callError error) <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.connected = true
        m.callError = callError
        m.dontSignalDone = true
}</span>

// SetCallError sets an error to be returned on Call operations.
// Pass nil to clear the error.
func (m *MockNexusClient) SetCallError(err error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.callError = err
}</span>

// SetPublishError sets an error to be returned on Publish operations.
// Pass nil to clear the error.
func (m *MockNexusClient) SetPublishError(err error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.publishError = err
}</span>

// SetRegisterError sets an error to be returned on Register operations.
// Pass nil to clear the error.
func (m *MockNexusClient) SetRegisterError(err error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.registerError = err
}</span>

// SetSubscribeError sets an error to be returned on Subscribe operations.
// Pass nil to clear the error.
func (m *MockNexusClient) SetSubscribeError(err error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.subscribeError = err
}</span>

// SetCallResult sets a custom result to be returned on Call operations.
// Pass nil to return an empty result.
func (m *MockNexusClient) SetCallResult(result *wamp.Result) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.callResult = result
}</span>

// SetOnCall sets a custom handler for Call operations.
// This allows complex test scenarios where different calls need different results.
// Pass nil to use the default behavior.
func (m *MockNexusClient) SetOnCall(handler func(procedure string) (*wamp.Result, error)) <span class="cov1" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.onCall = handler
}</span>

// SetDontSignalDone configures whether Close() should signal the Done() channel.
// When true, simulates the nexus bug where ping timeout doesn't properly signal Done().
func (m *MockNexusClient) SetDontSignalDone(value bool) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.dontSignalDone = value
}</span>

// SetCallLimit sets the maximum number of calls before returning ErrMockCallLimitExceeded.
// Pass 0 to disable the limit.
func (m *MockNexusClient) SetCallLimit(limit int) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.callLimit = limit
}</span>

// =============================================================================
// MockNexusClient - Inspection Functions
// =============================================================================

// CallCount returns the number of Call operations made.
func (m *MockNexusClient) CallCount() int <span class="cov1" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.callCount
}</span>

// PublishCount returns the number of Publish operations made.
func (m *MockNexusClient) PublishCount() int <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.publishCount
}</span>

// RegisterCount returns the number of Register operations made.
func (m *MockNexusClient) RegisterCount() int <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.registerCount
}</span>

// SubscribeCount returns the number of Subscribe operations made.
func (m *MockNexusClient) SubscribeCount() int <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.subscribeCount
}</span>

// =============================================================================
// MockNexusClient - NexusClient Interface Implementation
// =============================================================================

func (m *MockNexusClient) Close() error <span class="cov8" title="460">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.connected </span><span class="cov8" title="458">{
                m.connected = false
                if !m.dontSignalDone </span><span class="cov8" title="457">{
                        close(m.done)
                }</span>
        }
        <span class="cov8" title="460">return nil</span>
}

func (m *MockNexusClient) Connected() bool <span class="cov10" title="1069">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.connected
}</span>

func (m *MockNexusClient) Done() &lt;-chan struct{} <span class="cov8" title="476">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.done
}</span>

func (m *MockNexusClient) ID() wamp.ID <span class="cov5" title="25">{
        return wamp.ID(12345)
}</span>

func (m *MockNexusClient) Publish(topic string, options wamp.Dict, args wamp.List, kwargs wamp.Dict) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.publishCount++
        return m.publishError
}</span>

func (m *MockNexusClient) Subscribe(topic string, fn client.EventHandler, options wamp.Dict) error <span class="cov8" title="477">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.subscribeCount++
        return m.subscribeError
}</span>

func (m *MockNexusClient) SubscriptionID(topic string) (wamp.ID, bool) <span class="cov0" title="0">{
        return wamp.ID(100), true
}</span>

func (m *MockNexusClient) Unsubscribe(topic string) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *MockNexusClient) Call(ctx context.Context, procedure string, options wamp.Dict, args wamp.List, kwargs wamp.Dict, progCb client.ProgressHandler) (*wamp.Result, error) <span class="cov5" title="25">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.callCount++

        // Check call limit
        if m.callLimit &gt; 0 &amp;&amp; m.callCount &gt; m.callLimit </span><span class="cov1" title="2">{
                return nil, ErrMockCallLimitExceeded
        }</span>

        // Use custom handler if set
        <span class="cov5" title="23">if m.onCall != nil </span><span class="cov3" title="6">{
                return m.onCall(procedure)
        }</span>

        <span class="cov4" title="17">if m.callError != nil </span><span class="cov0" title="0">{
                return nil, m.callError
        }</span>

        <span class="cov4" title="17">if m.callResult != nil </span><span class="cov0" title="0">{
                return m.callResult, nil
        }</span>

        <span class="cov4" title="17">return &amp;wamp.Result{}, nil</span>
}

func (m *MockNexusClient) Register(procedure string, fn client.InvocationHandler, options wamp.Dict) error <span class="cov8" title="477">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.registerCount++
        return m.registerError
}</span>

func (m *MockNexusClient) RegistrationID(procedure string) (wamp.ID, bool) <span class="cov0" title="0">{
        return wamp.ID(200), true
}</span>

func (m *MockNexusClient) Unregister(procedure string) error <span class="cov0" title="0">{
        return nil
}</span>

// Ensure MockNexusClient implements NexusClient
var _ NexusClient = (*MockNexusClient)(nil)
</pre>
		
		<pre class="file" id="file48" style="display: none">package messenger

import (
        "reagent/common"
        "reagent/config"
)

// testConfig returns a minimal test configuration for messenger tests
func testConfig() *config.Config <span class="cov10" title="23">{
        return &amp;config.Config{
                CommandLineArguments: &amp;config.CommandLineArguments{
                        AgentDir:      "/opt/reagent",
                        PrettyLogging: true,
                        Debug:         true,
                        Offline:       false,
                },
                ReswarmConfig: &amp;config.ReswarmConfig{
                        Environment:       string(common.PRODUCTION),
                        SwarmKey:          1,
                        DeviceKey:         1,
                        SerialNumber:      "test-serial-001",
                        Secret:            "test-secret",
                        DeviceEndpointURL: "ws://localhost:8080/ws",
                        ReswarmBaseURL:    "https://app.ironflock.com",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package messenger

import (
        "context"
        "crypto/tls"
        "errors"
        "fmt"
        "os"
        "regexp"
        "strings"
        "sync"
        "time"

        "reagent/common"
        "reagent/config"
        "reagent/container"
        "reagent/messenger/topics"
        "reagent/safe"

        "github.com/gammazero/nexus/v3/client"
        "github.com/gammazero/nexus/v3/transport"
        "github.com/gammazero/nexus/v3/wamp"
        "github.com/gammazero/nexus/v3/wamp/crsign"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

type WampSession struct {
        client         NexusClient
        container      container.Container
        agentConfig    *config.Config
        socketConfig   *SocketConfig
        clientProvider ClientProvider // nil means use default client.ConnectNet
        mu             sync.Mutex
        onConnect      func(reconnect bool) // Callback invoked after successful connection/reconnection
        heartbeatDone  chan struct{}        // Closed by heartbeat when connection failure is detected
}

type wampLogWrapper struct {
        logger *zerolog.Logger
}

type DeviceStatus string

const (
        CONNECTED    DeviceStatus = "CONNECTED"
        DISCONNECTED DeviceStatus = "DISCONNECTED"
        CONFIGURING  DeviceStatus = "CONFIGURING"
)

var ErrNotConnected = errors.New("not connected")

func newWampLogger(zeroLogger *zerolog.Logger) wampLogWrapper <span class="cov9" title="479">{
        return wampLogWrapper{logger: zeroLogger}
}</span>

func (wl wampLogWrapper) Print(v ...interface{}) <span class="cov0" title="0">{
        // Check for connection errors that indicate the connection is broken
        for _, val := range v </span><span class="cov0" title="0">{
                if str, ok := val.(string); ok </span><span class="cov0" title="0">{
                        if strings.Contains(str, "broken pipe") || strings.Contains(str, "connection reset") || strings.Contains(str, "write tcp") </span><span class="cov0" title="0">{
                                log.Warn().Msgf("WAMP connection error detected: %v", str)
                        }</span>
                }
        }
        <span class="cov0" title="0">wl.logger.Print(v...)</span>
}

func (wl wampLogWrapper) Println(v ...interface{}) <span class="cov0" title="0">{
        // Check for connection errors
        for _, val := range v </span><span class="cov0" title="0">{
                if str, ok := val.(string); ok </span><span class="cov0" title="0">{
                        if strings.Contains(str, "broken pipe") || strings.Contains(str, "connection reset") || strings.Contains(str, "write tcp") </span><span class="cov0" title="0">{
                                log.Warn().Msgf("WAMP connection error detected: %v", str)
                        }</span>
                }
        }
        <span class="cov0" title="0">wl.logger.Print(v, "\n")</span>
}

func (wl wampLogWrapper) Printf(format string, v ...interface{}) <span class="cov0" title="0">{
        // Check for connection errors in formatted strings
        if strings.Contains(format, "broken pipe") || strings.Contains(format, "connection reset") || strings.Contains(format, "write tcp") </span><span class="cov0" title="0">{
                log.Warn().Msgf("WAMP connection error detected: "+format, v...)
        }</span>
        <span class="cov0" title="0">wl.logger.Printf(format, v...)</span>
}

func wrapZeroLogger(zeroLogger zerolog.Logger) wampLogWrapper <span class="cov9" title="479">{
        wrapper := newWampLogger(&amp;zeroLogger)
        return wrapper
}</span>

type SocketConfig struct {
        PingPongTimeout   time.Duration
        ResponseTimeout   time.Duration
        ConnectionTimeout time.Duration
        HeartbeatInterval time.Duration // Default: 30 seconds if zero
        SetupTestament    bool
}

// DefaultHeartbeatInterval is the default interval between heartbeat checks
const DefaultHeartbeatInterval = 30 * time.Second

// ClientProvider is a function that attempts to connect and returns a NexusClient.
// It's used to allow mocking the connection in tests.
type ClientProvider func(ctx context.Context, url string, cfg client.Config) (NexusClient, error)

var legacyEndpointRegex = regexp.MustCompile(`devices.*\.(com|io):8080`)

func createConnectConfig(config *config.Config, socketConfig *SocketConfig) (*client.Config, error) <span class="cov9" title="483">{
        reswarmConfig := config.ReswarmConfig

        cfg := client.Config{
                Realm: "realm1",
                HelloDetails: wamp.Dict{
                        "authid": fmt.Sprintf("%d-%d", reswarmConfig.SwarmKey, reswarmConfig.DeviceKey),
                },
                AuthHandlers: map[string]client.AuthFunc{
                        "wampcra": clientAuthFunc(reswarmConfig.Secret),
                },
                Debug:  config.CommandLineArguments.DebugMessaging,
                Logger: wrapZeroLogger(log.Logger),
        }

        isLegacyEndpoint := legacyEndpointRegex.Match([]byte(reswarmConfig.DeviceEndpointURL))
        if isLegacyEndpoint </span><span class="cov0" title="0">{
                tlscert, err := tls.X509KeyPair([]byte(reswarmConfig.Authentication.Certificate), []byte(reswarmConfig.Authentication.Key))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">cfg.TlsCfg = &amp;tls.Config{
                        Certificates:       []tls.Certificate{tlscert},
                        InsecureSkipVerify: true,
                }</span>
        }

        <span class="cov9" title="482">if socketConfig.PingPongTimeout != 0 </span><span class="cov0" title="0">{
                cfg.WsCfg = transport.WebsocketConfig{
                        KeepAlive: socketConfig.PingPongTimeout,
                }
        }</span>

        <span class="cov9" title="482">if socketConfig.ResponseTimeout != 0 </span><span class="cov1" title="2">{
                cfg.ResponseTimeout = socketConfig.ResponseTimeout
        }</span>

        <span class="cov9" title="482">return &amp;cfg, nil</span>
}

// SetOnConnect sets the callback that will be invoked after each successful connection or reconnection.
// The callback receives a boolean indicating whether this is a reconnection (true) or initial connection (false).
func (wampSession *WampSession) SetOnConnect(cb func(reconnect bool)) <span class="cov3" title="5">{
        wampSession.mu.Lock()
        defer wampSession.mu.Unlock()
        wampSession.onConnect = cb
}</span>

// NewWampSession creates a new WampSession from a ReswarmConfig file.
// If clientProvider is nil, the default client.ConnectNet is used.
func NewWampSession(config *config.Config, socketConfig *SocketConfig, container container.Container, clientProvider ClientProvider) (*WampSession, error) <span class="cov4" title="17">{
        session := &amp;WampSession{
                agentConfig:    config,
                socketConfig:   socketConfig,
                container:      container,
                clientProvider: clientProvider,
                heartbeatDone:  make(chan struct{}),
        }

        err := session.connect()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="17">return session, nil</span>
}

// connect establishes the WAMP connection
func (wampSession *WampSession) connect() error <span class="cov4" title="17">{
        clientChannel := wampSession.establishSocketConnection()
        wampSession.client = &lt;-clientChannel

        if wampSession.socketConfig.SetupTestament </span><span class="cov0" title="0">{
                err := wampSession.SetupTestament()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Start connection monitoring
        <span class="cov4" title="17">wampSession.listenForDisconnect()
        wampSession.startHeartbeat()

        return nil</span>
}

// reconnect attempts to re-establish the WAMP connection.
// Returns true if reconnection was successful, false otherwise.
func (wampSession *WampSession) reconnect() bool <span class="cov9" title="464">{
        wampSession.mu.Lock()
        // Close existing client
        if wampSession.client != nil </span><span class="cov0" title="0">{
                wampSession.client.Close()
                wampSession.client = nil
        }</span>
        <span class="cov9" title="464">wampSession.mu.Unlock()

        // Establish new connection
        clientChannel := wampSession.establishSocketConnection()

        wampSession.mu.Lock()
        wampSession.client = &lt;-clientChannel
        wampSession.mu.Unlock()

        // Check if we actually connected
        if !wampSession.Connected() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov9" title="463">if wampSession.socketConfig.SetupTestament </span><span class="cov0" title="0">{
                err := wampSession.SetupTestament()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Stack().Err(err).Msg("failed to setup testament")
                }</span>
        }

        <span class="cov9" title="463">return true</span>
}

// listenForDisconnect starts a goroutine that monitors for disconnection
// and automatically handles reconnection. When reconnection succeeds,
// it invokes the onConnect callback (if set) with reconnect=true.
func (wampSession *WampSession) listenForDisconnect() <span class="cov9" title="480">{
        log.Debug().Msg("listenForDisconnect: Starting disconnect listener setup...")

        // Get the current client's done channel
        wampSession.mu.Lock()
        client := wampSession.client
        heartbeatDone := wampSession.heartbeatDone
        wampSession.mu.Unlock()

        if client == nil </span><span class="cov0" title="0">{
                log.Warn().Msg("ListenForDisconnect called but client is nil")
                return
        }</span>

        <span class="cov9" title="480">clientDone := client.Done()

        safe.Go(func() </span><span class="cov9" title="480">{
                // Wait for either the client to signal done OR the heartbeat to detect failure
                select </span>{
                case &lt;-clientDone:<span class="cov7" title="85">
                        log.Warn().Msg("Connection lost: Received done signal from WAMP client (broken pipe, timeout, or server disconnect)")</span>
                case &lt;-heartbeatDone:<span class="cov9" title="379">
                        log.Warn().Msg("Connection lost: Heartbeat detected connection failure")</span>
                }

                <span class="cov9" title="464">wampSession.Close()

                // Cancel any active container streams
                if wampSession.container != nil </span><span class="cov0" title="0">{
                        err := wampSession.container.CancelAllStreams()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).Msg("error closing stream")
                        }</span>
                }

                <span class="cov9" title="464">reconnectAttempt := 0
                for </span><span class="cov9" title="464">{
                        reconnectAttempt++
                        log.Info().Msgf("Reconnect attempt #%d: Attempting to reconnect...", reconnectAttempt)

                        if wampSession.reconnect() </span><span class="cov9" title="463">{
                                log.Info().Msgf("Reconnect attempt #%d: Successfully reconnected to WAMP router", reconnectAttempt)

                                // Invoke onConnect callback if set
                                wampSession.mu.Lock()
                                cb := wampSession.onConnect
                                wampSession.mu.Unlock()

                                if cb != nil </span><span class="cov3" title="5">{
                                        safe.Go(func() </span><span class="cov3" title="5">{
                                                log.Info().Msg("Re-initializing after reconnection...")
                                                cb(true) // reconnect = true
                                                log.Info().Msg("Successfully re-initialized after reconnection")
                                        }</span>)
                                }

                                // Start listening for the next disconnect and restart heartbeat
                                <span class="cov9" title="463">wampSession.listenForDisconnect()
                                return</span>
                        }

                        <span class="cov0" title="0">log.Warn().Msgf("Reconnect attempt #%d: Connection failed or immediately lost, retrying in 1s...", reconnectAttempt)
                        time.Sleep(time.Second * 1)</span>
                }
        })

        <span class="cov9" title="480">log.Debug().Msg("Messenger: Setup disconnect listener")</span>
}

// startHeartbeat starts a goroutine that periodically sends a heartbeat to verify
// the connection is alive. If the heartbeat fails consecutively, it signals via heartbeatDone channel.
func (wampSession *WampSession) startHeartbeat() <span class="cov4" title="17">{
        heartbeatInterval := wampSession.socketConfig.HeartbeatInterval
        if heartbeatInterval == 0 </span><span class="cov4" title="13">{
                heartbeatInterval = DefaultHeartbeatInterval
        }</span>

        // Create a new heartbeat channel only if the current one is nil or closed
        <span class="cov4" title="17">wampSession.mu.Lock()
        if wampSession.heartbeatDone == nil </span><span class="cov0" title="0">{
                wampSession.heartbeatDone = make(chan struct{})
        }</span> else<span class="cov4" title="17"> {
                // Check if channel is closed by trying a non-blocking receive
                select </span>{
                case &lt;-wampSession.heartbeatDone:<span class="cov0" title="0">
                        // Channel was closed, create a new one
                        wampSession.heartbeatDone = make(chan struct{})</span>
                default:<span class="cov4" title="17"></span>
                        // Channel is still open, keep using it
                }
        }
        <span class="cov4" title="17">heartbeatDone := wampSession.heartbeatDone
        wampSession.mu.Unlock()

        safe.Go(func() </span><span class="cov4" title="17">{
                consecutiveFailures := 0
                const maxConsecutiveFailures = 2 // Trigger reconnect after 2 failures

                for </span><span class="cov6" title="41">{
                        time.Sleep(heartbeatInterval)

                        // Check if connection is still alive
                        if !wampSession.Connected() </span><span class="cov0" title="0">{
                                log.Warn().Msg("Connection lost detected in heartbeat, waiting for reconnection...")
                                consecutiveFailures = 0
                                continue</span>
                        }

                        <span class="cov5" title="25">err := wampSession.UpdateRemoteDeviceStatus(CONNECTED)
                        if err != nil </span><span class="cov2" title="3">{
                                consecutiveFailures++
                                log.Warn().Err(err).Msgf("Failed to send heartbeat (%d/%d failures), connection may be lost", consecutiveFailures, maxConsecutiveFailures)

                                // If we've failed multiple times, the connection is likely broken
                                // Signal via heartbeatDone channel to trigger reconnection
                                if consecutiveFailures &gt;= maxConsecutiveFailures </span><span class="cov1" title="1">{
                                        log.Error().Msg("Connection appears to be broken (multiple heartbeat failures), signaling reconnection...")
                                        close(heartbeatDone)
                                        return // Exit this heartbeat goroutine
                                }</span>
                        } else<span class="cov5" title="22"> {
                                // Reset counter on success
                                if consecutiveFailures &gt; 0 </span><span class="cov1" title="1">{
                                        log.Info().Msg("Heartbeat successful, connection restored")
                                }</span>
                                <span class="cov5" title="22">consecutiveFailures = 0</span>
                        }
                }
        })

        <span class="cov4" title="17">log.Debug().Msg("Messenger: Started heartbeat")</span>
}

func (wampSession *WampSession) Publish(topic topics.Topic, args []interface{}, kwargs common.Dict, options common.Dict) error <span class="cov0" title="0">{
        wampSession.mu.Lock()
        client := wampSession.client
        wampSession.mu.Unlock()

        if client == nil </span><span class="cov0" title="0">{
                return ErrNotConnected
        }</span>

        <span class="cov0" title="0">err := client.Publish(string(topic), wamp.Dict(options), args, wamp.Dict(kwargs))
        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Err(err).Str("topic", string(topic)).Msg("Failed to publish to topic")
        }</span>
        <span class="cov0" title="0">return err</span>
}

// establishSocketConnection establishes a WAMP connection using the session's ClientProvider.
// If clientProvider is nil, client.ConnectNet is used directly.
func (wampSession *WampSession) establishSocketConnection() chan NexusClient <span class="cov9" title="481">{
        agentConfig := wampSession.agentConfig
        socketConfig := wampSession.socketConfig
        container := wampSession.container
        provider := wampSession.clientProvider

        resChan := make(chan NexusClient)

        // never returns a established connection
        if agentConfig.CommandLineArguments.Offline </span><span class="cov0" title="0">{
                log.Warn().Msg("Started in offline mode, will not establish a socket connection!")
                return resChan
        }</span>

        <span class="cov9" title="481">log.Debug().Msg("Attempting to establish a socket connection...")

        safe.Go(func() </span><span class="cov9" title="481">{
                for </span><span class="cov9" title="483">{
                        connectionConfig, err := createConnectConfig(agentConfig, socketConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).Msg("failed to create connect config...")
                                continue</span>
                        }

                        <span class="cov9" title="483">var ctx context.Context
                        var cancelFunc context.CancelFunc

                        if socketConfig.ConnectionTimeout == 0 </span><span class="cov0" title="0">{
                                ctx = context.Background()
                        }</span> else<span class="cov9" title="483"> {
                                ctx, cancelFunc = context.WithTimeout(context.Background(), socketConfig.ConnectionTimeout)
                        }</span>

                        <span class="cov9" title="483">var duration time.Duration
                        requestStart := time.Now() // time request
                        var wClient NexusClient
                        if provider != nil </span><span class="cov9" title="483">{
                                wClient, err = provider(ctx, agentConfig.ReswarmConfig.DeviceEndpointURL, *connectionConfig)
                        }</span> else<span class="cov0" title="0"> {
                                wClient, err = client.ConnectNet(ctx, agentConfig.ReswarmConfig.DeviceEndpointURL, *connectionConfig)
                        }</span>
                        <span class="cov9" title="483">if err != nil </span><span class="cov1" title="2">{
                                if cancelFunc != nil </span><span class="cov1" title="2">{
                                        cancelFunc()
                                }</span>

                                <span class="cov1" title="2">duration = time.Since(requestStart)

                                if strings.Contains(err.Error(), "WAMP-CRA client signature is invalid") </span><span class="cov0" title="0">{
                                        exitMessage := fmt.Sprintln("The IronFlock device connect authentication failed")
                                        fmt.Println(exitMessage)
                                        os.Exit(1)
                                }</span>

                                <span class="cov1" title="2">log.Debug().Stack().Err(err).Msgf("Failed to establish a websocket connection (duration: %s), reattempting... in 1s", duration.String())
                                time.Sleep(time.Second * 1)
                                continue</span>
                        }

                        <span class="cov9" title="481">if cancelFunc != nil </span><span class="cov9" title="481">{
                                cancelFunc()
                        }</span>

                        // add a dummy topic that will be used as a means to check if a client has an existing session or not
                        <span class="cov9" title="481">topic := common.BuildExternalApiTopic(agentConfig.ReswarmConfig.SerialNumber, "wamp_connection_established")
                        invokeHandler := func(ctx context.Context, i *wamp.Invocation) client.InvokeResult </span><span class="cov0" title="0">{
                                return client.InvokeResult{Args: wamp.List{"Hello :-)"}}
                        }</span>

                        <span class="cov9" title="481">err = wClient.Register(topic, invokeHandler, nil)
                        if err != nil &amp;&amp; strings.Contains(err.Error(), string(wamp.ErrProcedureAlreadyExists)) </span><span class="cov0" title="0">{
                                exitMessage := fmt.Sprintf("a WAMP connection for %s already exists", agentConfig.ReswarmConfig.SerialNumber)
                                fmt.Println(exitMessage)
                                os.Exit(1)
                        }</span>

                        <span class="cov9" title="481">onDestroyListener := func(event *wamp.Event) </span><span class="cov0" title="0">{
                                container.PruneSystem()
                                os.Exit(1)
                        }</span>

                        <span class="cov9" title="481">wClient.Subscribe(fmt.Sprintf("%s/ondestroy", topics.ReswarmDeviceList), onDestroyListener, wamp.Dict{})

                        if wClient.Connected() </span><span class="cov9" title="480">{
                                duration = time.Since(requestStart)
                                log.Debug().Msgf("Sucessfully established a connection (duration: %s)", duration.String())
                                resChan &lt;- wClient
                                close(resChan)
                                return
                        }</span>

                        <span class="cov0" title="0">duration = time.Since(requestStart)
                        if wClient != nil </span><span class="cov0" title="0">{
                                wClient.Close()
                        }</span>

                        <span class="cov0" title="0">log.Debug().Msgf("A Session was established, but we are not connected (duration: %s)", duration.String())</span>
                }
        })

        <span class="cov9" title="481">return resChan</span>
}

func (wampSession *WampSession) Connected() bool <span class="cov10" title="592">{
        wampSession.mu.Lock()
        client := wampSession.client
        wampSession.mu.Unlock()
        if client == nil </span><span class="cov1" title="2">{
                return false
        }</span>
        <span class="cov9" title="590">return client.Connected()</span>
}

// Client returns the underlying NexusClient.
// This is primarily useful for testing to access the MockNexusClient.
func (wampSession *WampSession) Client() NexusClient <span class="cov0" title="0">{
        wampSession.mu.Lock()
        defer wampSession.mu.Unlock()
        return wampSession.client
}</span>

func (wampSession *WampSession) Subscribe(topic topics.Topic, cb func(Result) error, options common.Dict) error <span class="cov0" title="0">{
        wampSession.mu.Lock()
        client := wampSession.client
        wampSession.mu.Unlock()

        if client == nil </span><span class="cov0" title="0">{
                return ErrNotConnected
        }</span>

        <span class="cov0" title="0">handler := func(event *wamp.Event) </span><span class="cov0" title="0">{
                cbEventMap := Result{
                        Subscription: uint64(event.Subscription),
                        Publication:  uint64(event.Publication),
                        Details:      common.Dict(event.Details),
                        Arguments:    []interface{}(event.Arguments),
                        ArgumentsKw:  common.Dict(event.ArgumentsKw),
                }
                err := cb(cbEventMap)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Stack().Err(err).Msgf("An error occured during the subscribe result of %s", topic)
                }</span>
        }

        <span class="cov0" title="0">return client.Subscribe(string(topic), handler, wamp.Dict(options))</span>
}

func (wampSession *WampSession) GetConfig() *config.Config <span class="cov5" title="25">{
        return wampSession.agentConfig
}</span>

func (wampSession *WampSession) SubscriptionID(topic topics.Topic) (id uint64, ok bool) <span class="cov0" title="0">{
        wampSession.mu.Lock()
        client := wampSession.client
        wampSession.mu.Unlock()

        if client == nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">subID, ok := client.SubscriptionID(string(topic))
        return uint64(subID), ok</span>
}

func (wampSession *WampSession) RegistrationID(topic topics.Topic) (id uint64, ok bool) <span class="cov0" title="0">{
        wampSession.mu.Lock()
        client := wampSession.client
        wampSession.mu.Unlock()

        if client == nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">subID, ok := client.RegistrationID(string(topic))
        return uint64(subID), ok</span>
}

func (wampSession *WampSession) Call(
        ctx context.Context,
        topic topics.Topic,
        args []interface{},
        kwargs common.Dict,
        options common.Dict,
        progCb func(Result)) (Result, error) <span class="cov5" title="25">{

        wampSession.mu.Lock()
        client := wampSession.client
        wampSession.mu.Unlock()

        if client == nil </span><span class="cov0" title="0">{
                return Result{}, ErrNotConnected
        }</span>

        <span class="cov5" title="25">var handler func(result *wamp.Result)
        if progCb != nil </span><span class="cov0" title="0">{
                handler = func(result *wamp.Result) </span><span class="cov0" title="0">{
                        cbResultMap := Result{
                                Request:     uint64(result.Request),
                                Details:     common.Dict(result.Details),
                                Arguments:   []interface{}(result.Arguments),
                                ArgumentsKw: common.Dict(result.ArgumentsKw),
                        }
                        progCb(cbResultMap)
                }</span>
        }

        <span class="cov5" title="25">result, err := client.Call(ctx, string(topic), wamp.Dict(options), args, wamp.Dict(kwargs), handler)
        if err != nil </span><span class="cov2" title="3">{
                return Result{}, err
        }</span>

        <span class="cov5" title="22">callResultMap := Result{
                Request:     uint64(result.Request),
                Details:     common.Dict(result.Details),
                Arguments:   []interface{}(result.Arguments),
                ArgumentsKw: common.Dict(result.ArgumentsKw),
        }

        return callResultMap, nil</span>
}

func (wampSession *WampSession) GetSessionID() uint64 <span class="cov5" title="25">{
        wampSession.mu.Lock()
        client := wampSession.client
        wampSession.mu.Unlock()

        if client == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov5" title="25">return uint64(client.ID())</span>
}

func (wampSession *WampSession) Register(topic topics.Topic, cb func(ctx context.Context, invocation Result) (*InvokeResult, error), options common.Dict) error <span class="cov0" title="0">{

        invocationHandler := func(ctx context.Context, invocation *wamp.Invocation) client.InvokeResult </span><span class="cov0" title="0">{
                cbInvocationMap := Result{
                        Request:      uint64(invocation.Request),
                        Registration: uint64(invocation.Registration),
                        Details:      common.Dict(invocation.Details),
                        Arguments:    invocation.Arguments,
                        ArgumentsKw:  common.Dict(invocation.ArgumentsKw),
                }

                resultMap, invokeErr := cb(ctx, cbInvocationMap)
                if invokeErr != nil </span><span class="cov0" title="0">{
                        // Global error logging for any Registered WAMP topics
                        log.Error().Stack().Err(invokeErr).Msgf("An error occured during invocation of %s", topic)

                        return client.InvokeResult{
                                Err: wamp.URI("wamp.error.canceled"), // TODO: parse Error URI from error
                                Args: wamp.List{
                                        wamp.Dict{"error": invokeErr.Error()},
                                },
                        }
                }</span>

                <span class="cov0" title="0">kwargs := resultMap.ArgumentsKw

                return client.InvokeResult{Args: resultMap.Arguments, Kwargs: wamp.Dict(kwargs)}</span>
        }

        <span class="cov0" title="0">wampSession.mu.Lock()
        client := wampSession.client
        wampSession.mu.Unlock()

        if client == nil </span><span class="cov0" title="0">{
                return ErrNotConnected
        }</span>

        <span class="cov0" title="0">err := client.Register(string(topic), invocationHandler, wamp.Dict{"force_reregister": true})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (wampSession *WampSession) Unregister(topic topics.Topic) error <span class="cov0" title="0">{
        wampSession.mu.Lock()
        client := wampSession.client
        wampSession.mu.Unlock()

        if client == nil </span><span class="cov0" title="0">{
                return ErrNotConnected
        }</span>

        <span class="cov0" title="0">return client.Unregister(string(topic))</span>
}

func (wampSession *WampSession) Unsubscribe(topic topics.Topic) error <span class="cov0" title="0">{
        wampSession.mu.Lock()
        client := wampSession.client
        wampSession.mu.Unlock()

        if client == nil </span><span class="cov0" title="0">{
                return ErrNotConnected
        }</span>

        <span class="cov0" title="0">return client.Unsubscribe(string(topic))</span>
}

// SetupTestament will setup the device's crossbar testament
func (wampSession *WampSession) SetupTestament() error <span class="cov0" title="0">{
        ctx := context.Background()

        config := wampSession.GetConfig()

        // https://github.com/gammazero/nexus/blob/v3/router/realm.go#L1042 on how to form payload
        args := []interface{}{
                topics.SetDeviceTestament,
                []interface{}{
                        common.Dict{
                                "swarm_key":       config.ReswarmConfig.SwarmKey,
                                "device_key":      config.ReswarmConfig.DeviceKey,
                                "serial_number":   config.ReswarmConfig.SerialNumber,
                                "wamp_session_id": wampSession.GetSessionID(),
                        },
                },
                common.Dict{},
        }

        _, err := wampSession.Call(ctx, topics.MetaProcAddSessionTestament, args, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (wampSession *WampSession) Close() <span class="cov9" title="578">{
        wampSession.mu.Lock()
        clientToClose := wampSession.client
        wampSession.client = nil
        wampSession.mu.Unlock()

        if clientToClose != nil </span><span class="cov9" title="460">{
                clientToClose.Close()
        }</span>
}

func clientAuthFunc(deviceSecret string) func(c *wamp.Challenge) (string, wamp.Dict) <span class="cov9" title="479">{
        return func(c *wamp.Challenge) (string, wamp.Dict) </span><span class="cov0" title="0">{
                return crsign.RespondChallenge(deviceSecret, c, nil), wamp.Dict{}
        }</span>
}

func (wampSession *WampSession) UpdateRemoteDeviceStatus(status DeviceStatus) error <span class="cov5" title="25">{
        config := wampSession.GetConfig()
        ctx, cancelFunc := context.WithTimeout(context.Background(), time.Second*10)
        defer cancelFunc()

        stats := common.GetStats()

        payload := common.Dict{
                "swarm_key":       config.ReswarmConfig.SwarmKey,
                "device_key":      config.ReswarmConfig.DeviceKey,
                "status":          string(status),
                "wamp_session_id": wampSession.GetSessionID(),
                "stats": common.Dict{
                        "cpu_count":           stats.CPUCount,
                        "cpu_usage":           stats.CPUUsagePercent,
                        "memory_total":        stats.MemoryTotal,
                        "memory_used":         stats.MemoryUsed,
                        "memory_available":    stats.MemoryAvailable,
                        "storage_total":       stats.StorageTotal,
                        "storage_used":        stats.StorageUsed,
                        "storage_free":        stats.StorageFree,
                        "docker_apps_total":   stats.DockerAppsTotal,
                        "docker_apps_used":    stats.DockerAppsUsed,
                        "docker_apps_free":    stats.DockerAppsFree,
                        "docker_apps_mounted": stats.DockerAppsMounted,
                },
        }

        res, err := wampSession.Call(ctx, topics.UpdateDeviceStatus, []any{payload}, nil, nil, nil)
        if err != nil </span><span class="cov2" title="3">{
                return err
        }</span>

        <span class="cov5" title="22">if res.Arguments == nil || res.Arguments[0] == nil </span><span class="cov5" title="22">{
                return nil
        }</span>

        <span class="cov0" title="0">args, ok := res.Arguments[0].(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">reswarmBaseURL := fmt.Sprint(args["reswarmBaseURL"])
        if reswarmBaseURL != "" </span><span class="cov0" title="0">{
                wampSession.agentConfig.ReswarmConfig.ReswarmBaseURL = reswarmBaseURL
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package safe

import (
        "runtime/debug"

        "github.com/rs/zerolog/log"
)

func Go(f func()) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        err := recover()

                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal().Msgf("Panic: %+v \n Stack Trace: %s", err, debug.Stack())
                        }</span>
                }()

                <span class="cov0" title="0">f()</span>
        }()
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package testutil

import (
"reagent/common"
"reagent/config"
)

// DefaultTestConfig returns a minimal test configuration
func DefaultTestConfig() *config.Config <span class="cov0" title="0">{
        return &amp;config.Config{
                CommandLineArguments: &amp;config.CommandLineArguments{
                        AgentDir:      "/opt/reagent",
                        PrettyLogging: true,
                        Debug:         true,
                },
                ReswarmConfig: &amp;config.ReswarmConfig{
                        Environment:       string(common.PRODUCTION),
                        SwarmKey:          1,
                        DeviceKey:         1,
                        SerialNumber:      "test-serial-001",
                        Secret:            "test-secret",
                        DeviceEndpointURL: "ws://localhost:8080/ws",
                        ReswarmBaseURL:    "https://app.ironflock.com",
                },
        }
}</span>

// TestConfigBuilder provides a fluent interface for building test configs
type TestConfigBuilder struct {
        config *config.Config
}

// NewTestConfigBuilder creates a new builder with default values
func NewTestConfigBuilder() *TestConfigBuilder <span class="cov0" title="0">{
        return &amp;TestConfigBuilder{
                config: DefaultTestConfig(),
        }
}</span>

// WithSwarmKey sets the swarm key
func (b *TestConfigBuilder) WithSwarmKey(key int) *TestConfigBuilder <span class="cov0" title="0">{
        b.config.ReswarmConfig.SwarmKey = key
        return b
}</span>

// WithDeviceKey sets the device key
func (b *TestConfigBuilder) WithDeviceKey(key int) *TestConfigBuilder <span class="cov0" title="0">{
        b.config.ReswarmConfig.DeviceKey = key
        return b
}</span>

// WithSerialNumber sets the serial number
func (b *TestConfigBuilder) WithSerialNumber(serial string) *TestConfigBuilder <span class="cov0" title="0">{
        b.config.ReswarmConfig.SerialNumber = serial
        return b
}</span>

// WithEnvironment sets the environment
func (b *TestConfigBuilder) WithEnvironment(env string) *TestConfigBuilder <span class="cov0" title="0">{
        b.config.ReswarmConfig.Environment = env
        return b
}</span>

// WithEndpointURL sets the device endpoint URL
func (b *TestConfigBuilder) WithEndpointURL(url string) *TestConfigBuilder <span class="cov0" title="0">{
        b.config.ReswarmConfig.DeviceEndpointURL = url
        return b
}</span>

// WithOfflineMode sets the offline mode flag
func (b *TestConfigBuilder) WithOfflineMode(offline bool) *TestConfigBuilder <span class="cov0" title="0">{
        b.config.CommandLineArguments.Offline = offline
        return b
}</span>

// WithAgentDir sets the agent directory
func (b *TestConfigBuilder) WithAgentDir(dir string) *TestConfigBuilder <span class="cov0" title="0">{
        b.config.CommandLineArguments.AgentDir = dir
        return b
}</span>

// WithDebug sets debug mode
func (b *TestConfigBuilder) WithDebug(debug bool) *TestConfigBuilder <span class="cov0" title="0">{
        b.config.CommandLineArguments.Debug = debug
        return b
}</span>

// Build returns the configured config
func (b *TestConfigBuilder) Build() *config.Config <span class="cov0" title="0">{
        return b.config
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// Package testutil provides common test utilities and mock implementations
package testutil

import (
        "context"
        "reagent/common"
        "reagent/config"
        "reagent/messenger"
        "reagent/messenger/topics"
        "sync"
)

// MockMessenger is a configurable mock implementation of the Messenger interface
type MockMessenger struct {
        mu        sync.RWMutex
        config    *config.Config
        connected bool
        done      chan struct{}
        sessionID uint64

        // Call tracking
        PublishCalls   []PublishCall
        CallCalls      []CallCall
        RegisterCalls  []RegisterCall
        SubscribeCalls []SubscribeCall

        // Configurable responses
        CallResponses map[string]CallResponse
        CallErrors    map[string]error
}

// PublishCall records a Publish call
type PublishCall struct {
        Topic   topics.Topic
        Args    []interface{}
        Kwargs  common.Dict
        Options common.Dict
}

// CallCall records a Call invocation
type CallCall struct {
        Topic   topics.Topic
        Args    []interface{}
        Kwargs  common.Dict
        Options common.Dict
}

// RegisterCall records a Register call
type RegisterCall struct {
        Topic   topics.Topic
        Options common.Dict
}

// SubscribeCall records a Subscribe call
type SubscribeCall struct {
        Topic   topics.Topic
        Options common.Dict
}

// CallResponse holds a configured response for Call
type CallResponse struct {
        Result messenger.Result
        Err    error
}

// NewMockMessenger creates a new mock messenger with default configuration
func NewMockMessenger() *MockMessenger <span class="cov0" title="0">{
        return &amp;MockMessenger{
                config:        DefaultTestConfig(),
                connected:     true,
                done:          make(chan struct{}),
                sessionID:     12345,
                CallResponses: make(map[string]CallResponse),
                CallErrors:    make(map[string]error),
        }
}</span>

// NewMockMessengerWithConfig creates a mock messenger with custom config
func NewMockMessengerWithConfig(cfg *config.Config) *MockMessenger <span class="cov0" title="0">{
        m := NewMockMessenger()
        m.config = cfg
        return m
}</span>

func (m *MockMessenger) Register(topic topics.Topic, cb func(ctx context.Context, invocation messenger.Result) (*messenger.InvokeResult, error), options common.Dict) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.RegisterCalls = append(m.RegisterCalls, RegisterCall{Topic: topic, Options: options})
        return nil
}</span>

func (m *MockMessenger) Publish(topic topics.Topic, args []interface{}, kwargs common.Dict, options common.Dict) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.PublishCalls = append(m.PublishCalls, PublishCall{
                Topic:   topic,
                Args:    args,
                Kwargs:  kwargs,
                Options: options,
        })
        return nil
}</span>

func (m *MockMessenger) Subscribe(topic topics.Topic, cb func(messenger.Result) error, options common.Dict) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.SubscribeCalls = append(m.SubscribeCalls, SubscribeCall{Topic: topic, Options: options})
        return nil
}</span>

func (m *MockMessenger) Call(ctx context.Context, topic topics.Topic, args []interface{}, kwargs common.Dict, options common.Dict, progCb func(messenger.Result)) (messenger.Result, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.CallCalls = append(m.CallCalls, CallCall{
                Topic:   topic,
                Args:    args,
                Kwargs:  kwargs,
                Options: options,
        })

        // Check for configured error
        if err, ok := m.CallErrors[string(topic)]; ok </span><span class="cov0" title="0">{
                return messenger.Result{}, err
        }</span>

        // Check for configured response
        <span class="cov0" title="0">if resp, ok := m.CallResponses[string(topic)]; ok </span><span class="cov0" title="0">{
                return resp.Result, resp.Err
        }</span>

        <span class="cov0" title="0">return messenger.Result{}, nil</span>
}

func (m *MockMessenger) SubscriptionID(topic topics.Topic) (id uint64, ok bool) <span class="cov0" title="0">{
        return 0, true
}</span>

func (m *MockMessenger) RegistrationID(topic topics.Topic) (id uint64, ok bool) <span class="cov0" title="0">{
        return 0, true
}</span>

func (m *MockMessenger) Unregister(topic topics.Topic) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *MockMessenger) Unsubscribe(topic topics.Topic) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *MockMessenger) SetupTestament() error <span class="cov0" title="0">{
        return nil
}</span>

func (m *MockMessenger) GetSessionID() uint64 <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.sessionID
}</span>

func (m *MockMessenger) GetConfig() *config.Config <span class="cov0" title="0">{
        return m.config
}</span>

func (m *MockMessenger) Done() &lt;-chan struct{} <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.done
}</span>

func (m *MockMessenger) Connected() bool <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.connected
}</span>

func (m *MockMessenger) SetOnConnect(cb func(reconnect bool)) {<span class="cov0" title="0">
        // Mock implementation - store callback if needed for testing
}</span>

func (m *MockMessenger) Close() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.connected = false
        select </span>{
        case &lt;-m.done:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                close(m.done)</span>
        }
}

func (m *MockMessenger) UpdateRemoteDeviceStatus(status messenger.DeviceStatus) error <span class="cov0" title="0">{
        return nil
}</span>

// SetConnected sets the connection state
func (m *MockMessenger) SetConnected(connected bool) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.connected = connected
}</span>

// SimulateDisconnect simulates a connection drop
func (m *MockMessenger) SimulateDisconnect() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.connected = false
        select </span>{
        case &lt;-m.done:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                close(m.done)</span>
        }
}

// SetCallResponse configures a response for a specific topic
func (m *MockMessenger) SetCallResponse(topic string, result messenger.Result, err error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.CallResponses[topic] = CallResponse{Result: result, Err: err}
}</span>

// SetCallError configures an error for a specific topic
func (m *MockMessenger) SetCallError(topic string, err error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.CallErrors[topic] = err
}</span>

// GetPublishCount returns the number of publish calls
func (m *MockMessenger) GetPublishCount() int <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return len(m.PublishCalls)
}</span>

// GetCallCount returns the number of call invocations
func (m *MockMessenger) GetCallCount() int <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return len(m.CallCalls)
}</span>

// Reset clears all recorded calls
func (m *MockMessenger) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.PublishCalls = nil
        m.CallCalls = nil
        m.RegisterCalls = nil
        m.SubscribeCalls = nil
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package tunnel

import (
        "fmt"
        "net/url"
        "os"
        "path/filepath"
        "reagent/common"
        "reagent/config"
        "reagent/messenger"
        "regexp"
        "strings"

        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

type Frp struct {
        Config      *config.Config
        wampSession *messenger.WampSession
}

type TunnelConfig struct {
        Subdomain  string
        AppName    string
        Protocol   Protocol
        LocalPort  uint64
        LocalIP    string
        RemotePort uint64
}

// YAML config structures matching frp v0.65.0 format
type FrpcYamlConfig struct {
        ServerAddr    string        `yaml:"serverAddr"`
        ServerPort    int           `yaml:"serverPort"`
        Transport     *Transport    `yaml:"transport,omitempty"`
        WebServer     *WebServer    `yaml:"webServer,omitempty"`
        Log           *LogConfig    `yaml:"log,omitempty"`
        LoginFailExit bool          `yaml:"loginFailExit,omitempty"`
        Proxies       []ProxyConfig `yaml:"proxies,omitempty"`
}

type Transport struct {
        TLS *TLSConfig `yaml:"tls,omitempty"`
}

type TLSConfig struct {
        Enable bool `yaml:"enable"`
}

type WebServer struct {
        Addr string `yaml:"addr"`
        Port int    `yaml:"port"`
}

type LogConfig struct {
        To      string `yaml:"to"`
        Level   string `yaml:"level"`
        MaxDays int    `yaml:"maxDays"`
}

type ProxyConfig struct {
        Name       string          `yaml:"name"`
        Type       string          `yaml:"type"`
        LocalIP    string          `yaml:"localIP,omitempty"`
        LocalPort  int             `yaml:"localPort"`
        RemotePort int             `yaml:"remotePort,omitempty"`
        SubDomain  string          `yaml:"subdomain,omitempty"`
        Transport  *ProxyTransport `yaml:"transport,omitempty"`
}

type ProxyTransport struct {
        UseEncryption bool `yaml:"useEncryption,omitempty"`
}

type TunnelConfigBuilder struct {
        yamlConfig    *FrpcYamlConfig
        appConfig     *config.Config
        ConfigPath    string
        BaseTunnelURL string
}

type FrpcVariable string

const SERVER_ADDRESS FrpcVariable = "server_addr"
const SERVER_PORT FrpcVariable = "server_port"
const ENALBE_TLS FrpcVariable = "tls_enable"
const ADMIN_ADDRESS FrpcVariable = "admin_addr"
const ADMIN_PORT FrpcVariable = "admin_port"

const TYPE FrpcVariable = "type"
const SUBDOMAIN FrpcVariable = "subdomain"
const LOCAL_PORT FrpcVariable = "local_port"
const LOCAL_IP FrpcVariable = "local_ip"
const REMOTE_PORT FrpcVariable = "remote_port"

const PROD_SERVER_ADDR = "app.ironflock.com"
const TEST_SERVER_ADDR = "app.ironflock.dev"

var subdomainRegex = regexp.MustCompile(`\d+-(.*)-\d+`)

func NewTunnelConfigBuilder(cfg *config.Config) TunnelConfigBuilder <span class="cov0" title="0">{
        return initialize(cfg)
}</span>

func CreateTunnelID(subdomain string, protocol string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%s", subdomain, protocol)
}</span>

func CreateSubdomain(protocol Protocol, deviceKey uint64, appName string, localPort uint64) string <span class="cov0" title="0">{
        baseSubdomain := strings.ToLower(fmt.Sprintf("%d-%s-%d", deviceKey, appName, localPort))
        if protocol == HTTPS </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s-%s", "secure", baseSubdomain)
        }</span>
        <span class="cov0" title="0">return baseSubdomain</span>
}

func initialize(cfg *config.Config) TunnelConfigBuilder <span class="cov0" title="0">{
        frpcConfigPath := filepath.Join(cfg.CommandLineArguments.AgentDir, "frpc.yaml")

        // Extract server address from device_endpoint_url
        serverAddr := PROD_SERVER_ADDR // Default fallback

        if cfg.ReswarmConfig.DeviceEndpointURL != "" </span><span class="cov0" title="0">{
                parsedURL, err := url.Parse(cfg.ReswarmConfig.DeviceEndpointURL)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn().Err(err).Msgf("Failed to parse device_endpoint_url, using default: %s", serverAddr)
                }</span> else<span class="cov0" title="0"> {
                        // Extract hostname (without port)
                        hostname := parsedURL.Hostname()
                        if hostname != "" </span><span class="cov0" title="0">{
                                // For localhost, use as-is; otherwise replace subdomain with "app"
                                if hostname == "localhost" || hostname == "127.0.0.1" </span><span class="cov0" title="0">{
                                        serverAddr = hostname
                                }</span> else<span class="cov0" title="0"> {
                                        // Replace subdomain with "app"
                                        // e.g., "api.ironflock.com" -&gt; "app.ironflock.com"
                                        parts := strings.Split(hostname, ".")
                                        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                                                parts[0] = "app"
                                                serverAddr = strings.Join(parts, ".")
                                        }</span> else<span class="cov0" title="0"> {
                                                serverAddr = hostname
                                        }</span>
                                }
                                <span class="cov0" title="0">log.Debug().Msgf("Using tunnel server address from device_endpoint_url: %s", serverAddr)</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // Fallback to environment-based configuration
                switch cfg.ReswarmConfig.Environment </span>{
                case string(common.PRODUCTION):<span class="cov0" title="0">
                        serverAddr = PROD_SERVER_ADDR</span>
                case string(common.TEST):<span class="cov0" title="0">
                        serverAddr = TEST_SERVER_ADDR</span>
                case string(common.LOCAL):<span class="cov0" title="0">
                        serverAddr = "localhost"</span>
                }
                <span class="cov0" title="0">log.Debug().Msgf("Using tunnel server address from environment: %s", serverAddr)</span>
        }

        // Get admin port
        <span class="cov0" title="0">port := 7400
        randomPort, err := common.GetFreePortFromStart(30000)
        if err == nil </span><span class="cov0" title="0">{
                port = randomPort
        }</span>
        <span class="cov0" title="0">log.Debug().Msgf("Using port %d for Frp webserver", port)

        // Initialize YAML config structure
        frpcConfig := &amp;FrpcYamlConfig{
                ServerAddr: serverAddr,
                ServerPort: 7000,
                Transport: &amp;Transport{
                        TLS: &amp;TLSConfig{
                                Enable: true,
                        },
                },
                WebServer: &amp;WebServer{
                        Addr: "127.0.0.1",
                        Port: port,
                },
                Log: &amp;LogConfig{
                        To:      "/var/log/frpc.log",
                        Level:   "debug",
                        MaxDays: 3,
                },
                LoginFailExit: false,
                Proxies:       []ProxyConfig{},
        }

        // For local development, use port 7400 to avoid conflicts with macOS services
        if serverAddr == "localhost" || serverAddr == "127.0.0.1" </span><span class="cov0" title="0">{
                frpcConfig.ServerPort = 7400
        }</span>

        <span class="cov0" title="0">configBuilder := TunnelConfigBuilder{
                yamlConfig:    frpcConfig,
                appConfig:     cfg,
                ConfigPath:    frpcConfigPath,
                BaseTunnelURL: serverAddr,
        }

        configBuilder.SaveConfig()

        return configBuilder</span>
}

func (builder *TunnelConfigBuilder) GetTunnelConfig() ([]TunnelConfig, error) <span class="cov0" title="0">{
        tunnelConfigs := make([]TunnelConfig, 0)

        for _, proxy := range builder.yamlConfig.Proxies </span><span class="cov0" title="0">{
                tunnelConfig := TunnelConfig{
                        Protocol:   Protocol(proxy.Type),
                        LocalPort:  uint64(proxy.LocalPort),
                        RemotePort: uint64(proxy.RemotePort),
                        LocalIP:    proxy.LocalIP,
                        Subdomain:  proxy.SubDomain,
                }

                var appName string
                // For HTTP/HTTPS, parse from subdomain field
                if proxy.SubDomain != "" </span><span class="cov0" title="0">{
                        result := subdomainRegex.FindStringSubmatch(proxy.SubDomain)
                        if len(result) &gt; 1 </span><span class="cov0" title="0">{
                                appName = result[1]
                        }</span> else<span class="cov0" title="0"> {
                                log.Error().Str("subdomain", proxy.SubDomain).Msg("Failed to parse app name from subdomain")
                        }</span>
                } else<span class="cov0" title="0"> {
                        // For TCP/UDP, parse from name field (format: {deviceKey}-{appName}-{port}-{protocol})
                        result := subdomainRegex.FindStringSubmatch(proxy.Name)
                        if len(result) &gt; 1 </span><span class="cov0" title="0">{
                                appName = result[1]
                        }</span> else<span class="cov0" title="0"> {
                                log.Error().Str("name", proxy.Name).Msg("Failed to parse app name from tunnel name")
                        }</span>
                }

                <span class="cov0" title="0">tunnelConfig.AppName = appName
                tunnelConfigs = append(tunnelConfigs, tunnelConfig)</span>
        }

        <span class="cov0" title="0">return tunnelConfigs, nil</span>
}

func (builder *TunnelConfigBuilder) AddTunnelConfig(conf TunnelConfig) <span class="cov0" title="0">{
        tunnelID := CreateTunnelID(conf.Subdomain, string(conf.Protocol))

        // Check if this tunnel already exists in the config
        for _, proxy := range builder.yamlConfig.Proxies </span><span class="cov0" title="0">{
                if proxy.Name == tunnelID </span><span class="cov0" title="0">{
                        log.Debug().Str("tunnelID", tunnelID).Msg("Tunnel already exists in config, skipping add")
                        return
                }</span>
        }

        <span class="cov0" title="0">proxyConfig := ProxyConfig{
                Name:      tunnelID,
                Type:      string(conf.Protocol),
                LocalPort: int(conf.LocalPort),
        }

        if conf.LocalIP != "" </span><span class="cov0" title="0">{
                proxyConfig.LocalIP = conf.LocalIP
        }</span>

        // subdomain is only valid for HTTP/HTTPS protocols
        <span class="cov0" title="0">if conf.Protocol == HTTP || conf.Protocol == HTTPS </span><span class="cov0" title="0">{
                proxyConfig.SubDomain = conf.Subdomain
        }</span> else<span class="cov0" title="0"> {
                // For TCP/UDP, use remotePort instead
                proxyConfig.RemotePort = int(conf.RemotePort)
        }</span>

        <span class="cov0" title="0">builder.yamlConfig.Proxies = append(builder.yamlConfig.Proxies, proxyConfig)
        builder.SaveConfig()</span>
}

func (builder *TunnelConfigBuilder) SetTunnelVariable(tunnelID string, key FrpcVariable, value string) <span class="cov0" title="0">{
        // Find and update existing proxy
        for i := range builder.yamlConfig.Proxies </span><span class="cov0" title="0">{
                if builder.yamlConfig.Proxies[i].Name == tunnelID </span><span class="cov0" title="0">{
                        switch key </span>{
                        case TYPE:<span class="cov0" title="0">
                                builder.yamlConfig.Proxies[i].Type = value</span>
                        case SUBDOMAIN:<span class="cov0" title="0">
                                builder.yamlConfig.Proxies[i].SubDomain = value</span>
                        case LOCAL_PORT:<span class="cov0" title="0">
                                var port int
                                fmt.Sscanf(value, "%d", &amp;port)
                                builder.yamlConfig.Proxies[i].LocalPort = port</span>
                        case LOCAL_IP:<span class="cov0" title="0">
                                builder.yamlConfig.Proxies[i].LocalIP = value</span>
                        case REMOTE_PORT:<span class="cov0" title="0">
                                var port int
                                fmt.Sscanf(value, "%d", &amp;port)
                                builder.yamlConfig.Proxies[i].RemotePort = port</span>
                        }
                        <span class="cov0" title="0">return</span>
                }
        }
}

func (builder *TunnelConfigBuilder) RemoveTunnelVariable(tunnelID string) <span class="cov0" title="0">{
        // Remove proxy with matching name
        newProxies := []ProxyConfig{}
        for _, proxy := range builder.yamlConfig.Proxies </span><span class="cov0" title="0">{
                if proxy.Name != tunnelID </span><span class="cov0" title="0">{
                        newProxies = append(newProxies, proxy)
                }</span>
        }
        <span class="cov0" title="0">builder.yamlConfig.Proxies = newProxies</span>
}

func (builder *TunnelConfigBuilder) Reset() <span class="cov0" title="0">{
        *builder = initialize(builder.appConfig)
}</span>

func (builder *TunnelConfigBuilder) SetAdminPort() <span class="cov0" title="0">{
        port := 7400
        randomPort, err := common.GetFreePortFromStart(30000)
        if err == nil </span><span class="cov0" title="0">{
                port = randomPort
        }</span>

        <span class="cov0" title="0">log.Debug().Msgf("Using port %d for Frp webserver", port)

        builder.yamlConfig.WebServer.Port = port</span>
}

func (builder *TunnelConfigBuilder) SetCommonVariable(key FrpcVariable, value string) <span class="cov0" title="0">{
        switch key </span>{
        case SERVER_ADDRESS:<span class="cov0" title="0">
                builder.yamlConfig.ServerAddr = value</span>
        case SERVER_PORT:<span class="cov0" title="0">
                var port int
                fmt.Sscanf(value, "%d", &amp;port)
                builder.yamlConfig.ServerPort = port</span>
        case ENALBE_TLS:<span class="cov0" title="0">
                builder.yamlConfig.Transport.TLS.Enable = (value == "true")</span>
        case ADMIN_ADDRESS:<span class="cov0" title="0">
                builder.yamlConfig.WebServer.Addr = value</span>
        case ADMIN_PORT:<span class="cov0" title="0">
                var port int
                fmt.Sscanf(value, "%d", &amp;port)
                builder.yamlConfig.WebServer.Port = port</span>
        default:<span class="cov0" title="0">
                // Handle log and other settings
                if key == "log_file" </span><span class="cov0" title="0">{
                        builder.yamlConfig.Log.To = value
                }</span> else<span class="cov0" title="0"> if key == "log_level" </span><span class="cov0" title="0">{
                        builder.yamlConfig.Log.Level = value
                }</span> else<span class="cov0" title="0"> if key == "log_max_days" </span><span class="cov0" title="0">{
                        var days int
                        fmt.Sscanf(value, "%d", &amp;days)
                        builder.yamlConfig.Log.MaxDays = days
                }</span>
        }
}

func (builder *TunnelConfigBuilder) GetAdminPort() (int, error) <span class="cov0" title="0">{
        if builder.yamlConfig.WebServer == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("webServer not configured")
        }</span>
        <span class="cov0" title="0">return builder.yamlConfig.WebServer.Port, nil</span>
}

func (builder *TunnelConfigBuilder) RemoveTunnelConfig(port TunnelConfig) <span class="cov0" title="0">{
        tunnelID := CreateTunnelID(port.Subdomain, string(port.Protocol))
        builder.RemoveTunnelVariable(tunnelID)
        builder.SaveConfig()
}</span>

func (builder *TunnelConfigBuilder) SaveConfig() <span class="cov0" title="0">{
        data, err := yaml.Marshal(builder.yamlConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to marshal frpc config to YAML")
                return
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(builder.ConfigPath, data, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msgf("Failed to write frpc config to %s", builder.ConfigPath)
                return
        }</span>

        <span class="cov0" title="0">log.Debug().Msgf("Saved frpc config to %s", builder.ConfigPath)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package tunnel

import (
        "bufio"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "os"
        "os/exec"
        "os/signal"
        "path/filepath"
        "reagent/common"
        "reagent/config"
        "reagent/errdefs"
        "reagent/filesystem"
        "reagent/messenger"
        "reagent/messenger/topics"
        "reagent/safe"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

type Protocol string

const (
        TCP   Protocol = "tcp"
        UDP   Protocol = "udp"
        HTTP  Protocol = "http"
        HTTPS Protocol = "https"
)

type FrpTunnelManager struct {
        TunnelManager
        tunnelsLock         *sync.RWMutex
        tunnelUpdateChan    chan TunnelUpdate
        activeTunnelConfigs map[string]*Tunnel
        clientProcess       *exec.Cmd
        configBuilder       TunnelConfigBuilder
        config              *config.Config
        messenger           messenger.Messenger
        loginChan           chan bool // Signals when frpc logs in to server
        isLoggedIn          bool
        loginMutex          sync.RWMutex
}

type UpdateType string

const (
        STARTED UpdateType = "started"
        REMOVED UpdateType = "removed"
)

type TunnelUpdate struct {
        DeviceKey  uint64
        AppName    string
        LocalPort  uint64
        UpdateType UpdateType
        Protocol   Protocol
}

type FullURL struct {
        HttpURL  string `json:"httpURL"`
        HttpsURL string `json:"httpsURL"`
        TcpURL   string `json:"tcpURL"`
}

type Tunnel struct {
        Error  string
        Config TunnelConfig
}

type AppTunnel struct {
        Tunnel    *Tunnel
        Mutex     sync.Mutex
        Name      string
        DeviceKey uint64
        AppKey    uint64
        Main      bool
        Public    bool
        Running   bool
}

func InterfaceToPortForwardRule(dat []interface{}) ([]common.PortForwardRule, error) <span class="cov0" title="0">{
        portEntries := make([]common.PortForwardRule, 0, len(dat))

        for _, portEntry := range dat </span><span class="cov0" title="0">{
                jsonStr, err := json.Marshal(portEntry)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">var portEntry common.PortForwardRule
                err = json.Unmarshal(jsonStr, &amp;portEntry)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if portEntry.Protocol == "" </span><span class="cov0" title="0">{
                        portEntry.Protocol = "http"
                }</span>

                <span class="cov0" title="0">portEntries = append(portEntries, portEntry)</span>

        }
        <span class="cov0" title="0">return portEntries, nil</span>
}

func PortForwardRuleToInterface(portEntries []common.PortForwardRule) ([]interface{}, error) <span class="cov0" title="0">{
        portEntriesInterface := make([]interface{}, 0, len(portEntries))

        for _, portEntry := range portEntries </span><span class="cov0" title="0">{
                jsonStr, err := json.Marshal(portEntry)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">var portEntryInterface interface{}
                err = json.Unmarshal(jsonStr, &amp;portEntryInterface)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">portEntriesInterface = append(portEntriesInterface, portEntryInterface)</span>

        }
        <span class="cov0" title="0">return portEntriesInterface, nil</span>
}

type TunnelManager interface {
        AddTunnel(config TunnelConfig) (TunnelConfig, error)
        GetState() ([]TunnelState, error)
        GetStateById(tunnelID string) (TunnelState, error)
        RemoveTunnel(conf TunnelConfig) error
        GetTunnelConfig() ([]TunnelConfig, error)
        Get(tunnelID string) *Tunnel
        Status(tunnelID string) (TunnelStatus, error)
        Reload() error
        Start() error
        SaveRemotePorts(payload common.TransitionPayload) error
}

type TunnelStatus struct {
        Name       string   `json:"name"`
        Status     string   `json:"status"`
        LocalAddr  string   `json:"localAddr"`
        Plugin     string   `json:"plugin"`
        RemoteAddr string   `json:"remoteAddr"`
        RemotePort uint64   `json:"remotePort"`
        Error      string   `json:"error"`
        Protocol   Protocol `json:"protocol"`
}

type FrpStatus struct {
        Name       string `json:"name"`
        Type       string `json:"type"`
        Status     string `json:"status"`
        Err        string `json:"err"`
        LocalAddr  string `json:"local_addr"`
        Plugin     string `json:"plugin"`
        RemoteAddr string `json:"remote_addr"`
}

type TunnelState struct {
        Status       *TunnelStatus `json:"status"`
        AppName      string        `json:"app_name"`
        Port         uint64        `json:"port"`
        Active       bool          `json:"active"`
        Error        bool          `json:"error"`
        ErrorMessage string        `json:"error_message"`
        URL          string        `json:"url"`
}

func parseProxyStatus(text string) ([]TunnelStatus, error) <span class="cov0" title="0">{

        frpStatuses := make([]TunnelStatus, 0)

        frpStatusMap := make(map[string][]FrpStatus)
        err := json.Unmarshal([]byte(text), &amp;frpStatusMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, statusArray := range frpStatusMap </span><span class="cov0" title="0">{
                for _, frpStatus := range statusArray </span><span class="cov0" title="0">{

                        tunnelStatus := TunnelStatus{
                                Status:     frpStatus.Status,
                                Name:       frpStatus.Name,
                                LocalAddr:  frpStatus.LocalAddr,
                                Plugin:     frpStatus.Plugin,
                                RemoteAddr: frpStatus.RemoteAddr,
                                Error:      frpStatus.Err,
                                Protocol:   Protocol(frpStatus.Type),
                        }

                        if frpStatus.RemoteAddr != "" </span><span class="cov0" title="0">{
                                parts := strings.Split(frpStatus.RemoteAddr, ":")
                                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                        remotePortStr := parts[1]
                                        remotePort, err := strconv.ParseInt(remotePortStr, 10, 64)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error().Msgf("frpStatus.RemoteAddr: %s", frpStatus.RemoteAddr)
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">tunnelStatus.RemotePort = uint64(remotePort)</span>
                                } else<span class="cov0" title="0"> {
                                        log.Warn().Msgf("RemoteAddr does not contain port: %s", frpStatus.RemoteAddr)
                                }</span>
                        }

                        <span class="cov0" title="0">frpStatuses = append(frpStatuses, tunnelStatus)</span>
                }
        }

        <span class="cov0" title="0">return frpStatuses, nil</span>
}

var tunnelIdRegexp = regexp.MustCompile(`\[(([^\]]+)-(http|https|tcp|udp))]`)
var errMessageRegexp = regexp.MustCompile(`error: (.*)`)
var proxyNameRegex = regexp.MustCompile(`\[(\d+)-(.*)-(\d+)-(.*)\]`)

func (frpTm *FrpTunnelManager) Restart() error <span class="cov0" title="0">{
        log.Debug().Msg("Restarting tunnel client...")
        if frpTm.clientProcess == nil || frpTm.clientProcess.Process == nil </span><span class="cov0" title="0">{
                log.Error().Msg("frp client is not running")
                return errors.New("frp client is not running")
        }</span>

        <span class="cov0" title="0">err := frpTm.clientProcess.Process.Kill()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to kill frp client process")
                return err
        }</span>

        <span class="cov0" title="0">processState, err := frpTm.clientProcess.Process.Wait()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to wait for frp client process")
                return err
        }</span>

        <span class="cov0" title="0">log.Debug().Msgf("Tunnel client process exited with state: %+v\n", processState)

        time.Sleep(time.Second * 5)

        return frpTm.Start()</span>
}

func (frpTm *FrpTunnelManager) Start() error <span class="cov0" title="0">{
        log.Debug().Msg("Starting tunnel client")

        frpcPath := filesystem.GetTunnelBinaryPath(frpTm.config, "frpc")

        ctx, cancelNotifyContext := signal.NotifyContext(context.Background(), os.Interrupt)
        frpCommand := exec.CommandContext(ctx, frpcPath, "-c", frpTm.configBuilder.ConfigPath)
        frpCommand.Dir = filepath.Dir(frpcPath)

        frpTm.clientProcess = frpCommand

        stdout, err := frpCommand.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get stdout pipe for frp command")
                return err
        }</span>

        <span class="cov0" title="0">err = frpCommand.Start()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to start frp command")
                return err
        }</span>

        <span class="cov0" title="0">ackChan := make(chan bool)
        go func() </span><span class="cov0" title="0">{
                defer cancelNotifyContext()

                scanner := bufio.NewScanner(stdout)

                for scanner.Scan() </span><span class="cov0" title="0">{
                        line := scanner.Text()

                        if strings.Contains(line, "login to server success") </span><span class="cov0" title="0">{
                                // Mark as logged in
                                frpTm.loginMutex.Lock()
                                frpTm.isLoggedIn = true
                                frpTm.loginMutex.Unlock()

                                // Signal login (non-blocking)
                                select </span>{
                                case frpTm.loginChan &lt;- true:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                }

                                // Send initial ack for startup
                                <span class="cov0" title="0">ackChan &lt;- true</span>
                        }

                        // Error was found
                        <span class="cov0" title="0">if strings.Contains(line, "[E]") </span><span class="cov0" title="0">{
                                tunnelIdMatch := tunnelIdRegexp.FindStringSubmatch(line)
                                if len(tunnelIdMatch) &gt; 1 </span><span class="cov0" title="0">{
                                        tunnelID := tunnelIdMatch[1]

                                        errMatch := errMessageRegexp.FindStringSubmatch(line)
                                        if len(errMatch) &gt; 1 </span><span class="cov0" title="0">{
                                                errMessage := errMatch[1]
                                                frpTm.tunnelsLock.Lock()
                                                activeTunnel := frpTm.activeTunnelConfigs[tunnelID]
                                                if activeTunnel != nil </span><span class="cov0" title="0">{
                                                        activeTunnel.Error = errMessage
                                                }</span> else<span class="cov0" title="0"> {
                                                        log.Error().Msgf("failed to get tunnel with ID %s", tunnelID)
                                                }</span>
                                                <span class="cov0" title="0">frpTm.tunnelsLock.Unlock()</span>
                                        }

                                }

                                <span class="cov0" title="0">log.Error().Msgf("frp-err: %s", line)</span>

                        } else<span class="cov0" title="0"> {
                                proxyStarted := strings.Contains(line, "start proxy success")
                                proxyRemoved := strings.Contains(line, "proxy removed")
                                runAdminServerError := strings.Contains(line, "run admin server error")

                                if runAdminServerError </span><span class="cov0" title="0">{
                                        log.Debug().Msgf("Tunnel process failed to setup admin server: %s, attempting to restart..", line)

                                        // Reset the webserver port in case the port is in use
                                        frpTm.configBuilder.SetAdminPort()
                                        frpTm.Restart()

                                        return
                                }</span>

                                <span class="cov0" title="0">if proxyStarted || proxyRemoved </span><span class="cov0" title="0">{
                                        safe.Go(func() </span><span class="cov0" title="0">{
                                                matches := proxyNameRegex.FindStringSubmatch(line)

                                                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                                                        deviceKeyStr := matches[1]
                                                        appName := matches[2]
                                                        localPortStr := matches[3]
                                                        protocol := matches[4]

                                                        updateType := STARTED
                                                        if proxyRemoved </span><span class="cov0" title="0">{
                                                                updateType = REMOVED
                                                        }</span>

                                                        <span class="cov0" title="0">deviceKey, err := strconv.ParseInt(deviceKeyStr, 10, 64)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return
                                                        }</span>

                                                        <span class="cov0" title="0">localPort, err := strconv.ParseInt(localPortStr, 10, 64)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return
                                                        }</span>

                                                        <span class="cov0" title="0">tunnelUpdate := TunnelUpdate{
                                                                DeviceKey:  uint64(deviceKey),
                                                                AppName:    appName,
                                                                LocalPort:  uint64(localPort),
                                                                UpdateType: updateType,
                                                                Protocol:   Protocol(protocol),
                                                        }

                                                        frpTm.tunnelUpdateChan &lt;- tunnelUpdate</span>
                                                }

                                        })

                                        <span class="cov0" title="0">safe.Go(func() </span><span class="cov0" title="0">{
                                                // Wait for frpc to complete login to frps server
                                                // This prevents publishing "offline" state before connection is established
                                                frpTm.waitForLogin()

                                                err = frpTm.PublishTunnelState()
                                                if err != nil </span><span class="cov0" title="0">{
                                                        log.Error().Err(err).Msg("Failed to publish tunnel state")
                                                }</span>
                                        })
                                }

                                <span class="cov0" title="0">log.Info().Msgf("frp-out: %s", line)</span>
                        }
                }
        }()

        <span class="cov0" title="0">&lt;-ackChan

        return nil</span>
}

func (frpTm *FrpTunnelManager) Stop() error <span class="cov0" title="0">{
        return frpTm.clientProcess.Process.Kill()
}</span>

func (frpTm *FrpTunnelManager) Reset() error <span class="cov0" title="0">{
        frpTm.configBuilder.Reset()

        return frpTm.Reload()
}</span>

// waitForLogin waits for frpc to successfully login to frps server
// If already logged in, returns immediately
// If not logged in, waits up to 5 seconds for login confirmation
func (frpTm *FrpTunnelManager) waitForLogin() <span class="cov0" title="0">{
        frpTm.loginMutex.RLock()
        if frpTm.isLoggedIn </span><span class="cov0" title="0">{
                frpTm.loginMutex.RUnlock()
                log.Debug().Msg("frpc already logged in, publishing tunnel state immediately")
                return
        }</span>
        <span class="cov0" title="0">frpTm.loginMutex.RUnlock()

        log.Debug().Msg("Waiting for frpc login confirmation before publishing tunnel state")

        // Wait for login signal with timeout
        select </span>{
        case &lt;-frpTm.loginChan:<span class="cov0" title="0">
                log.Info().Msg("frpc login confirmed, proceeding with tunnel state publication")</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                log.Warn().Msg("Timeout waiting for frpc login, publishing tunnel state anyway")</span>
        }
}

func (frpTm *FrpTunnelManager) PublishTunnelState() error <span class="cov0" title="0">{
        updateTopic := common.BuildTunnelStateUpdate(frpTm.config.ReswarmConfig.SerialNumber)
        tunnelStates, err := frpTm.GetState()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var args []interface{}
        for _, tunnelState := range tunnelStates </span><span class="cov0" title="0">{
                args = append(args, tunnelState)
        }</span>

        <span class="cov0" title="0">return frpTm.messenger.Publish(topics.Topic(updateTopic), args, nil, nil)</span>
}

func NewFrpTunnelManager(messenger messenger.Messenger, config *config.Config) (*FrpTunnelManager, error) <span class="cov0" title="0">{

        configBuilder := NewTunnelConfigBuilder(config)
        frpTunnelManager := &amp;FrpTunnelManager{
                configBuilder:       configBuilder,
                messenger:           messenger,
                config:              config,
                tunnelsLock:         &amp;sync.RWMutex{},
                tunnelUpdateChan:    make(chan TunnelUpdate),
                activeTunnelConfigs: make(map[string]*Tunnel),
                loginChan:           make(chan bool, 10), // Buffered to avoid blocking
                isLoggedIn:          false,
        }

        return frpTunnelManager, nil
}</span>

func (frpTm *FrpTunnelManager) SetMessenger(messenger messenger.Messenger) <span class="cov0" title="0">{
        frpTm.messenger = messenger
}</span>

func (frpTm *FrpTunnelManager) reserveRemotePort(port uint64, protocol Protocol) (uint64, error) <span class="cov0" title="0">{
        args := []interface{}{
                common.Dict{
                        "port":     port,
                        "protocol": string(protocol),
                },
        }

        result, err := frpTm.messenger.Call(context.Background(), topics.ExposePort, args, common.Dict{}, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "Duplicate value") </span><span class="cov0" title="0">{
                        log.Debug().Msg("Port still exposed in backend, continuing...")
                        return port, nil
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }

        <span class="cov0" title="0">if result.Arguments == nil || len(result.Arguments) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("arguments is empty")
        }</span>

        <span class="cov0" title="0">payloadArg := result.Arguments[0]
        payload, ok := payloadArg.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return 0, errors.New("failed to parse payload")
        }</span>

        <span class="cov0" title="0">remotePortKw := payload["remote_port"]
        remotePort, ok := remotePortKw.(uint64)
        if !ok </span><span class="cov0" title="0">{
                return 0, errors.New("failed to parse port")
        }</span>

        <span class="cov0" title="0">return remotePort, nil</span>
}

func (frpTm *FrpTunnelManager) Reload() error <span class="cov0" title="0">{
        frpcPath := filesystem.GetTunnelBinaryPath(frpTm.config, "frpc")
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
        defer cancel()

        output, err := exec.CommandContext(ctx, frpcPath, "reload", "-c", frpTm.configBuilder.ConfigPath).CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                // frpc service is not properly running
                log.Error().Err(err).Msgf("Error while reloading frp client config: %s", string(output))
                if strings.Contains(string(output), "connect: connection refused") || strings.Contains(string(output), "api status code") </span><span class="cov0" title="0">{
                        log.Warn().Msg("frpc appears to not be running, attempting to start it")
                        safe.Go(func() </span><span class="cov0" title="0">{
                                startErr := frpTm.Start()
                                if startErr != nil </span><span class="cov0" title="0">{
                                        log.Error().Err(startErr).Msg("Failed to start frpc")
                                }</span>
                        })
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (frpTm *FrpTunnelManager) Get(tunnelID string) *Tunnel <span class="cov0" title="0">{
        frpTm.tunnelsLock.Lock()
        tunnel := frpTm.activeTunnelConfigs[tunnelID]
        frpTm.tunnelsLock.Unlock()

        return tunnel
}</span>

func (frpTm *FrpTunnelManager) buildURL(protocol Protocol, subdomain string, remotePort uint64) string <span class="cov0" title="0">{
        protocolString := string(protocol)

        if remotePort != 0 &amp;&amp; protocol != HTTP &amp;&amp; protocol != HTTPS </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s://%s.%s:%d", protocolString, subdomain, frpTm.configBuilder.BaseTunnelURL, remotePort)
        }</span>

        // we always have HTTPS since we tunnel to our HTTPS service
        <span class="cov0" title="0">if protocolString == "http" </span><span class="cov0" title="0">{
                protocolString = "https"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s://%s.%s", protocolString, subdomain, frpTm.configBuilder.BaseTunnelURL)</span>
}

func (frpTm *FrpTunnelManager) GetState() ([]TunnelState, error) <span class="cov0" title="0">{
        tunnelConfigs, err := frpTm.GetTunnelConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to get tunnel configs")
                return nil, err
        }</span>

        <span class="cov0" title="0">tunnelStatuses, err := frpTm.AllStatus()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to get tunnel statuses")
                return nil, err
        }</span>

        <span class="cov0" title="0">tunnelStates := make([]TunnelState, 0)
        for _, tunnelConfig := range tunnelConfigs </span><span class="cov0" title="0">{
                for _, tunnelStatus := range tunnelStatuses </span><span class="cov0" title="0">{
                        tunnelID := CreateTunnelID(tunnelConfig.Subdomain, string(tunnelConfig.Protocol))
                        if tunnelID != tunnelStatus.Name </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">tunnelState := TunnelState{
                                Status:       &amp;tunnelStatus,
                                Port:         tunnelConfig.LocalPort,
                                AppName:      tunnelConfig.AppName,
                                Error:        tunnelStatus.Error != "",
                                ErrorMessage: tunnelStatus.Error,
                                Active:       tunnelStatus.Status == "running",
                                URL:          frpTm.buildURL(tunnelConfig.Protocol, tunnelConfig.Subdomain, tunnelStatus.RemotePort),
                        }

                        tunnelStates = append(tunnelStates, tunnelState)</span>
                }

        }

        <span class="cov0" title="0">return tunnelStates, nil</span>
}

func (frpTm *FrpTunnelManager) GetStateById(tunnelID string) (TunnelState, error) <span class="cov0" title="0">{
        states, err := frpTm.GetState()
        if err != nil </span><span class="cov0" title="0">{
                return TunnelState{}, err
        }</span>

        <span class="cov0" title="0">for _, state := range states </span><span class="cov0" title="0">{
                if state.Status.Name == tunnelID </span><span class="cov0" title="0">{
                        return state, nil
                }</span>
        }

        <span class="cov0" title="0">return TunnelState{}, errdefs.ErrNotFound</span>
}

func (frpTm *FrpTunnelManager) GetTunnelConfig() ([]TunnelConfig, error) <span class="cov0" title="0">{
        return frpTm.configBuilder.GetTunnelConfig()
}</span>

func (frpTm *FrpTunnelManager) AllStatus() ([]TunnelStatus, error) <span class="cov0" title="0">{
        adminPort, err := frpTm.configBuilder.GetAdminPort()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to get admin port from config")
                return []TunnelStatus{}, err
        }</span>

        <span class="cov0" title="0">apiURL := fmt.Sprintf("http://127.0.0.1:%d/api/status", adminPort)

        ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
        defer cancel()

        req, err := http.NewRequestWithContext(ctx, "GET", apiURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to create HTTP request")
                return []TunnelStatus{}, err
        }</span>

        <span class="cov0" title="0">resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "connection refused") </span><span class="cov0" title="0">{
                        safe.Go(func() </span><span class="cov0" title="0">{
                                frpTm.Restart()
                        }</span>)
                        <span class="cov0" title="0">return []TunnelStatus{}, nil</span>
                }
                <span class="cov0" title="0">log.Error().Err(err).Msg("Failed to call frpc API")
                return []TunnelStatus{}, nil</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                log.Error().Msgf("frpc API returned status code: %d", resp.StatusCode)
                return []TunnelStatus{}, fmt.Errorf("API returned status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var statusResp map[string][]FrpStatus
        if err := json.NewDecoder(resp.Body).Decode(&amp;statusResp); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to decode JSON response")
                return []TunnelStatus{}, err
        }</span>

        // Convert map to flat array
        <span class="cov0" title="0">tunnelStatuses := make([]TunnelStatus, 0)
        for _, statusArray := range statusResp </span><span class="cov0" title="0">{
                for _, frpStatus := range statusArray </span><span class="cov0" title="0">{
                        tunnelStatus := TunnelStatus{
                                Status:     frpStatus.Status,
                                Name:       frpStatus.Name,
                                LocalAddr:  frpStatus.LocalAddr,
                                Plugin:     frpStatus.Plugin,
                                RemoteAddr: frpStatus.RemoteAddr,
                                Error:      frpStatus.Err,
                                Protocol:   Protocol(frpStatus.Type),
                        }

                        if frpStatus.RemoteAddr != "" </span><span class="cov0" title="0">{
                                parts := strings.Split(frpStatus.RemoteAddr, ":")
                                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                        remotePortStr := parts[1]
                                        remotePort, err := strconv.ParseInt(remotePortStr, 10, 64)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error().Msgf("frpStatus.RemoteAddr: %s", frpStatus.RemoteAddr)
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">tunnelStatus.RemotePort = uint64(remotePort)</span>
                                } else<span class="cov0" title="0"> {
                                        log.Warn().Msgf("RemoteAddr does not contain port: %s", frpStatus.RemoteAddr)
                                }</span>
                        }

                        <span class="cov0" title="0">tunnelStatuses = append(tunnelStatuses, tunnelStatus)</span>
                }
        }

        <span class="cov0" title="0">return tunnelStatuses, nil</span>
}

func (frpTm *FrpTunnelManager) Status(tunnelID string) (TunnelStatus, error) <span class="cov0" title="0">{
        // Use AllStatus and filter for the specific tunnel
        tunnelStatuses, err := frpTm.AllStatus()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Error while getting tunnel status")
                return TunnelStatus{}, err
        }</span>

        <span class="cov0" title="0">for _, tunnelStatus := range tunnelStatuses </span><span class="cov0" title="0">{
                if tunnelStatus.Name == tunnelID </span><span class="cov0" title="0">{
                        return tunnelStatus, nil
                }</span>
        }

        <span class="cov0" title="0">return TunnelStatus{}, errdefs.ErrNotFound</span>
}

// Tries to reserve an external port for kubernetes, updates the frpc client config and reloads the config file
func (frpTm *FrpTunnelManager) AddTunnel(config TunnelConfig) (TunnelConfig, error) <span class="cov0" title="0">{
        log.Debug().Str("subdomain", config.Subdomain).Str("protocol", string(config.Protocol)).Msg("AddTunnel called")
        // Don't need to reserve a port if the user starts an HTTP tunnel
        if config.Protocol != HTTP &amp;&amp; config.Protocol != HTTPS </span><span class="cov0" title="0">{
                // If no remote port is set, we will allocate one
                remotePort, err := frpTm.reserveRemotePort(config.RemotePort, config.Protocol)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Error while reserving remote port")
                        return TunnelConfig{}, err
                }</span>
                <span class="cov0" title="0">config.RemotePort = remotePort</span>
        }

        <span class="cov0" title="0">frpTm.configBuilder.AddTunnelConfig(config)

        err := frpTm.Reload()
        if err != nil </span><span class="cov0" title="0">{
                // Rollback the config change if reload fails
                frpTm.configBuilder.RemoveTunnelConfig(config)
                return TunnelConfig{}, err
        }</span>

        // for update := range frpTm.tunnelUpdateChan {
        //         if update.AppName == strings.ToLower(config.AppName) &amp;&amp;
        //                 update.LocalPort == config.LocalPort &amp;&amp;
        //                 update.Protocol == config.Protocol &amp;&amp;
        //                 update.UpdateType == STARTED {
        //                 break
        //         }
        // }

        <span class="cov0" title="0">tunnelId := CreateTunnelID(config.Subdomain, string(config.Protocol))
        frpTm.tunnelsLock.Lock()
        if frpTm.activeTunnelConfigs[tunnelId] == nil </span><span class="cov0" title="0">{
                frpTm.activeTunnelConfigs[tunnelId] = &amp;Tunnel{Config: config}
                frpTm.tunnelsLock.Unlock()
        }</span> else<span class="cov0" title="0"> {
                frpTm.tunnelsLock.Unlock()
                return TunnelConfig{}, errors.New("tunnel already exists")
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

func (frpTm *FrpTunnelManager) RemoveTunnel(conf TunnelConfig) error <span class="cov0" title="0">{
        log.Debug().Str("subdomain", conf.Subdomain).Str("protocol", string(conf.Protocol)).Msg("RemoveTunnel called")
        tunnelId := CreateTunnelID(conf.Subdomain, string(conf.Protocol))

        // Remove from active tunnels in memory (if exists)
        frpTm.tunnelsLock.Lock()
        if frpTm.activeTunnelConfigs[tunnelId] != nil </span><span class="cov0" title="0">{
                delete(frpTm.activeTunnelConfigs, tunnelId)
                log.Debug().Str("tunnelId", tunnelId).Msg("Removed tunnel from active configs")
        }</span> else<span class="cov0" title="0"> {
                log.Debug().Str("tunnelId", tunnelId).Msg("Tunnel not in active configs, but will remove from config file")
        }</span>
        <span class="cov0" title="0">frpTm.tunnelsLock.Unlock()

        // Always remove from config file regardless of whether it's in memory
        frpTm.configBuilder.RemoveTunnelConfig(conf)

        err := frpTm.Reload()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to reload after removing tunnel")
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (frpTm *FrpTunnelManager) SaveRemotePorts(payload common.TransitionPayload) error <span class="cov0" title="0">{
        // log.Debug().Str("app_key", fmt.Sprintf("%v", payload.AppKey)).Interface("payload", payload).Msg("SaveRemotePort called")

        update := []interface{}{common.Dict{
                "app_key":    payload.AppKey,
                "device_key": frpTm.config.ReswarmConfig.DeviceKey,
                "swarm_key":  frpTm.config.ReswarmConfig.SwarmKey,
                "stage":      payload.Stage,
                "ports":      payload.Ports,
                "foo":        "bar",
        }}
        log.Debug().Interface("update", update).Msg("Saving remote port with update payload")
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
        defer cancel()

        _, err := frpTm.messenger.Call(ctx, topics.SetActualAppOnDeviceState, update, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to save remote port")
                return err
        }</span>

        <span class="cov0" title="0">log.Info().Str("app_key", fmt.Sprintf("%v", payload.AppKey)).Msg("Remote port saved successfully")
        return nil</span>
}

func init() <span class="cov8" title="1">{
        // Set zerolog to use a pretty console writer for human-friendly logs
        log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: "2006-01-02 15:04:05"})
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
